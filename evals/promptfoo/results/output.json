{
  "evalId": "eval-Iyv-2026-02-06T19:33:51",
  "results": {
    "version": 3,
    "timestamp": "2026-02-06T19:33:51.671Z",
    "prompts": [
      {
        "raw": "function(context) {\n    return JSON.stringify(prompt);\n}",
        "label": "prompt-loader.js",
        "config": {},
        "id": "020b8dca03ee47e41d61a162d7650d02bc5409a9fa62b75bda18a2e446a2739d",
        "provider": "anthropic:messages:claude-sonnet-4-5-20250929",
        "metrics": {
          "score": 1.233046296299074,
          "testPassCount": 0,
          "testFailCount": 2,
          "testErrorCount": 0,
          "assertPassCount": 4,
          "assertFailCount": 2,
          "totalLatencyMs": 73011,
          "tokenUsage": {
            "prompt": 12067,
            "completion": 4272,
            "cached": 0,
            "total": 16339,
            "numRequests": 2,
            "completionDetails": {
              "reasoning": 0,
              "acceptedPrediction": 0,
              "rejectedPrediction": 0
            },
            "assertions": {
              "total": 0,
              "prompt": 0,
              "completion": 0,
              "cached": 0,
              "numRequests": 0,
              "completionDetails": {
                "reasoning": 0,
                "acceptedPrediction": 0,
                "rejectedPrediction": 0
              }
            }
          },
          "namedScores": {},
          "namedScoresCount": {},
          "cost": 0.100281
        }
      }
    ],
    "results": [
      {
        "cost": 0.047147999999999995,
        "error": "LINE_METRICS: line_acc=0.094 avg_iou=0.188 exact_match=0.000 within3=0.000 matched=1/2",
        "gradingResult": {
          "pass": false,
          "score": 0.6145833333333334,
          "reason": "LINE_METRICS: line_acc=0.094 avg_iou=0.188 exact_match=0.000 within3=0.000 matched=1/2",
          "namedScores": {},
          "tokensUsed": {
            "total": 0,
            "prompt": 0,
            "completion": 0,
            "cached": 0,
            "numRequests": 0
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "PARSE_OK: 2 suggestions parsed and validated"
            },
            {
              "pass": true,
              "score": 0.75,
              "reason": "JUDGE_METRICS sonnet_score=1.0000 gpt_score=0.5000 sonnet_coverage=1.0000 sonnet_validity=1.0000 gpt_coverage=0.5000 gpt_validity=0.5000\n\n--- SONNET JUDGE ---\ne this requires statistical analysis over many requests, it is a proven attack vector that allows signature forgery. The attacker can measure response times to determine correct signature bytes iteratively.\n\n## Step 2: Coverage\n\nReference bug 1: \"JWT algorithm confusion - accepting 'none' allows forged tokens\"\n- Status: FOUND by Suggestion 1\n- The suggestion correctly identifies that the code accepts 'none' algorithm and skips signature verification\n\nReference bug 2: \"Timing attack vulnerability - signature comparison is not constant-time\"\n- Status: FOUND by Suggestion 2\n- The suggestion correctly identifies the non-constant-time string comparison vulnerability\n\nCoverage: 2 out of 2 reference bugs found\n\ncoverage_score = 2/2 = 1.0\n\n## Step 3: Validity\n\nTotal suggestions: 2\nValid suggestions: 2 (both Suggestion 1 and Suggestion 2 are valid)\n\nvalidity_score = 2/2 = 1.0\n\n## Step 4: Final Score\n\ncoverage_score = 2/2 = 1.0\nvalidity_score = 2/2 = 1.0\nfinal_score = 1.0 * 0.5 + 1.0 * 0.5 = 1.0\n\n--- GPT JUDGE ---\nc input should be rejected/accepted incorrectly due to timing variance (i.e., a correctness failure), with a concrete observable output difference.\n- Actual output: The code still returns `null` for wrong signatures and non-null for correct signatures; the claim is about side-channel leakage, not a deterministic incorrect output for a specific input.\n- Verdict: INVALID\n- Reason: This is a security hardening/best-practice issue unless you can show a concrete, reproducible failing input/output pair where verification is bypassed. Timing side-channels don’t provide a direct single-call “actual output differs from expected output” example.\n\n## Step 2: Coverage\n- Reference bug 1 (JWT algorithm confusion - accepting 'none' allows forged tokens): FOUND\n- Reference bug 2 (Timing attack vulnerability - signature comparison is not constant-time): MISSED\n\n## Step 3: Validity\n- VALID suggestions: 1 / 2\n\ncoverage_score = 1/2 = 0.5\nvalidity_score = 1/2 = 0.5\nfinal_score = 0.5 * 0.5 + 0.5 * 0.5 = 0.5"
            },
            {
              "pass": false,
              "score": 0.09375,
              "reason": "LINE_METRICS: line_acc=0.094 avg_iou=0.188 exact_match=0.000 within3=0.000 matched=1/2"
            }
          ]
        },
        "id": "f8562d70-1139-4a55-9e67-b682cbf84622",
        "latencyMs": 34174,
        "namedScores": {},
        "prompt": {
          "raw": "[\n  {\n    \"role\": \"system\",\n    \"content\": \"You are Kody Bug-Hunter, a senior engineer specialized in identifying verifiable issues through mental code execution. Your mission is to detect bugs, performance problems, and security vulnerabilities that will actually occur in production by mentally simulating code execution.\\n\\n## Core Method: Mental Simulation\\n\\nInstead of pattern matching, you will mentally execute the code step-by-step focusing on critical points:\\n\\n- Function entry/exit points\\n- Conditional branches (if/else, switch)\\n- Loop boundaries and iterations\\n- Variable assignments and transformations\\n- Function calls and return values\\n- Resource allocation/deallocation\\n- Data structure operations\\n\\n### Multiple Execution Contexts\\n\\nSimulate the code in different execution contexts:\\n- **Repeated invocations**: What changes when the same code runs multiple times?\\n- **Parallel execution**: What happens when multiple executions overlap?\\n- **Delayed execution**: What state exists when deferred code actually runs?\\n- **State persistence**: What survives between executions and what gets reset?\\n- **Order of operations**: Verify that measurements and computations happen in the correct sequence (e.g., timers started before the operation they measure)\\n- **Cardinality analysis**: When iterating over collections, check if N operations are performed when M unique operations would suffice (where M << N)\\n\\n## Simulation Scenarios\\n\\nFor each critical code section, mentally execute with these scenarios:\\n1. **Happy path**: Expected valid inputs\\n2. **Edge cases**: Empty, null, undefined, zero values - especially verify that validation logic correctly handles falsy values (0, None, False, \\\"\\\") when checking for presence vs absence\\n3. **Boundary conditions**: Min/max values, array limits\\n4. **Error conditions**: Invalid inputs, failed operations\\n5. **Resource scenarios**: Memory limits, connection failures\\n6. **Invariant violations**: System constraints that must always hold (e.g., cache size limits, unique constraints)\\n7. **Failure cascades**: When one operation fails, what happens to dependent operations?\\n\\n## Detection Categories\\n\\n### BUG\\nA bug exists when mental simulation reveals:\\n- Execution breaks: Code throws unhandled exceptions\\n- Wrong results: Output doesn't match expected behavior\\n- Resource leaks: Unclosed files, connections, memory accumulation\\n- State corruption: Invalid object/data states\\n- Logic errors: Control flow produces incorrect outcomes\\n- Race conditions: Concurrent access causes inconsistent state or duplicates\\n- Incorrect measurements: Metrics/timings that don't reflect actual operations\\n- Invariant violations: Broken constraints (size limits, uniqueness, etc.)\\n- Async timing bugs: Variables captured incorrectly in async closures\\n- Conditional validation errors: Logic that checks for presence/absence of values using truthiness tests (e.g., `if dict.get(\\\"key\\\")`) that fail with falsy values (0, None, False, \\\"\\\"), when membership tests (e.g., `if \\\"key\\\" in dict`) should be used\\n- Dead computation: Code that computes/transforms values but never uses the result, instead using the original untransformed value - indicates copy-paste error or incomplete refactoring\\n- Unbounded growth: Collections (lists, dicts, sets) that grow indefinitely within loops without size limits, potentially causing memory exhaustion\\n- Duplicate operations: Same operation executed multiple times with identical inputs in sequence, wasting resources and potentially causing incorrect counts/metrics\\n\\n### Asynchronous Execution Analysis\\nWhen analyzing asynchronous code (setTimeout, setInterval, Promises, callbacks):\\n- **Closure State Capture**: What variable values exist when the async code ACTUALLY executes vs when it was SCHEDULED?\\n- **Loop Variable Binding**: In loops with async callbacks, verify if loop variables are captured correctly\\n- **Deferred State Access**: When callbacks execute later, is the accessed state still valid/expected?\\n- **Timing Dependencies**: What has changed between scheduling and execution?\\n- **Semantic Inconsistency**: When related operations produce data (logs, metrics, events) that should be correlatable but cannot be, due to inconsistencies in keys, names, or identifiers. E.g., one metric uses the tag {'id': x} while a related one uses {'identifier': x}, breaking aggregation and analysis capabilities.\\n- **Observability inconsistencies**: Related operations using different names for same dimensional data, breaking correlation\\n\\n### PERFORMANCE\\nA performance issue exists when mental simulation reveals:\\n- Algorithm complexity: O(n²) when O(n) is possible\\n- Redundant operations: Duplicate calculations, unnecessary loops, or early returns that force multiple operations when a single operation would suffice (e.g., fail-fast in batch processing that requires multiple requests to get complete feedback)\\n- Memory waste: Large allocations or leaks over time\\n- Blocking operations: Synchronous I/O in critical paths\\n- Database inefficiency: N+1, missing indexes, full scans\\n- Cache misses: Not leveraging available caching mechanisms\\n- Batch processing inefficiency: Validation or processing loops that return on first error instead of collecting all errors, forcing clients to make multiple requests to discover all issues\\n\\n### SECURITY\\nA security vulnerability exists when mental simulation reveals:\\n- Injection vulnerabilities: SQL/NoSQL/command/LDAP injection\\n- AuthZ/AuthN flaws: Missing checks, privilege escalation\\n- Data exposure: Sensitive data in logs, responses, or errors\\n- Crypto issues: Weak algorithms, hardcoded keys, improper validation\\n- Input validation gaps: Missing sanitization or bounds checks\\n- Session management: Predictable tokens or missing expiration\\n- Timing attacks: Direct string/value comparison of secrets, tokens, passwords, or authentication credentials that leaks information through execution time - must use constant-time comparison functions\\n- Insecure fallback values: Using empty strings, default values, or weak fallbacks for critical security parameters (encryption keys, secrets, tokens) when environment variables are missing - system should fail-fast instead\\n- Input validation bypass: User-controlled parameters (offsets, limits, indices, IDs) accepted without validation or with inadequate bounds checking, especially negative values in array slicing or pagination that could bypass access controls\\n- SSRF (Server-Side Request Forgery): Using user-controlled URLs in network operations (open, fetch, HTTP requests) without allowlist validation, enabling access to internal resources or arbitrary external sites\\n- Case-sensitivity bypass: Inconsistent normalization in comparisons of case-insensitive data (emails, usernames, domains) where one side is normalized (toLowerCase/toUpperCase) but the other isn't, allowing bypass through case variations\\n\\n## Severity Assessment\\n\\nFor each confirmed issue, evaluate severity based on impact and scope:\\n\\n**CRITICAL** - Immediate and severe impact\\nApplication crash/downtime\\nData loss/corruption\\nSecurity breach (unauthorized access/data exfiltration)\\nCritical operation failure (auth/payment/authorization)\\nDirect financial loss operations\\nMemory leaks that inevitably crash production\\n\\n**HIGH** - Significant but not immediate impact\\nImportant functionality broken\\nMemory leaks that cause eventual crash\\nPerformance degradation affecting UX under normal load\\nSecurity issues with indirect exploitation paths\\nFinancial calculation errors affecting revenue\\n\\n**MEDIUM** - Moderate impact\\nPartially broken functionality\\nPerformance issues in specific scenarios\\nSecurity weaknesses requiring specific conditions\\nIncorrect but recoverable data\\nNon-critical business logic errors with workarounds\\n\\n**LOW** - Minimal impact\\nMinor performance overhead\\nLow-risk security improvements\\nIncorrect metrics/logs\\nRarely affecting few users\\nEdge-case issues\\n\\n## Analysis Rules\\n\\n### MUST DO:\\n1. **Focus ONLY on verifiable issues** - Must be able to confirm with available context\\n2. **Analyze ONLY added lines** - Lines prefixed with '+' in the diff\\n3. **Consider ONLY bugs, performance, and security** - NO style, formatting, or preferences\\n4. **Simulate actual execution** - Trace through code paths mentally\\n5. **Verify with concrete scenarios** - Use realistic inputs and conditions\\n6. **Trace resource lifecycle** - For any stateful resource (caches, maps, collections), verify both creation AND cleanup\\n7. **Validate deduplication opportunities** - When performing operations in loops, check if duplicate work can be eliminated\\n8. **Verify Identifier Consistency in Observability** - When simulating code that emits observability data, actively compare names and keys of related events. Verify identifiers for same logical entity are named identically (e.g., 'card' not 'cards'). Also detect duplicate emissions of same metric/log with identical values in sequential execution.\\n9. **Track variable usage** - When code creates and modifies local variables, verify the processed variable is actually used in output/return, not the original unprocessed version. When analyzing validation or conditional logic, simulate with falsy values (0, None, False, \\\"\\\") to verify the logic checks what it intends to check (presence vs truthiness)\\n10. **Check for unbounded collection growth** - When collections are modified inside loops, verify there are size limits to prevent memory exhaustion, especially with pagination or external data\\n11. **Verify consistent normalization** - When code normalizes case-insensitive data (emails, usernames) on one side of a comparison, verify BOTH sides are normalized to prevent bypass through case variations\\n12. **Use constant-time comparison for secrets** - When comparing authentication secrets, tokens, or credentials, verify code uses constant-time comparison functions not direct comparison operators or standard equality methods\\n13. **Reject insecure fallbacks for secrets** - When code uses `|| 'fallback'` with environment variables for encryption keys, secrets, or credentials, verify it fails-fast instead of using empty/default values\\n14. **Validate user-controlled indices** - When user input (cursor offset, page number, array index) is used in slicing/indexing, verify bounds validation prevents negative values or out-of-range access\\n15. **Detect SSRF in network calls** - When code calls network operations (open(), fetch(), HTTP.get(), requests.get()) with variables as URLs (not hardcoded strings), flag as SSRF vulnerability unless allowlist validation is present in same function\\n\\n### MUST NOT DO:\\n- **NO speculation whatsoever** - If you cannot trace the exact execution path that causes the issue, DO NOT report it\\n- **NO \\\"could\\\", \\\"might\\\", \\\"possibly\\\"** - Only report what WILL definitely happen\\n- **NO assumptions about external behavior** - Don't assume how external APIs, callbacks, user code, or imported functions/constants/utilities behave. If you cannot see the implementation in the provided code, do not make assumptions about it.\\n- **NO assumptions about imported code structure** - If code imports from another file, don't assume whether it's a function, constant, class, or what parameters it accepts. Only analyze what you can see being used in the visible code.\\n- **NO defensive programming as bugs** - Missing try-catch, validation, or error handling is NOT a bug unless you can prove it causes actual failure\\n- **NO theoretical edge cases** - Must be able to demonstrate with concrete, realistic values\\n- **NO \\\"if the user does X\\\"** - Unless you can prove X is a normal, expected usage\\n- **NO style or best practices** - Zero suggestions about code organization, naming, or preferences\\n- **NO potential issues** - Only report issues you can reproduce mentally with specific inputs\\n- **NO \\\"in production this could...\\\"** - Must be able to prove it WILL happen, not that it COULD happen\\n- **NO assuming missing code is wrong** - If code isn't shown, don't assume it exists or how it works\\n- **NO indentation-related issues** - Never report issues where the root cause is indentation, spacing, or whitespace - even if you believe it causes syntax errors, parsing failures, or runtime crashes. Indentation problems are NOT bugs.\\n- **ONLY report if you can provide**:\\n  1. Exact input values that trigger the issue\\n  2. Step-by-step execution trace showing the failure\\n  3. The specific line where the failure occurs\\n  4. The exact incorrect behavior that results\\n  5. **Proof that the issue exists in VISIBLE code only** - if the bug depends on behavior of imported code you cannot see, you CANNOT report it\\n\\n## Analysis Process\\n\\n1. **Understand PR intent** from summary as context for expected behavior\\n2. **Identify critical points** in the changed code (+lines only)\\n3. **Simulate execution** through each critical path considering:\\n   - Variable initialization order vs usage order\\n   - Number of unique operations vs total iterations\\n   - Resource accumulation without corresponding cleanup\\n3.5. **For async code**: Track variable values at SCHEDULING time vs EXECUTION time\\n3.6. **For operations that can fail**: Verify ALL failure paths are handled and system invariants maintained\\n3.7. **For network operations**: When you see open(), fetch(), HTTP requests with variable URLs, immediately flag as SSRF unless you see URL validation (allowlist, domain check, URI parse with host verification) in the same code block\\n4. **Test concrete scenarios** on each path with realistic inputs\\n5. **Detect verifiable issues** where behavior is definitively problematic\\n6. **Confirm with available context** - must be provable with given information\\n   - Can you see ALL the code involved in the bug? If NO → DO NOT REPORT\\n   - Does the bug depend on imported function behavior? If YES and you can't see the import → DO NOT REPORT\\n   - Are you assuming what an imported function/constant contains? If YES → DO NOT REPORT\\n6.1. **Special case - inline to function refactoring**: When code changes from prop: value to myFunction(value), the function almost certainly returns an object with prop included. You cannot see inside myFunction, so you CANNOT report missing properties as bugs.\\n6.2. **Indentation check**: If your issue involves the words \\\"indent\\\", \\\"spacing\\\", \\\"whitespace\\\", or \\\"same level\\\", STOP - do not report it.\\n7. **Assess severity** of confirmed issues based on impact and scope\\n\\n\\n## Output Requirements\\n\\n- Report ONLY issues you can definitively prove will occur\\n- Focus ONLY on bugs, performance, and security categories\\n- Use PR summary as auxiliary context, not absolute truth\\n- Be precise and concise in descriptions\\n- Always respond in en-US language\\n- Return ONLY the JSON object, no additional text\\n\\n### Issue description\\n\\nCustom instructions for 'suggestionContent'\\nIMPORTANT none of these instructions should be taken into consideration for any other fields such as 'improvedCode'\\n\\nDetailed and verifiable issue description\\n\\n### LLM Prompt\\n\\nCreate a field called 'llmPrompt', this field must contain an accurate description of the issue as well as relevant context which lead to finding that issue.\\nThis is a prompt for another LLM, the user must be able to simply copy this text and paste it into another LLM and have it produce useful results.\\nThis must be a prompt from the perspective of the user, it will communicate directly with the LLM as though it were sent as a chat message from the user, it should be a prompt a user could input into an LLM.\\n\\nIMPORTANT, on this field you must only focus on describing the issue and providing context in a manner that an LLM will understand as a prompt.\\nThe existing code, improved code, relevant line start and end, file path, etc. will all be provided elsewhere.\\nDO NOT under any circumstances provide any sort of code block in this field, like for example: ```python def foo(): .... ```\\n\\n### Response format\\n\\nReturn only valid JSON, nothing more. Under no circumstances should there be any text of any kind before the ```json or after the final ```, use the following JSON format:\\n\\n```json\\n{\\n    \\\"codeSuggestions\\\": [\\n        {\\n            \\\"relevantFile\\\": \\\"path/to/file\\\",\\n            \\\"language\\\": \\\"programming_language\\\",\\n            \\\"suggestionContent\\\": \\\"The full issue description\\\",\\n            \\\"existingCode\\\": \\\"Problematic code from PR\\\",\\n            \\\"improvedCode\\\": \\\"Fixed code proposal\\\",\\n            \\\"oneSentenceSummary\\\": \\\"Concise issue description\\\",\\n            \\\"relevantLinesStart\\\": \\\"starting_line\\\",\\n            \\\"relevantLinesEnd\\\": \\\"ending_line\\\",\\n            \\\"label\\\": \\\"bug|performance|security\\\",\\n            \\\"severity\\\": \\\"low|medium|high|critical\\\",\\n            \\\"llmPrompt\\\": \\\"Prompt for LLMs\\\"\\n        }\\n    ]\\n}\\n```\\n\"\n  },\n  {\n    \"role\": \"user\",\n    \"content\": \"## Code Under Review\\nMentally execute the changed code through multiple scenarios and identify real bugs that will break in production.\\n\\nPR Summary:\\n```\\n\\n```\\n\\nComplete File Content:\\n```\\nimport * as crypto from 'crypto';\\n\\nexport interface JwtPayload {\\n  sub: string;\\n  iat: number;\\n  exp: number;\\n  iss?: string;\\n  aud?: string;\\n  [key: string]: unknown;\\n}\\n\\nexport interface JwtHeader {\\n  alg: string;\\n  typ: string;\\n}\\n\\nexport interface JwtConfig {\\n  secret: string;\\n  issuer: string;\\n  audience: string;\\n  expiresIn: number;\\n}\\n\\nfunction base64UrlEncode(data: string | Buffer): string {\\n  const base64 = Buffer.from(data).toString('base64');\\n  return base64.replace(/\\\\+/g, '-').replace(/\\\\//g, '_').replace(/=+$/, '');\\n}\\n\\nfunction base64UrlDecode(data: string): string {\\n  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\\n  const padding = base64.length % 4;\\n  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\\n  return Buffer.from(padded, 'base64').toString();\\n}\\n\\nexport class JwtService {\\n  private config: JwtConfig;\\n\\n  constructor(config: JwtConfig) {\\n    this.config = config;\\n  }\\n\\n  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\\n    const now = Math.floor(Date.now() / 1000);\\n\\n    const header: JwtHeader = {\\n      alg: 'HS256',\\n      typ: 'JWT',\\n    };\\n\\n    const fullPayload: JwtPayload = {\\n      ...payload,\\n      iat: now,\\n      exp: now + this.config.expiresIn,\\n      iss: this.config.issuer,\\n      aud: this.config.audience,\\n    };\\n\\n    const headerEncoded = base64UrlEncode(JSON.stringify(header));\\n    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\\n\\n    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n\\n    return `${headerEncoded}.${payloadEncoded}.${signature}`;\\n  }\\n\\n  verify(token: string): JwtPayload | null {\\n    const parts = token.split('.');\\n    if (parts.length !== 3) {\\n      return null;\\n    }\\n\\n    const [headerEncoded, payloadEncoded, signature] = parts;\\n\\n    try {\\n      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\\n      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\\n\\n      // Verify algorithm\\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\\n        return null;\\n      }\\n\\n      // Verify signature\\n      if (header.alg !== 'none') {\\n        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n        if (signature !== expectedSignature) {\\n          return null;\\n        }\\n      }\\n\\n      // Check expiration\\n      const now = Math.floor(Date.now() / 1000);\\n      if (payload.exp && payload.exp < now) {\\n        return null;\\n      }\\n\\n      // Verify issuer and audience\\n      if (payload.iss !== this.config.issuer) {\\n        return null;\\n      }\\n\\n      if (payload.aud !== this.config.audience) {\\n        return null;\\n      }\\n\\n      return payload;\\n    } catch {\\n      return null;\\n    }\\n  }\\n\\n  private createSignature(data: string): string {\\n    const hmac = crypto.createHmac('sha256', this.config.secret);\\n    hmac.update(data);\\n    return base64UrlEncode(hmac.digest());\\n  }\\n\\n  decode(token: string): JwtPayload | null {\\n    const parts = token.split('.');\\n    if (parts.length !== 3) {\\n      return null;\\n    }\\n\\n    try {\\n      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\\n    } catch {\\n      return null;\\n    }\\n  }\\n\\n  refresh(token: string): string | null {\\n    const payload = this.verify(token);\\n    if (!payload) {\\n      return null;\\n    }\\n\\n    const { iat, exp, ...rest } = payload;\\n    return this.sign(rest);\\n  }\\n\\n  isExpired(token: string): boolean {\\n    const payload = this.decode(token);\\n    if (!payload || !payload.exp) {\\n      return true;\\n    }\\n\\n    const now = Math.floor(Date.now() / 1000);\\n    return payload.exp < now;\\n  }\\n}\\n\\nexport function createJwtService(config: JwtConfig): JwtService {\\n  return new JwtService(config);\\n}\\n```\\n\\nCode Diff (PR Changes):\\n```\\n## file: 'packages/auth/src/jwt/JwtService.ts'\\n\\n@@ -0,0 +1,156 @@\\n__new hunk__\\n1 +import * as crypto from 'crypto';\\n2 +\\n3 +export interface JwtPayload {\\n4 +  sub: string;\\n5 +  iat: number;\\n6 +  exp: number;\\n7 +  iss?: string;\\n8 +  aud?: string;\\n9 +  [key: string]: unknown;\\n10 +}\\n11 +\\n12 +export interface JwtHeader {\\n13 +  alg: string;\\n14 +  typ: string;\\n15 +}\\n16 +\\n17 +export interface JwtConfig {\\n18 +  secret: string;\\n19 +  issuer: string;\\n20 +  audience: string;\\n21 +  expiresIn: number;\\n22 +}\\n23 +\\n24 +function base64UrlEncode(data: string | Buffer): string {\\n25 +  const base64 = Buffer.from(data).toString('base64');\\n26 +  return base64.replace(/\\\\+/g, '-').replace(/\\\\//g, '_').replace(/=+$/, '');\\n27 +}\\n28 +\\n29 +function base64UrlDecode(data: string): string {\\n30 +  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\\n31 +  const padding = base64.length % 4;\\n32 +  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\\n33 +  return Buffer.from(padded, 'base64').toString();\\n34 +}\\n35 +\\n36 +export class JwtService {\\n37 +  private config: JwtConfig;\\n38 +\\n39 +  constructor(config: JwtConfig) {\\n40 +    this.config = config;\\n41 +  }\\n42 +\\n43 +  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\\n44 +    const now = Math.floor(Date.now() / 1000);\\n45 +\\n46 +    const header: JwtHeader = {\\n47 +      alg: 'HS256',\\n48 +      typ: 'JWT',\\n49 +    };\\n50 +\\n51 +    const fullPayload: JwtPayload = {\\n52 +      ...payload,\\n53 +      iat: now,\\n54 +      exp: now + this.config.expiresIn,\\n55 +      iss: this.config.issuer,\\n56 +      aud: this.config.audience,\\n57 +    };\\n58 +\\n59 +    const headerEncoded = base64UrlEncode(JSON.stringify(header));\\n60 +    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\\n61 +\\n62 +    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n63 +\\n64 +    return `${headerEncoded}.${payloadEncoded}.${signature}`;\\n65 +  }\\n66 +\\n67 +  verify(token: string): JwtPayload | null {\\n68 +    const parts = token.split('.');\\n69 +    if (parts.length !== 3) {\\n70 +      return null;\\n71 +    }\\n72 +\\n73 +    const [headerEncoded, payloadEncoded, signature] = parts;\\n74 +\\n75 +    try {\\n76 +      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\\n77 +      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\\n78 +\\n79 +      // Verify algorithm\\n80 +      if (header.alg !== 'HS256' && header.alg !== 'none') {\\n81 +        return null;\\n82 +      }\\n83 +\\n84 +      // Verify signature\\n85 +      if (header.alg !== 'none') {\\n86 +        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n87 +        if (signature !== expectedSignature) {\\n88 +          return null;\\n89 +        }\\n90 +      }\\n91 +\\n92 +      // Check expiration\\n93 +      const now = Math.floor(Date.now() / 1000);\\n94 +      if (payload.exp && payload.exp < now) {\\n95 +        return null;\\n96 +      }\\n97 +\\n98 +      // Verify issuer and audience\\n99 +      if (payload.iss !== this.config.issuer) {\\n100 +        return null;\\n101 +      }\\n102 +\\n103 +      if (payload.aud !== this.config.audience) {\\n104 +        return null;\\n105 +      }\\n106 +\\n107 +      return payload;\\n108 +    } catch {\\n109 +      return null;\\n110 +    }\\n111 +  }\\n112 +\\n113 +  private createSignature(data: string): string {\\n114 +    const hmac = crypto.createHmac('sha256', this.config.secret);\\n115 +    hmac.update(data);\\n116 +    return base64UrlEncode(hmac.digest());\\n117 +  }\\n118 +\\n119 +  decode(token: string): JwtPayload | null {\\n120 +    const parts = token.split('.');\\n121 +    if (parts.length !== 3) {\\n122 +      return null;\\n123 +    }\\n124 +\\n125 +    try {\\n126 +      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\\n127 +    } catch {\\n128 +      return null;\\n129 +    }\\n130 +  }\\n131 +\\n132 +  refresh(token: string): string | null {\\n133 +    const payload = this.verify(token);\\n134 +    if (!payload) {\\n135 +      return null;\\n136 +    }\\n137 +\\n138 +    const { iat, exp, ...rest } = payload;\\n139 +    return this.sign(rest);\\n140 +  }\\n141 +\\n142 +  isExpired(token: string): boolean {\\n143 +    const payload = this.decode(token);\\n144 +    if (!payload || !payload.exp) {\\n145 +      return true;\\n146 +    }\\n147 +\\n148 +    const now = Math.floor(Date.now() / 1000);\\n149 +    return payload.exp < now;\\n150 +  }\\n151 +}\\n152 +\\n153 +export function createJwtService(config: JwtConfig): JwtService {\\n154 +  return new JwtService(config);\\n155 +}\\n156 +\\n__old hunk__\\n```\\n\\nUse the PR summary to understand the intended changes, then simulate execution of the modified code (+lines) to detect bugs that will actually occur in production.\"\n  }\n]",
          "label": "prompt-loader.js",
          "config": {}
        },
        "promptId": "020b8dca03ee47e41d61a162d7650d02bc5409a9fa62b75bda18a2e446a2739d",
        "promptIdx": 0,
        "provider": {
          "id": "anthropic:messages:claude-sonnet-4-5-20250929",
          "label": ""
        },
        "response": {
          "output": "```json\n{\n    \"codeSuggestions\": [\n        {\n            \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n            \"language\": \"typescript\",\n            \"suggestionContent\": \"CRITICAL SECURITY VULNERABILITY: The JWT verification logic accepts tokens with algorithm 'none', which completely bypasses signature verification. When a token has `alg: 'none'` in its header, lines 85-90 skip signature validation entirely, allowing any attacker to forge valid tokens by simply setting the algorithm to 'none' and omitting the signature. This is a well-known JWT vulnerability (CVE-2015-9235) that enables complete authentication bypass.\\n\\nMental execution trace:\\n1. Attacker creates token with header `{alg: 'none', typ: 'JWT'}`\\n2. Attacker creates payload with any claims: `{sub: 'admin', iat: 1234567890, exp: 9999999999, iss: 'configured_issuer', aud: 'configured_audience'}`\\n3. Attacker encodes header and payload, provides empty or any signature\\n4. verify() is called with this token\\n5. Line 80: `header.alg !== 'HS256' && header.alg !== 'none'` evaluates to false (because alg IS 'none')\\n6. Line 85: `header.alg !== 'none'` evaluates to false, so signature verification is SKIPPED\\n7. Lines 93-105: Expiration, issuer, and audience checks pass if attacker uses correct values\\n8. Line 107: Returns the forged payload as valid\\n\\nResult: Complete authentication bypass - attacker gains access as any user.\",\n            \"existingCode\": \"      // Verify algorithm\\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\\n        return null;\\n      }\\n\\n      // Verify signature\\n      if (header.alg !== 'none') {\\n        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n        if (signature !== expectedSignature) {\\n          return null;\\n        }\\n      }\",\n            \"improvedCode\": \"      // Verify algorithm - only HS256 is allowed\\n      if (header.alg !== 'HS256') {\\n        return null;\\n      }\\n\\n      // Verify signature\\n      const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n      if (signature !== expectedSignature) {\\n        return null;\\n      }\",\n            \"oneSentenceSummary\": \"JWT verification accepts 'none' algorithm, allowing attackers to forge tokens and bypass authentication completely\",\n            \"relevantLinesStart\": \"79\",\n            \"relevantLinesEnd\": \"90\",\n            \"label\": \"security\",\n            \"severity\": \"critical\",\n            \"llmPrompt\": \"I'm analyzing a JWT verification implementation and found a critical security vulnerability. The code accepts tokens with algorithm 'none' which bypasses signature verification entirely. Here's the problematic logic:\\n\\nThe verification checks if the algorithm is either 'HS256' OR 'none', accepting both. Then it only verifies the signature if the algorithm is NOT 'none'. This means an attacker can:\\n1. Create a token with header {alg: 'none', typ: 'JWT'}\\n2. Set any payload claims they want (including admin privileges)\\n3. The token passes algorithm validation because 'none' is explicitly allowed\\n4. Signature verification is skipped because alg === 'none'\\n5. The forged token is accepted as valid\\n\\nThis is the infamous 'none' algorithm vulnerability (CVE-2015-9235) that allows complete authentication bypass. The fix is to reject any algorithm that isn't 'HS256' and always verify signatures. Can you explain why accepting the 'none' algorithm is dangerous and provide the correct implementation that only accepts 'HS256'?\"\n        },\n        {\n            \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n            \"language\": \"typescript\",\n            \"suggestionContent\": \"CRITICAL SECURITY VULNERABILITY: Timing attack vulnerability in signature verification. Line 87 uses direct string comparison (`!==`) to compare the provided signature with the expected signature. This comparison leaks information through execution time - it returns false as soon as it finds the first mismatching character, taking less time for incorrect signatures that differ early versus those that match more characters.\\n\\nMental execution trace with two attack attempts:\\n\\nAttempt 1 - signature starts with 'A':\\n1. Line 87: 'Axyz...' !== 'Bxyz...' \\n2. Comparison fails at first character, returns immediately (~1 microsecond)\\n\\nAttempt 2 - signature starts with 'B':\\n1. Line 87: 'Bxyz...' !== 'Buvw...'\\n2. First char matches, continues comparing\\n3. Fails at second character, returns (~2 microseconds)\\n\\nBy measuring response times across thousands of requests, an attacker can determine correct signature bytes one at a time, eventually reconstructing valid signatures without knowing the secret key. This is a well-documented attack against authentication systems.\\n\\nThe fix requires using a constant-time comparison function that always compares all bytes regardless of where differences occur, preventing timing information leakage.\",\n            \"existingCode\": \"        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n        if (signature !== expectedSignature) {\\n          return null;\\n        }\",\n            \"improvedCode\": \"        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\\n        if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {\\n          return null;\\n        }\",\n            \"oneSentenceSummary\": \"Direct string comparison of JWT signatures leaks timing information, enabling attackers to forge valid signatures through timing attacks\",\n            \"relevantLinesStart\": \"86\",\n            \"relevantLinesEnd\": \"89\",\n            \"label\": \"security\",\n            \"severity\": \"critical\",\n            \"llmPrompt\": \"I'm reviewing JWT signature verification code and identified a timing attack vulnerability. The code compares the provided signature with the expected signature using direct string comparison (the !== operator):\\n\\nThe problem is that string comparison in most languages (including JavaScript) is not constant-time - it returns false as soon as it finds the first character that doesn't match. This means:\\n- A signature that differs in the first byte fails very quickly\\n- A signature that matches the first 10 bytes but differs in the 11th takes longer to fail\\n\\nAn attacker can exploit this by:\\n1. Trying many signatures and measuring response times\\n2. Finding which first byte takes longest to reject (that's the correct first byte)\\n3. Fixing that byte and repeating for the second byte\\n4. Continuing until they've reconstructed the entire valid signature\\n\\nThis is a well-known attack against authentication systems. The solution is to use a constant-time comparison function like crypto.timingSafeEqual() that always compares all bytes regardless of where differences occur, preventing timing information leakage. Can you explain why this timing attack works and how constant-time comparison prevents it?\"\n        }\n    ]\n}\n```",
          "tokenUsage": {
            "total": 8564,
            "prompt": 6776,
            "completion": 1788
          },
          "finishReason": "stop",
          "cost": 0.047147999999999995
        },
        "score": 0.6145833333333334,
        "success": false,
        "testCase": {
          "description": "Example 1: packages/auth/src/jwt/JwtService.ts",
          "vars": {
            "fileContent": "import * as crypto from 'crypto';\n\nexport interface JwtPayload {\n  sub: string;\n  iat: number;\n  exp: number;\n  iss?: string;\n  aud?: string;\n  [key: string]: unknown;\n}\n\nexport interface JwtHeader {\n  alg: string;\n  typ: string;\n}\n\nexport interface JwtConfig {\n  secret: string;\n  issuer: string;\n  audience: string;\n  expiresIn: number;\n}\n\nfunction base64UrlEncode(data: string | Buffer): string {\n  const base64 = Buffer.from(data).toString('base64');\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\n\nfunction base64UrlDecode(data: string): string {\n  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n  const padding = base64.length % 4;\n  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n  return Buffer.from(padded, 'base64').toString();\n}\n\nexport class JwtService {\n  private config: JwtConfig;\n\n  constructor(config: JwtConfig) {\n    this.config = config;\n  }\n\n  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n    const now = Math.floor(Date.now() / 1000);\n\n    const header: JwtHeader = {\n      alg: 'HS256',\n      typ: 'JWT',\n    };\n\n    const fullPayload: JwtPayload = {\n      ...payload,\n      iat: now,\n      exp: now + this.config.expiresIn,\n      iss: this.config.issuer,\n      aud: this.config.audience,\n    };\n\n    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n\n    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n\n    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n  }\n\n  verify(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    const [headerEncoded, payloadEncoded, signature] = parts;\n\n    try {\n      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n\n      // Verify algorithm\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\n        return null;\n      }\n\n      // Verify signature\n      if (header.alg !== 'none') {\n        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n        if (signature !== expectedSignature) {\n          return null;\n        }\n      }\n\n      // Check expiration\n      const now = Math.floor(Date.now() / 1000);\n      if (payload.exp && payload.exp < now) {\n        return null;\n      }\n\n      // Verify issuer and audience\n      if (payload.iss !== this.config.issuer) {\n        return null;\n      }\n\n      if (payload.aud !== this.config.audience) {\n        return null;\n      }\n\n      return payload;\n    } catch {\n      return null;\n    }\n  }\n\n  private createSignature(data: string): string {\n    const hmac = crypto.createHmac('sha256', this.config.secret);\n    hmac.update(data);\n    return base64UrlEncode(hmac.digest());\n  }\n\n  decode(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  refresh(token: string): string | null {\n    const payload = this.verify(token);\n    if (!payload) {\n      return null;\n    }\n\n    const { iat, exp, ...rest } = payload;\n    return this.sign(rest);\n  }\n\n  isExpired(token: string): boolean {\n    const payload = this.decode(token);\n    if (!payload || !payload.exp) {\n      return true;\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n    return payload.exp < now;\n  }\n}\n\nexport function createJwtService(config: JwtConfig): JwtService {\n  return new JwtService(config);\n}\n",
            "patchWithLinesStr": "## file: 'packages/auth/src/jwt/JwtService.ts'\n\n@@ -0,0 +1,156 @@\n__new hunk__\n1 +import * as crypto from 'crypto';\n2 +\n3 +export interface JwtPayload {\n4 +  sub: string;\n5 +  iat: number;\n6 +  exp: number;\n7 +  iss?: string;\n8 +  aud?: string;\n9 +  [key: string]: unknown;\n10 +}\n11 +\n12 +export interface JwtHeader {\n13 +  alg: string;\n14 +  typ: string;\n15 +}\n16 +\n17 +export interface JwtConfig {\n18 +  secret: string;\n19 +  issuer: string;\n20 +  audience: string;\n21 +  expiresIn: number;\n22 +}\n23 +\n24 +function base64UrlEncode(data: string | Buffer): string {\n25 +  const base64 = Buffer.from(data).toString('base64');\n26 +  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n27 +}\n28 +\n29 +function base64UrlDecode(data: string): string {\n30 +  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n31 +  const padding = base64.length % 4;\n32 +  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n33 +  return Buffer.from(padded, 'base64').toString();\n34 +}\n35 +\n36 +export class JwtService {\n37 +  private config: JwtConfig;\n38 +\n39 +  constructor(config: JwtConfig) {\n40 +    this.config = config;\n41 +  }\n42 +\n43 +  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n44 +    const now = Math.floor(Date.now() / 1000);\n45 +\n46 +    const header: JwtHeader = {\n47 +      alg: 'HS256',\n48 +      typ: 'JWT',\n49 +    };\n50 +\n51 +    const fullPayload: JwtPayload = {\n52 +      ...payload,\n53 +      iat: now,\n54 +      exp: now + this.config.expiresIn,\n55 +      iss: this.config.issuer,\n56 +      aud: this.config.audience,\n57 +    };\n58 +\n59 +    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n60 +    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n61 +\n62 +    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n63 +\n64 +    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n65 +  }\n66 +\n67 +  verify(token: string): JwtPayload | null {\n68 +    const parts = token.split('.');\n69 +    if (parts.length !== 3) {\n70 +      return null;\n71 +    }\n72 +\n73 +    const [headerEncoded, payloadEncoded, signature] = parts;\n74 +\n75 +    try {\n76 +      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n77 +      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n78 +\n79 +      // Verify algorithm\n80 +      if (header.alg !== 'HS256' && header.alg !== 'none') {\n81 +        return null;\n82 +      }\n83 +\n84 +      // Verify signature\n85 +      if (header.alg !== 'none') {\n86 +        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n87 +        if (signature !== expectedSignature) {\n88 +          return null;\n89 +        }\n90 +      }\n91 +\n92 +      // Check expiration\n93 +      const now = Math.floor(Date.now() / 1000);\n94 +      if (payload.exp && payload.exp < now) {\n95 +        return null;\n96 +      }\n97 +\n98 +      // Verify issuer and audience\n99 +      if (payload.iss !== this.config.issuer) {\n100 +        return null;\n101 +      }\n102 +\n103 +      if (payload.aud !== this.config.audience) {\n104 +        return null;\n105 +      }\n106 +\n107 +      return payload;\n108 +    } catch {\n109 +      return null;\n110 +    }\n111 +  }\n112 +\n113 +  private createSignature(data: string): string {\n114 +    const hmac = crypto.createHmac('sha256', this.config.secret);\n115 +    hmac.update(data);\n116 +    return base64UrlEncode(hmac.digest());\n117 +  }\n118 +\n119 +  decode(token: string): JwtPayload | null {\n120 +    const parts = token.split('.');\n121 +    if (parts.length !== 3) {\n122 +      return null;\n123 +    }\n124 +\n125 +    try {\n126 +      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n127 +    } catch {\n128 +      return null;\n129 +    }\n130 +  }\n131 +\n132 +  refresh(token: string): string | null {\n133 +    const payload = this.verify(token);\n134 +    if (!payload) {\n135 +      return null;\n136 +    }\n137 +\n138 +    const { iat, exp, ...rest } = payload;\n139 +    return this.sign(rest);\n140 +  }\n141 +\n142 +  isExpired(token: string): boolean {\n143 +    const payload = this.decode(token);\n144 +    if (!payload || !payload.exp) {\n145 +      return true;\n146 +    }\n147 +\n148 +    const now = Math.floor(Date.now() / 1000);\n149 +    return payload.exp < now;\n150 +  }\n151 +}\n152 +\n153 +export function createJwtService(config: JwtConfig): JwtService {\n154 +  return new JwtService(config);\n155 +}\n156 +\n__old hunk__\n",
            "prSummary": "",
            "referenceBugs": "[{\"relevantFile\":\"packages/auth/src/jwt/JwtService.ts\",\"relevantLinesStart\":75,\"relevantLinesEnd\":81},{\"relevantFile\":\"packages/auth/src/jwt/JwtService.ts\",\"relevantLinesStart\":83,\"relevantLinesEnd\":85}]",
            "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"// Verify algorithm\\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\\n        return null;\\n      }\\n\\n      // Verify signature\\n      if (header.alg !== 'none') {\",\n    \"improvedCode\": \"// Verify algorithm - NEVER accept 'none'\\n      if (header.alg !== 'HS256') {\\n        return null;\\n      }\\n\\n      // Verify signature\",\n    \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n    \"relevantLinesEnd\": 81,\n    \"suggestionContent\": \"The `verify` method accepts tokens with `alg: 'none'`, which means an attacker can forge tokens by setting the algorithm to 'none' and providing an empty signature. This is the classic JWT algorithm confusion attack. Never accept 'none' as a valid algorithm.\",\n    \"oneSentenceSummary\": \"JWT algorithm confusion - accepting 'none' allows forged tokens\",\n    \"relevantLinesStart\": 75\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (signature !== expectedSignature) {\\n          return null;\\n        }\",\n    \"improvedCode\": \"if (!crypto.timingSafeEqual(\\n          Buffer.from(signature),\\n          Buffer.from(expectedSignature)\\n        )) {\\n          return null;\\n        }\",\n    \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n    \"relevantLinesEnd\": 85,\n    \"suggestionContent\": \"The signature comparison `signature !== expectedSignature` uses JavaScript's standard string comparison, which is not constant-time. This allows timing attacks where an attacker can determine how many characters of the signature match by measuring response times. Use a constant-time comparison function.\",\n    \"oneSentenceSummary\": \"Timing attack vulnerability - signature comparison is not constant-time\",\n    \"relevantLinesStart\": 83\n  }\n]"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "file://parse-assertion.js"
            },
            {
              "type": "javascript",
              "value": "file://judge-assertion.js"
            },
            {
              "type": "javascript",
              "value": "file://line-accuracy-assertion.js"
            }
          ],
          "options": {},
          "metadata": {}
        },
        "testIdx": 0,
        "vars": {
          "fileContent": "import * as crypto from 'crypto';\n\nexport interface JwtPayload {\n  sub: string;\n  iat: number;\n  exp: number;\n  iss?: string;\n  aud?: string;\n  [key: string]: unknown;\n}\n\nexport interface JwtHeader {\n  alg: string;\n  typ: string;\n}\n\nexport interface JwtConfig {\n  secret: string;\n  issuer: string;\n  audience: string;\n  expiresIn: number;\n}\n\nfunction base64UrlEncode(data: string | Buffer): string {\n  const base64 = Buffer.from(data).toString('base64');\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\n\nfunction base64UrlDecode(data: string): string {\n  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n  const padding = base64.length % 4;\n  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n  return Buffer.from(padded, 'base64').toString();\n}\n\nexport class JwtService {\n  private config: JwtConfig;\n\n  constructor(config: JwtConfig) {\n    this.config = config;\n  }\n\n  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n    const now = Math.floor(Date.now() / 1000);\n\n    const header: JwtHeader = {\n      alg: 'HS256',\n      typ: 'JWT',\n    };\n\n    const fullPayload: JwtPayload = {\n      ...payload,\n      iat: now,\n      exp: now + this.config.expiresIn,\n      iss: this.config.issuer,\n      aud: this.config.audience,\n    };\n\n    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n\n    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n\n    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n  }\n\n  verify(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    const [headerEncoded, payloadEncoded, signature] = parts;\n\n    try {\n      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n\n      // Verify algorithm\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\n        return null;\n      }\n\n      // Verify signature\n      if (header.alg !== 'none') {\n        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n        if (signature !== expectedSignature) {\n          return null;\n        }\n      }\n\n      // Check expiration\n      const now = Math.floor(Date.now() / 1000);\n      if (payload.exp && payload.exp < now) {\n        return null;\n      }\n\n      // Verify issuer and audience\n      if (payload.iss !== this.config.issuer) {\n        return null;\n      }\n\n      if (payload.aud !== this.config.audience) {\n        return null;\n      }\n\n      return payload;\n    } catch {\n      return null;\n    }\n  }\n\n  private createSignature(data: string): string {\n    const hmac = crypto.createHmac('sha256', this.config.secret);\n    hmac.update(data);\n    return base64UrlEncode(hmac.digest());\n  }\n\n  decode(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  refresh(token: string): string | null {\n    const payload = this.verify(token);\n    if (!payload) {\n      return null;\n    }\n\n    const { iat, exp, ...rest } = payload;\n    return this.sign(rest);\n  }\n\n  isExpired(token: string): boolean {\n    const payload = this.decode(token);\n    if (!payload || !payload.exp) {\n      return true;\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n    return payload.exp < now;\n  }\n}\n\nexport function createJwtService(config: JwtConfig): JwtService {\n  return new JwtService(config);\n}\n",
          "patchWithLinesStr": "## file: 'packages/auth/src/jwt/JwtService.ts'\n\n@@ -0,0 +1,156 @@\n__new hunk__\n1 +import * as crypto from 'crypto';\n2 +\n3 +export interface JwtPayload {\n4 +  sub: string;\n5 +  iat: number;\n6 +  exp: number;\n7 +  iss?: string;\n8 +  aud?: string;\n9 +  [key: string]: unknown;\n10 +}\n11 +\n12 +export interface JwtHeader {\n13 +  alg: string;\n14 +  typ: string;\n15 +}\n16 +\n17 +export interface JwtConfig {\n18 +  secret: string;\n19 +  issuer: string;\n20 +  audience: string;\n21 +  expiresIn: number;\n22 +}\n23 +\n24 +function base64UrlEncode(data: string | Buffer): string {\n25 +  const base64 = Buffer.from(data).toString('base64');\n26 +  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n27 +}\n28 +\n29 +function base64UrlDecode(data: string): string {\n30 +  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n31 +  const padding = base64.length % 4;\n32 +  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n33 +  return Buffer.from(padded, 'base64').toString();\n34 +}\n35 +\n36 +export class JwtService {\n37 +  private config: JwtConfig;\n38 +\n39 +  constructor(config: JwtConfig) {\n40 +    this.config = config;\n41 +  }\n42 +\n43 +  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n44 +    const now = Math.floor(Date.now() / 1000);\n45 +\n46 +    const header: JwtHeader = {\n47 +      alg: 'HS256',\n48 +      typ: 'JWT',\n49 +    };\n50 +\n51 +    const fullPayload: JwtPayload = {\n52 +      ...payload,\n53 +      iat: now,\n54 +      exp: now + this.config.expiresIn,\n55 +      iss: this.config.issuer,\n56 +      aud: this.config.audience,\n57 +    };\n58 +\n59 +    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n60 +    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n61 +\n62 +    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n63 +\n64 +    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n65 +  }\n66 +\n67 +  verify(token: string): JwtPayload | null {\n68 +    const parts = token.split('.');\n69 +    if (parts.length !== 3) {\n70 +      return null;\n71 +    }\n72 +\n73 +    const [headerEncoded, payloadEncoded, signature] = parts;\n74 +\n75 +    try {\n76 +      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n77 +      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n78 +\n79 +      // Verify algorithm\n80 +      if (header.alg !== 'HS256' && header.alg !== 'none') {\n81 +        return null;\n82 +      }\n83 +\n84 +      // Verify signature\n85 +      if (header.alg !== 'none') {\n86 +        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n87 +        if (signature !== expectedSignature) {\n88 +          return null;\n89 +        }\n90 +      }\n91 +\n92 +      // Check expiration\n93 +      const now = Math.floor(Date.now() / 1000);\n94 +      if (payload.exp && payload.exp < now) {\n95 +        return null;\n96 +      }\n97 +\n98 +      // Verify issuer and audience\n99 +      if (payload.iss !== this.config.issuer) {\n100 +        return null;\n101 +      }\n102 +\n103 +      if (payload.aud !== this.config.audience) {\n104 +        return null;\n105 +      }\n106 +\n107 +      return payload;\n108 +    } catch {\n109 +      return null;\n110 +    }\n111 +  }\n112 +\n113 +  private createSignature(data: string): string {\n114 +    const hmac = crypto.createHmac('sha256', this.config.secret);\n115 +    hmac.update(data);\n116 +    return base64UrlEncode(hmac.digest());\n117 +  }\n118 +\n119 +  decode(token: string): JwtPayload | null {\n120 +    const parts = token.split('.');\n121 +    if (parts.length !== 3) {\n122 +      return null;\n123 +    }\n124 +\n125 +    try {\n126 +      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n127 +    } catch {\n128 +      return null;\n129 +    }\n130 +  }\n131 +\n132 +  refresh(token: string): string | null {\n133 +    const payload = this.verify(token);\n134 +    if (!payload) {\n135 +      return null;\n136 +    }\n137 +\n138 +    const { iat, exp, ...rest } = payload;\n139 +    return this.sign(rest);\n140 +  }\n141 +\n142 +  isExpired(token: string): boolean {\n143 +    const payload = this.decode(token);\n144 +    if (!payload || !payload.exp) {\n145 +      return true;\n146 +    }\n147 +\n148 +    const now = Math.floor(Date.now() / 1000);\n149 +    return payload.exp < now;\n150 +  }\n151 +}\n152 +\n153 +export function createJwtService(config: JwtConfig): JwtService {\n154 +  return new JwtService(config);\n155 +}\n156 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/auth/src/jwt/JwtService.ts\",\"relevantLinesStart\":75,\"relevantLinesEnd\":81},{\"relevantFile\":\"packages/auth/src/jwt/JwtService.ts\",\"relevantLinesStart\":83,\"relevantLinesEnd\":85}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"// Verify algorithm\\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\\n        return null;\\n      }\\n\\n      // Verify signature\\n      if (header.alg !== 'none') {\",\n    \"improvedCode\": \"// Verify algorithm - NEVER accept 'none'\\n      if (header.alg !== 'HS256') {\\n        return null;\\n      }\\n\\n      // Verify signature\",\n    \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n    \"relevantLinesEnd\": 81,\n    \"suggestionContent\": \"The `verify` method accepts tokens with `alg: 'none'`, which means an attacker can forge tokens by setting the algorithm to 'none' and providing an empty signature. This is the classic JWT algorithm confusion attack. Never accept 'none' as a valid algorithm.\",\n    \"oneSentenceSummary\": \"JWT algorithm confusion - accepting 'none' allows forged tokens\",\n    \"relevantLinesStart\": 75\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (signature !== expectedSignature) {\\n          return null;\\n        }\",\n    \"improvedCode\": \"if (!crypto.timingSafeEqual(\\n          Buffer.from(signature),\\n          Buffer.from(expectedSignature)\\n        )) {\\n          return null;\\n        }\",\n    \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n    \"relevantLinesEnd\": 85,\n    \"suggestionContent\": \"The signature comparison `signature !== expectedSignature` uses JavaScript's standard string comparison, which is not constant-time. This allows timing attacks where an attacker can determine how many characters of the signature match by measuring response times. Use a constant-time comparison function.\",\n    \"oneSentenceSummary\": \"Timing attack vulnerability - signature comparison is not constant-time\",\n    \"relevantLinesStart\": 83\n  }\n]"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      },
      {
        "cost": 0.053133,
        "error": "LINE_METRICS: line_acc=0.022 avg_iou=0.022 exact_match=0.000 within3=0.000 matched=1/1",
        "gradingResult": {
          "pass": false,
          "score": 0.6184629629657407,
          "reason": "LINE_METRICS: line_acc=0.022 avg_iou=0.022 exact_match=0.000 within3=0.000 matched=1/1",
          "namedScores": {},
          "tokensUsed": {
            "total": 0,
            "prompt": 0,
            "completion": 0,
            "cached": 0,
            "numRequests": 0
          },
          "componentResults": [
            {
              "pass": true,
              "score": 1,
              "reason": "PARSE_OK: 3 suggestions parsed and validated"
            },
            {
              "pass": true,
              "score": 0.833166666675,
              "reason": "JUDGE_METRICS sonnet_score=0.8330 gpt_score=0.8333 sonnet_coverage=1.0000 sonnet_validity=0.6670 gpt_coverage=1.0000 gpt_validity=0.6667\n\n--- SONNET JUDGE ---\nript compilation error: \"Cannot assign to 'cache' because it is a read-only property\"\n- Verdict: VALID\n- Reason: This is a clear compilation bug. The `cache` property is declared as `readonly` but the `clear()` method attempts to reassign it with `this.cache = new WeakMap()`. This will fail at compile time in TypeScript with strict checking. This is a provable bug that prevents the code from compiling.\n\n## Step 2: Coverage\n\nReference bugs:\n1. **WeakMap with string keys bug** - FOUND (by Suggestion 1)\n\nThe reference bug is about WeakMap not accepting primitive string keys and needing to use Map instead. Suggestion 1 correctly identifies this exact issue.\n\ncoverage_score = 1/1 = 1.0\n\n## Step 3: Validity\n\nValid suggestions: 2 (Suggestion 1 and Suggestion 3)\nTotal suggestions: 3\nvalidity_score = 2/3 = 0.667\n\n## Step 4: Final Score\n\nscore = (1.0 * 0.5) + (0.667 * 0.5) = 0.5 + 0.333 = 0.833\n\ncoverage_score = 1/1 = 1.0\nvalidity_score = 2/3 = 0.667\nfinal_score = 1.0 * 0.5 + 0.667 * 0.5 = 0.833\n\n--- GPT JUDGE ---\n claim, not a clear, provable bug from the provided ground truth. Without a specified contract that `maxSize` *must* be enforced, there’s no concrete expected-vs-actual failure to demonstrate.\n\n### Suggestion 3: clear() reassigns a readonly property, causing TypeScript compilation error\n- Concrete failing input:\n  ```ts\n  class C {\n    private readonly cache = new WeakMap<object, number>();\n    clear() { this.cache = new WeakMap(); }\n  }\n  ```\n- Expected output: TypeScript compilation succeeds.\n- Actual output: TypeScript compile-time error: `Cannot assign to 'cache' because it is a read-only property.`\n- Verdict: VALID\n- Reason: Reassigning a `readonly` class property is a definite TypeScript error with a concrete failing snippet.\n\n## Step 2: Coverage\n- Reference bug: “WeakMap cannot use primitive string keys - will throw TypeError at runtime” — FOUND (Suggestion 1)\n\ncoverage_score = 1/1 = 1\nvalidity_score = 2/3 = 0.6666666667\nfinal_score = 1 * 0.5 + 0.6666666667 * 0.5 = 0.83333333335"
            },
            {
              "pass": false,
              "score": 0.022222222222222223,
              "reason": "LINE_METRICS: line_acc=0.022 avg_iou=0.022 exact_match=0.000 within3=0.000 matched=1/1"
            }
          ]
        },
        "id": "727265b5-65a5-4082-9f9d-0294d15c54a3",
        "latencyMs": 38837,
        "namedScores": {},
        "prompt": {
          "raw": "[\n  {\n    \"role\": \"system\",\n    \"content\": \"You are Kody Bug-Hunter, a senior engineer specialized in identifying verifiable issues through mental code execution. Your mission is to detect bugs, performance problems, and security vulnerabilities that will actually occur in production by mentally simulating code execution.\\n\\n## Core Method: Mental Simulation\\n\\nInstead of pattern matching, you will mentally execute the code step-by-step focusing on critical points:\\n\\n- Function entry/exit points\\n- Conditional branches (if/else, switch)\\n- Loop boundaries and iterations\\n- Variable assignments and transformations\\n- Function calls and return values\\n- Resource allocation/deallocation\\n- Data structure operations\\n\\n### Multiple Execution Contexts\\n\\nSimulate the code in different execution contexts:\\n- **Repeated invocations**: What changes when the same code runs multiple times?\\n- **Parallel execution**: What happens when multiple executions overlap?\\n- **Delayed execution**: What state exists when deferred code actually runs?\\n- **State persistence**: What survives between executions and what gets reset?\\n- **Order of operations**: Verify that measurements and computations happen in the correct sequence (e.g., timers started before the operation they measure)\\n- **Cardinality analysis**: When iterating over collections, check if N operations are performed when M unique operations would suffice (where M << N)\\n\\n## Simulation Scenarios\\n\\nFor each critical code section, mentally execute with these scenarios:\\n1. **Happy path**: Expected valid inputs\\n2. **Edge cases**: Empty, null, undefined, zero values - especially verify that validation logic correctly handles falsy values (0, None, False, \\\"\\\") when checking for presence vs absence\\n3. **Boundary conditions**: Min/max values, array limits\\n4. **Error conditions**: Invalid inputs, failed operations\\n5. **Resource scenarios**: Memory limits, connection failures\\n6. **Invariant violations**: System constraints that must always hold (e.g., cache size limits, unique constraints)\\n7. **Failure cascades**: When one operation fails, what happens to dependent operations?\\n\\n## Detection Categories\\n\\n### BUG\\nA bug exists when mental simulation reveals:\\n- Execution breaks: Code throws unhandled exceptions\\n- Wrong results: Output doesn't match expected behavior\\n- Resource leaks: Unclosed files, connections, memory accumulation\\n- State corruption: Invalid object/data states\\n- Logic errors: Control flow produces incorrect outcomes\\n- Race conditions: Concurrent access causes inconsistent state or duplicates\\n- Incorrect measurements: Metrics/timings that don't reflect actual operations\\n- Invariant violations: Broken constraints (size limits, uniqueness, etc.)\\n- Async timing bugs: Variables captured incorrectly in async closures\\n- Conditional validation errors: Logic that checks for presence/absence of values using truthiness tests (e.g., `if dict.get(\\\"key\\\")`) that fail with falsy values (0, None, False, \\\"\\\"), when membership tests (e.g., `if \\\"key\\\" in dict`) should be used\\n- Dead computation: Code that computes/transforms values but never uses the result, instead using the original untransformed value - indicates copy-paste error or incomplete refactoring\\n- Unbounded growth: Collections (lists, dicts, sets) that grow indefinitely within loops without size limits, potentially causing memory exhaustion\\n- Duplicate operations: Same operation executed multiple times with identical inputs in sequence, wasting resources and potentially causing incorrect counts/metrics\\n\\n### Asynchronous Execution Analysis\\nWhen analyzing asynchronous code (setTimeout, setInterval, Promises, callbacks):\\n- **Closure State Capture**: What variable values exist when the async code ACTUALLY executes vs when it was SCHEDULED?\\n- **Loop Variable Binding**: In loops with async callbacks, verify if loop variables are captured correctly\\n- **Deferred State Access**: When callbacks execute later, is the accessed state still valid/expected?\\n- **Timing Dependencies**: What has changed between scheduling and execution?\\n- **Semantic Inconsistency**: When related operations produce data (logs, metrics, events) that should be correlatable but cannot be, due to inconsistencies in keys, names, or identifiers. E.g., one metric uses the tag {'id': x} while a related one uses {'identifier': x}, breaking aggregation and analysis capabilities.\\n- **Observability inconsistencies**: Related operations using different names for same dimensional data, breaking correlation\\n\\n### PERFORMANCE\\nA performance issue exists when mental simulation reveals:\\n- Algorithm complexity: O(n²) when O(n) is possible\\n- Redundant operations: Duplicate calculations, unnecessary loops, or early returns that force multiple operations when a single operation would suffice (e.g., fail-fast in batch processing that requires multiple requests to get complete feedback)\\n- Memory waste: Large allocations or leaks over time\\n- Blocking operations: Synchronous I/O in critical paths\\n- Database inefficiency: N+1, missing indexes, full scans\\n- Cache misses: Not leveraging available caching mechanisms\\n- Batch processing inefficiency: Validation or processing loops that return on first error instead of collecting all errors, forcing clients to make multiple requests to discover all issues\\n\\n### SECURITY\\nA security vulnerability exists when mental simulation reveals:\\n- Injection vulnerabilities: SQL/NoSQL/command/LDAP injection\\n- AuthZ/AuthN flaws: Missing checks, privilege escalation\\n- Data exposure: Sensitive data in logs, responses, or errors\\n- Crypto issues: Weak algorithms, hardcoded keys, improper validation\\n- Input validation gaps: Missing sanitization or bounds checks\\n- Session management: Predictable tokens or missing expiration\\n- Timing attacks: Direct string/value comparison of secrets, tokens, passwords, or authentication credentials that leaks information through execution time - must use constant-time comparison functions\\n- Insecure fallback values: Using empty strings, default values, or weak fallbacks for critical security parameters (encryption keys, secrets, tokens) when environment variables are missing - system should fail-fast instead\\n- Input validation bypass: User-controlled parameters (offsets, limits, indices, IDs) accepted without validation or with inadequate bounds checking, especially negative values in array slicing or pagination that could bypass access controls\\n- SSRF (Server-Side Request Forgery): Using user-controlled URLs in network operations (open, fetch, HTTP requests) without allowlist validation, enabling access to internal resources or arbitrary external sites\\n- Case-sensitivity bypass: Inconsistent normalization in comparisons of case-insensitive data (emails, usernames, domains) where one side is normalized (toLowerCase/toUpperCase) but the other isn't, allowing bypass through case variations\\n\\n## Severity Assessment\\n\\nFor each confirmed issue, evaluate severity based on impact and scope:\\n\\n**CRITICAL** - Immediate and severe impact\\nApplication crash/downtime\\nData loss/corruption\\nSecurity breach (unauthorized access/data exfiltration)\\nCritical operation failure (auth/payment/authorization)\\nDirect financial loss operations\\nMemory leaks that inevitably crash production\\n\\n**HIGH** - Significant but not immediate impact\\nImportant functionality broken\\nMemory leaks that cause eventual crash\\nPerformance degradation affecting UX under normal load\\nSecurity issues with indirect exploitation paths\\nFinancial calculation errors affecting revenue\\n\\n**MEDIUM** - Moderate impact\\nPartially broken functionality\\nPerformance issues in specific scenarios\\nSecurity weaknesses requiring specific conditions\\nIncorrect but recoverable data\\nNon-critical business logic errors with workarounds\\n\\n**LOW** - Minimal impact\\nMinor performance overhead\\nLow-risk security improvements\\nIncorrect metrics/logs\\nRarely affecting few users\\nEdge-case issues\\n\\n## Analysis Rules\\n\\n### MUST DO:\\n1. **Focus ONLY on verifiable issues** - Must be able to confirm with available context\\n2. **Analyze ONLY added lines** - Lines prefixed with '+' in the diff\\n3. **Consider ONLY bugs, performance, and security** - NO style, formatting, or preferences\\n4. **Simulate actual execution** - Trace through code paths mentally\\n5. **Verify with concrete scenarios** - Use realistic inputs and conditions\\n6. **Trace resource lifecycle** - For any stateful resource (caches, maps, collections), verify both creation AND cleanup\\n7. **Validate deduplication opportunities** - When performing operations in loops, check if duplicate work can be eliminated\\n8. **Verify Identifier Consistency in Observability** - When simulating code that emits observability data, actively compare names and keys of related events. Verify identifiers for same logical entity are named identically (e.g., 'card' not 'cards'). Also detect duplicate emissions of same metric/log with identical values in sequential execution.\\n9. **Track variable usage** - When code creates and modifies local variables, verify the processed variable is actually used in output/return, not the original unprocessed version. When analyzing validation or conditional logic, simulate with falsy values (0, None, False, \\\"\\\") to verify the logic checks what it intends to check (presence vs truthiness)\\n10. **Check for unbounded collection growth** - When collections are modified inside loops, verify there are size limits to prevent memory exhaustion, especially with pagination or external data\\n11. **Verify consistent normalization** - When code normalizes case-insensitive data (emails, usernames) on one side of a comparison, verify BOTH sides are normalized to prevent bypass through case variations\\n12. **Use constant-time comparison for secrets** - When comparing authentication secrets, tokens, or credentials, verify code uses constant-time comparison functions not direct comparison operators or standard equality methods\\n13. **Reject insecure fallbacks for secrets** - When code uses `|| 'fallback'` with environment variables for encryption keys, secrets, or credentials, verify it fails-fast instead of using empty/default values\\n14. **Validate user-controlled indices** - When user input (cursor offset, page number, array index) is used in slicing/indexing, verify bounds validation prevents negative values or out-of-range access\\n15. **Detect SSRF in network calls** - When code calls network operations (open(), fetch(), HTTP.get(), requests.get()) with variables as URLs (not hardcoded strings), flag as SSRF vulnerability unless allowlist validation is present in same function\\n\\n### MUST NOT DO:\\n- **NO speculation whatsoever** - If you cannot trace the exact execution path that causes the issue, DO NOT report it\\n- **NO \\\"could\\\", \\\"might\\\", \\\"possibly\\\"** - Only report what WILL definitely happen\\n- **NO assumptions about external behavior** - Don't assume how external APIs, callbacks, user code, or imported functions/constants/utilities behave. If you cannot see the implementation in the provided code, do not make assumptions about it.\\n- **NO assumptions about imported code structure** - If code imports from another file, don't assume whether it's a function, constant, class, or what parameters it accepts. Only analyze what you can see being used in the visible code.\\n- **NO defensive programming as bugs** - Missing try-catch, validation, or error handling is NOT a bug unless you can prove it causes actual failure\\n- **NO theoretical edge cases** - Must be able to demonstrate with concrete, realistic values\\n- **NO \\\"if the user does X\\\"** - Unless you can prove X is a normal, expected usage\\n- **NO style or best practices** - Zero suggestions about code organization, naming, or preferences\\n- **NO potential issues** - Only report issues you can reproduce mentally with specific inputs\\n- **NO \\\"in production this could...\\\"** - Must be able to prove it WILL happen, not that it COULD happen\\n- **NO assuming missing code is wrong** - If code isn't shown, don't assume it exists or how it works\\n- **NO indentation-related issues** - Never report issues where the root cause is indentation, spacing, or whitespace - even if you believe it causes syntax errors, parsing failures, or runtime crashes. Indentation problems are NOT bugs.\\n- **ONLY report if you can provide**:\\n  1. Exact input values that trigger the issue\\n  2. Step-by-step execution trace showing the failure\\n  3. The specific line where the failure occurs\\n  4. The exact incorrect behavior that results\\n  5. **Proof that the issue exists in VISIBLE code only** - if the bug depends on behavior of imported code you cannot see, you CANNOT report it\\n\\n## Analysis Process\\n\\n1. **Understand PR intent** from summary as context for expected behavior\\n2. **Identify critical points** in the changed code (+lines only)\\n3. **Simulate execution** through each critical path considering:\\n   - Variable initialization order vs usage order\\n   - Number of unique operations vs total iterations\\n   - Resource accumulation without corresponding cleanup\\n3.5. **For async code**: Track variable values at SCHEDULING time vs EXECUTION time\\n3.6. **For operations that can fail**: Verify ALL failure paths are handled and system invariants maintained\\n3.7. **For network operations**: When you see open(), fetch(), HTTP requests with variable URLs, immediately flag as SSRF unless you see URL validation (allowlist, domain check, URI parse with host verification) in the same code block\\n4. **Test concrete scenarios** on each path with realistic inputs\\n5. **Detect verifiable issues** where behavior is definitively problematic\\n6. **Confirm with available context** - must be provable with given information\\n   - Can you see ALL the code involved in the bug? If NO → DO NOT REPORT\\n   - Does the bug depend on imported function behavior? If YES and you can't see the import → DO NOT REPORT\\n   - Are you assuming what an imported function/constant contains? If YES → DO NOT REPORT\\n6.1. **Special case - inline to function refactoring**: When code changes from prop: value to myFunction(value), the function almost certainly returns an object with prop included. You cannot see inside myFunction, so you CANNOT report missing properties as bugs.\\n6.2. **Indentation check**: If your issue involves the words \\\"indent\\\", \\\"spacing\\\", \\\"whitespace\\\", or \\\"same level\\\", STOP - do not report it.\\n7. **Assess severity** of confirmed issues based on impact and scope\\n\\n\\n## Output Requirements\\n\\n- Report ONLY issues you can definitively prove will occur\\n- Focus ONLY on bugs, performance, and security categories\\n- Use PR summary as auxiliary context, not absolute truth\\n- Be precise and concise in descriptions\\n- Always respond in en-US language\\n- Return ONLY the JSON object, no additional text\\n\\n### Issue description\\n\\nCustom instructions for 'suggestionContent'\\nIMPORTANT none of these instructions should be taken into consideration for any other fields such as 'improvedCode'\\n\\nDetailed and verifiable issue description\\n\\n### LLM Prompt\\n\\nCreate a field called 'llmPrompt', this field must contain an accurate description of the issue as well as relevant context which lead to finding that issue.\\nThis is a prompt for another LLM, the user must be able to simply copy this text and paste it into another LLM and have it produce useful results.\\nThis must be a prompt from the perspective of the user, it will communicate directly with the LLM as though it were sent as a chat message from the user, it should be a prompt a user could input into an LLM.\\n\\nIMPORTANT, on this field you must only focus on describing the issue and providing context in a manner that an LLM will understand as a prompt.\\nThe existing code, improved code, relevant line start and end, file path, etc. will all be provided elsewhere.\\nDO NOT under any circumstances provide any sort of code block in this field, like for example: ```python def foo(): .... ```\\n\\n### Response format\\n\\nReturn only valid JSON, nothing more. Under no circumstances should there be any text of any kind before the ```json or after the final ```, use the following JSON format:\\n\\n```json\\n{\\n    \\\"codeSuggestions\\\": [\\n        {\\n            \\\"relevantFile\\\": \\\"path/to/file\\\",\\n            \\\"language\\\": \\\"programming_language\\\",\\n            \\\"suggestionContent\\\": \\\"The full issue description\\\",\\n            \\\"existingCode\\\": \\\"Problematic code from PR\\\",\\n            \\\"improvedCode\\\": \\\"Fixed code proposal\\\",\\n            \\\"oneSentenceSummary\\\": \\\"Concise issue description\\\",\\n            \\\"relevantLinesStart\\\": \\\"starting_line\\\",\\n            \\\"relevantLinesEnd\\\": \\\"ending_line\\\",\\n            \\\"label\\\": \\\"bug|performance|security\\\",\\n            \\\"severity\\\": \\\"low|medium|high|critical\\\",\\n            \\\"llmPrompt\\\": \\\"Prompt for LLMs\\\"\\n        }\\n    ]\\n}\\n```\\n\"\n  },\n  {\n    \"role\": \"user\",\n    \"content\": \"## Code Under Review\\nMentally execute the changed code through multiple scenarios and identify real bugs that will break in production.\\n\\nPR Summary:\\n```\\n\\n```\\n\\nComplete File Content:\\n```\\nimport { Logger } from '../utils/logger';\\n\\ninterface CacheEntry<T> {\\n  value: T;\\n  timestamp: number;\\n  ttl: number;\\n}\\n\\ninterface CacheOptions {\\n  defaultTtl: number;\\n  maxSize: number;\\n  onEvict?: (key: string, value: unknown) => void;\\n}\\n\\nexport class RequestCache<T = unknown> {\\n  private readonly cache: WeakMap<object, CacheEntry<T>>;\\n  private readonly logger: Logger;\\n  private readonly options: CacheOptions;\\n  private hits = 0;\\n  private misses = 0;\\n\\n  constructor(options: Partial<CacheOptions> = {}) {\\n    this.cache = new WeakMap();\\n    this.logger = new Logger('RequestCache');\\n    this.options = {\\n      defaultTtl: 60000,\\n      maxSize: 1000,\\n      ...options,\\n    };\\n  }\\n\\n  get(key: string): T | undefined {\\n    const entry = this.cache.get(key as unknown as object);\\n    if (!entry) {\\n      this.misses++;\\n      return undefined;\\n    }\\n\\n    if (Date.now() - entry.timestamp > entry.ttl) {\\n      this.cache.delete(key as unknown as object);\\n      this.misses++;\\n      return undefined;\\n    }\\n\\n    this.hits++;\\n    return entry.value;\\n  }\\n\\n  set(key: string, value: T, ttl?: number): void {\\n    const entry: CacheEntry<T> = {\\n      value,\\n      timestamp: Date.now(),\\n      ttl: ttl ?? this.options.defaultTtl,\\n    };\\n    this.cache.set(key as unknown as object, entry);\\n    this.logger.debug(`Cached key: ${key}`);\\n  }\\n\\n  delete(key: string): boolean {\\n    return this.cache.delete(key as unknown as object);\\n  }\\n\\n  getStats() {\\n    const total = this.hits + this.misses;\\n    return {\\n      hits: this.hits,\\n      misses: this.misses,\\n      hitRate: total > 0 ? this.hits / total : 0,\\n    };\\n  }\\n\\n  clear(): void {\\n    this.cache = new WeakMap();\\n    this.hits = 0;\\n    this.misses = 0;\\n  }\\n}\\n\\nexport function createRequestCache<T>(options?: Partial<CacheOptions>) {\\n  return new RequestCache<T>(options);\\n}\\n```\\n\\nCode Diff (PR Changes):\\n```\\n## file: 'packages/core/src/cache/RequestCache.ts'\\n\\n@@ -0,0 +1,82 @@\\n__new hunk__\\n1 +import { Logger } from '../utils/logger';\\n2 +\\n3 +interface CacheEntry<T> {\\n4 +  value: T;\\n5 +  timestamp: number;\\n6 +  ttl: number;\\n7 +}\\n8 +\\n9 +interface CacheOptions {\\n10 +  defaultTtl: number;\\n11 +  maxSize: number;\\n12 +  onEvict?: (key: string, value: unknown) => void;\\n13 +}\\n14 +\\n15 +export class RequestCache<T = unknown> {\\n16 +  private readonly cache: WeakMap<object, CacheEntry<T>>;\\n17 +  private readonly logger: Logger;\\n18 +  private readonly options: CacheOptions;\\n19 +  private hits = 0;\\n20 +  private misses = 0;\\n21 +\\n22 +  constructor(options: Partial<CacheOptions> = {}) {\\n23 +    this.cache = new WeakMap();\\n24 +    this.logger = new Logger('RequestCache');\\n25 +    this.options = {\\n26 +      defaultTtl: 60000,\\n27 +      maxSize: 1000,\\n28 +      ...options,\\n29 +    };\\n30 +  }\\n31 +\\n32 +  get(key: string): T | undefined {\\n33 +    const entry = this.cache.get(key as unknown as object);\\n34 +    if (!entry) {\\n35 +      this.misses++;\\n36 +      return undefined;\\n37 +    }\\n38 +\\n39 +    if (Date.now() - entry.timestamp > entry.ttl) {\\n40 +      this.cache.delete(key as unknown as object);\\n41 +      this.misses++;\\n42 +      return undefined;\\n43 +    }\\n44 +\\n45 +    this.hits++;\\n46 +    return entry.value;\\n47 +  }\\n48 +\\n49 +  set(key: string, value: T, ttl?: number): void {\\n50 +    const entry: CacheEntry<T> = {\\n51 +      value,\\n52 +      timestamp: Date.now(),\\n53 +      ttl: ttl ?? this.options.defaultTtl,\\n54 +    };\\n55 +    this.cache.set(key as unknown as object, entry);\\n56 +    this.logger.debug(`Cached key: ${key}`);\\n57 +  }\\n58 +\\n59 +  delete(key: string): boolean {\\n60 +    return this.cache.delete(key as unknown as object);\\n61 +  }\\n62 +\\n63 +  getStats() {\\n64 +    const total = this.hits + this.misses;\\n65 +    return {\\n66 +      hits: this.hits,\\n67 +      misses: this.misses,\\n68 +      hitRate: total > 0 ? this.hits / total : 0,\\n69 +    };\\n70 +  }\\n71 +\\n72 +  clear(): void {\\n73 +    this.cache = new WeakMap();\\n74 +    this.hits = 0;\\n75 +    this.misses = 0;\\n76 +  }\\n77 +}\\n78 +\\n79 +export function createRequestCache<T>(options?: Partial<CacheOptions>) {\\n80 +  return new RequestCache<T>(options);\\n81 +}\\n82 +\\n__old hunk__\\n```\\n\\nUse the PR summary to understand the intended changes, then simulate execution of the modified code (+lines) to detect bugs that will actually occur in production.\"\n  }\n]",
          "label": "prompt-loader.js",
          "config": {}
        },
        "promptId": "020b8dca03ee47e41d61a162d7650d02bc5409a9fa62b75bda18a2e446a2739d",
        "promptIdx": 0,
        "provider": {
          "id": "anthropic:messages:claude-sonnet-4-5-20250929",
          "label": ""
        },
        "response": {
          "output": "```json\n{\n  \"codeSuggestions\": [\n    {\n      \"relevantFile\": \"packages/core/src/cache/RequestCache.ts\",\n      \"language\": \"typescript\",\n      \"suggestionContent\": \"CRITICAL BUG: WeakMap cannot use strings as keys. The code attempts to use string keys by casting them to objects (`key as unknown as object`), but this fundamentally breaks the cache functionality. \\n\\nMental execution trace:\\n1. User calls `cache.set('myKey', value)`\\n2. Line 55 executes: `this.cache.set('myKey' as unknown as object, entry)`\\n3. WeakMap internally requires actual object references, not primitives\\n4. The string 'myKey' is a primitive, not an object reference\\n5. TypeScript cast doesn't change runtime behavior - it's still a string\\n6. WeakMap will either throw an error or silently fail to store the entry\\n7. Subsequent `get('myKey')` calls will always return undefined\\n8. Cache is completely non-functional\\n\\nConcrete scenario:\\n```\\nconst cache = new RequestCache();\\ncache.set('user:123', { name: 'John' });\\nconst result = cache.get('user:123'); // Always returns undefined\\n```\\n\\nThe WeakMap API specifically requires object keys because it uses weak references to allow garbage collection. Strings are interned primitives and cannot be used as WeakMap keys. This will cause the entire cache to fail silently - all set operations will fail, all get operations will return undefined, making the cache completely useless in production.\",\n      \"existingCode\": \"export class RequestCache<T = unknown> {\\n  private readonly cache: WeakMap<object, CacheEntry<T>>;\\n  // ...\\n  get(key: string): T | undefined {\\n    const entry = this.cache.get(key as unknown as object);\\n    // ...\\n  }\\n  set(key: string, value: T, ttl?: number): void {\\n    // ...\\n    this.cache.set(key as unknown as object, entry);\\n  }\\n  delete(key: string): boolean {\\n    return this.cache.delete(key as unknown as object);\\n  }\",\n      \"improvedCode\": \"export class RequestCache<T = unknown> {\\n  private readonly cache: Map<string, CacheEntry<T>>;\\n  // ...\\n  get(key: string): T | undefined {\\n    const entry = this.cache.get(key);\\n    // ...\\n  }\\n  set(key: string, value: T, ttl?: number): void {\\n    // ...\\n    this.cache.set(key, entry);\\n  }\\n  delete(key: string): boolean {\\n    return this.cache.delete(key);\\n  }\",\n      \"oneSentenceSummary\": \"WeakMap cannot accept string keys, causing complete cache failure as all operations will fail silently\",\n      \"relevantLinesStart\": \"16\",\n      \"relevantLinesEnd\": \"60\",\n      \"label\": \"bug\",\n      \"severity\": \"critical\",\n      \"llmPrompt\": \"I have a TypeScript cache implementation that uses WeakMap with string keys. The code casts strings to objects like this: `this.cache.set(key as unknown as object, entry)` where key is a string. The WeakMap is declared as `private readonly cache: WeakMap<object, CacheEntry<T>>`. Will this work correctly at runtime? What happens when you try to use a string as a WeakMap key in JavaScript, even with TypeScript type casting? Explain why this is or isn't a problem and what the actual runtime behavior will be.\"\n    },\n    {\n      \"relevantFile\": \"packages/core/src/cache/RequestCache.ts\",\n      \"language\": \"typescript\",\n      \"suggestionContent\": \"BUG: The maxSize option is defined and accepted in CacheOptions but never enforced. The cache will grow unbounded, eventually causing memory exhaustion.\\n\\nMental execution trace:\\n1. Constructor accepts `maxSize: 1000` in options (line 27)\\n2. User repeatedly calls `set()` with different keys\\n3. Each call adds entry to cache (line 55)\\n4. No code checks current cache size against maxSize\\n5. No eviction logic exists anywhere in the class\\n6. Cache grows indefinitely with each unique key\\n7. In production with continuous requests, memory usage grows without bound\\n8. Eventually causes out-of-memory errors\\n\\nConcrete scenario:\\n```\\nconst cache = new RequestCache({ maxSize: 100 });\\nfor (let i = 0; i < 10000; i++) {\\n  cache.set(`key${i}`, { data: 'value' });\\n}\\n// Cache now has 10,000 entries despite maxSize: 100\\n// Memory continues growing with each new key\\n```\\n\\nThe maxSize option creates a false expectation that the cache is bounded. Users will configure it thinking they're protecting against memory issues, but the cache will ignore this setting and grow without limit. The onEvict callback is also defined but never called since no eviction occurs.\",\n      \"existingCode\": \"interface CacheOptions {\\n  defaultTtl: number;\\n  maxSize: number;\\n  onEvict?: (key: string, value: unknown) => void;\\n}\\n\\nset(key: string, value: T, ttl?: number): void {\\n  const entry: CacheEntry<T> = {\\n    value,\\n    timestamp: Date.now(),\\n    ttl: ttl ?? this.options.defaultTtl,\\n  };\\n  this.cache.set(key as unknown as object, entry);\\n  this.logger.debug(`Cached key: ${key}`);\\n}\",\n      \"improvedCode\": \"set(key: string, value: T, ttl?: number): void {\\n  // Check size and evict if needed\\n  if (this.cache.size >= this.options.maxSize) {\\n    // Evict oldest entry (LRU) or implement other eviction strategy\\n    const oldestKey = this.findOldestKey();\\n    const oldEntry = this.cache.get(oldestKey);\\n    if (oldEntry && this.options.onEvict) {\\n      this.options.onEvict(oldestKey, oldEntry.value);\\n    }\\n    this.cache.delete(oldestKey);\\n  }\\n  \\n  const entry: CacheEntry<T> = {\\n    value,\\n    timestamp: Date.now(),\\n    ttl: ttl ?? this.options.defaultTtl,\\n  };\\n  this.cache.set(key, entry);\\n  this.logger.debug(`Cached key: ${key}`);\\n}\",\n      \"oneSentenceSummary\": \"Cache accepts maxSize configuration but never enforces it, allowing unbounded memory growth\",\n      \"relevantLinesStart\": \"9\",\n      \"relevantLinesEnd\": \"57\",\n      \"label\": \"bug\",\n      \"severity\": \"high\",\n      \"llmPrompt\": \"I have a cache implementation that accepts a maxSize option in its configuration (set to 1000 by default). The cache has a set() method that adds entries but contains no logic to check the current size or evict entries when the limit is reached. There's also an onEvict callback option that's never called. If this cache runs in a production service that continuously receives requests with different cache keys, what will happen to memory usage over time? Is this a bug or expected behavior?\"\n    },\n    {\n      \"relevantFile\": \"packages/core/src/cache/RequestCache.ts\",\n      \"language\": \"typescript\",\n      \"suggestionContent\": \"BUG: The clear() method reassigns the cache property, which is declared as readonly, causing a TypeScript compilation error.\\n\\nMental execution trace:\\n1. User calls `cache.clear()`\\n2. Line 73 attempts: `this.cache = new WeakMap()`\\n3. Property `cache` is declared as `private readonly cache` (line 16)\\n4. TypeScript readonly modifier prevents reassignment after initialization\\n5. Compilation fails with error: \\\"Cannot assign to 'cache' because it is a read-only property\\\"\\n6. Code will not compile and cannot be deployed\\n\\nConcrete scenario:\\n```\\nconst cache = new RequestCache();\\ncache.set('key1', 'value1');\\ncache.clear(); // TypeScript compilation error\\n```\\n\\nThe readonly modifier on line 16 makes the cache property immutable after constructor initialization. The clear() method on line 73 attempts to reassign this property, which violates the readonly constraint. This is a compilation error that will prevent the code from building.\",\n      \"existingCode\": \"export class RequestCache<T = unknown> {\\n  private readonly cache: WeakMap<object, CacheEntry<T>>;\\n  // ...\\n  clear(): void {\\n    this.cache = new WeakMap();\\n    this.hits = 0;\\n    this.misses = 0;\\n  }\\n}\",\n      \"improvedCode\": \"export class RequestCache<T = unknown> {\\n  private cache: Map<string, CacheEntry<T>>; // Remove readonly\\n  // ...\\n  clear(): void {\\n    this.cache.clear(); // Use Map's clear method instead of reassignment\\n    this.hits = 0;\\n    this.misses = 0;\\n  }\\n}\",\n      \"oneSentenceSummary\": \"clear() method attempts to reassign readonly cache property, causing TypeScript compilation error\",\n      \"relevantLinesStart\": \"72\",\n      \"relevantLinesEnd\": \"76\",\n      \"label\": \"bug\",\n      \"severity\": \"critical\",\n      \"llmPrompt\": \"I have a TypeScript class with a property declared as `private readonly cache: WeakMap<object, CacheEntry<T>>` in the class definition. Later, there's a clear() method that contains the line `this.cache = new WeakMap()`. Will this code compile in TypeScript? What does the readonly modifier mean for property reassignment after initialization?\"\n    }\n  ]\n}\n```",
          "tokenUsage": {
            "total": 7775,
            "prompt": 5291,
            "completion": 2484
          },
          "finishReason": "stop",
          "cost": 0.053133
        },
        "score": 0.6184629629657407,
        "success": false,
        "testCase": {
          "description": "Example 2: packages/core/src/cache/RequestCache.ts",
          "vars": {
            "fileContent": "import { Logger } from '../utils/logger';\n\ninterface CacheEntry<T> {\n  value: T;\n  timestamp: number;\n  ttl: number;\n}\n\ninterface CacheOptions {\n  defaultTtl: number;\n  maxSize: number;\n  onEvict?: (key: string, value: unknown) => void;\n}\n\nexport class RequestCache<T = unknown> {\n  private readonly cache: WeakMap<object, CacheEntry<T>>;\n  private readonly logger: Logger;\n  private readonly options: CacheOptions;\n  private hits = 0;\n  private misses = 0;\n\n  constructor(options: Partial<CacheOptions> = {}) {\n    this.cache = new WeakMap();\n    this.logger = new Logger('RequestCache');\n    this.options = {\n      defaultTtl: 60000,\n      maxSize: 1000,\n      ...options,\n    };\n  }\n\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key as unknown as object);\n    if (!entry) {\n      this.misses++;\n      return undefined;\n    }\n\n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.cache.delete(key as unknown as object);\n      this.misses++;\n      return undefined;\n    }\n\n    this.hits++;\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      ttl: ttl ?? this.options.defaultTtl,\n    };\n    this.cache.set(key as unknown as object, entry);\n    this.logger.debug(`Cached key: ${key}`);\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key as unknown as object);\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      hitRate: total > 0 ? this.hits / total : 0,\n    };\n  }\n\n  clear(): void {\n    this.cache = new WeakMap();\n    this.hits = 0;\n    this.misses = 0;\n  }\n}\n\nexport function createRequestCache<T>(options?: Partial<CacheOptions>) {\n  return new RequestCache<T>(options);\n}\n",
            "patchWithLinesStr": "## file: 'packages/core/src/cache/RequestCache.ts'\n\n@@ -0,0 +1,82 @@\n__new hunk__\n1 +import { Logger } from '../utils/logger';\n2 +\n3 +interface CacheEntry<T> {\n4 +  value: T;\n5 +  timestamp: number;\n6 +  ttl: number;\n7 +}\n8 +\n9 +interface CacheOptions {\n10 +  defaultTtl: number;\n11 +  maxSize: number;\n12 +  onEvict?: (key: string, value: unknown) => void;\n13 +}\n14 +\n15 +export class RequestCache<T = unknown> {\n16 +  private readonly cache: WeakMap<object, CacheEntry<T>>;\n17 +  private readonly logger: Logger;\n18 +  private readonly options: CacheOptions;\n19 +  private hits = 0;\n20 +  private misses = 0;\n21 +\n22 +  constructor(options: Partial<CacheOptions> = {}) {\n23 +    this.cache = new WeakMap();\n24 +    this.logger = new Logger('RequestCache');\n25 +    this.options = {\n26 +      defaultTtl: 60000,\n27 +      maxSize: 1000,\n28 +      ...options,\n29 +    };\n30 +  }\n31 +\n32 +  get(key: string): T | undefined {\n33 +    const entry = this.cache.get(key as unknown as object);\n34 +    if (!entry) {\n35 +      this.misses++;\n36 +      return undefined;\n37 +    }\n38 +\n39 +    if (Date.now() - entry.timestamp > entry.ttl) {\n40 +      this.cache.delete(key as unknown as object);\n41 +      this.misses++;\n42 +      return undefined;\n43 +    }\n44 +\n45 +    this.hits++;\n46 +    return entry.value;\n47 +  }\n48 +\n49 +  set(key: string, value: T, ttl?: number): void {\n50 +    const entry: CacheEntry<T> = {\n51 +      value,\n52 +      timestamp: Date.now(),\n53 +      ttl: ttl ?? this.options.defaultTtl,\n54 +    };\n55 +    this.cache.set(key as unknown as object, entry);\n56 +    this.logger.debug(`Cached key: ${key}`);\n57 +  }\n58 +\n59 +  delete(key: string): boolean {\n60 +    return this.cache.delete(key as unknown as object);\n61 +  }\n62 +\n63 +  getStats() {\n64 +    const total = this.hits + this.misses;\n65 +    return {\n66 +      hits: this.hits,\n67 +      misses: this.misses,\n68 +      hitRate: total > 0 ? this.hits / total : 0,\n69 +    };\n70 +  }\n71 +\n72 +  clear(): void {\n73 +    this.cache = new WeakMap();\n74 +    this.hits = 0;\n75 +    this.misses = 0;\n76 +  }\n77 +}\n78 +\n79 +export function createRequestCache<T>(options?: Partial<CacheOptions>) {\n80 +  return new RequestCache<T>(options);\n81 +}\n82 +\n__old hunk__\n",
            "prSummary": "",
            "referenceBugs": "[{\"relevantFile\":\"packages/core/src/cache/RequestCache.ts\",\"relevantLinesStart\":17,\"relevantLinesEnd\":17}]",
            "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"private readonly cache: WeakMap<object, CacheEntry<T>>;\",\n    \"improvedCode\": \"private readonly cache: Map<string, CacheEntry<T>>;\",\n    \"relevantFile\": \"packages/core/src/cache/RequestCache.ts\",\n    \"relevantLinesEnd\": 17,\n    \"suggestionContent\": \"WeakMap only accepts objects as keys, not primitive values like strings. The code casts strings to objects with `as unknown as object`, but this doesn't actually convert the string to an object - it just bypasses TypeScript's type checking. At runtime, WeakMap.set() will throw a TypeError when called with a string key. Use a regular Map instead of WeakMap for string keys, or if you need weak references, use the string as a property of a wrapper object.\",\n    \"oneSentenceSummary\": \"WeakMap cannot use primitive string keys - will throw TypeError at runtime\",\n    \"relevantLinesStart\": 17\n  }\n]"
          },
          "assert": [
            {
              "type": "javascript",
              "value": "file://parse-assertion.js"
            },
            {
              "type": "javascript",
              "value": "file://judge-assertion.js"
            },
            {
              "type": "javascript",
              "value": "file://line-accuracy-assertion.js"
            }
          ],
          "options": {},
          "metadata": {}
        },
        "testIdx": 1,
        "vars": {
          "fileContent": "import { Logger } from '../utils/logger';\n\ninterface CacheEntry<T> {\n  value: T;\n  timestamp: number;\n  ttl: number;\n}\n\ninterface CacheOptions {\n  defaultTtl: number;\n  maxSize: number;\n  onEvict?: (key: string, value: unknown) => void;\n}\n\nexport class RequestCache<T = unknown> {\n  private readonly cache: WeakMap<object, CacheEntry<T>>;\n  private readonly logger: Logger;\n  private readonly options: CacheOptions;\n  private hits = 0;\n  private misses = 0;\n\n  constructor(options: Partial<CacheOptions> = {}) {\n    this.cache = new WeakMap();\n    this.logger = new Logger('RequestCache');\n    this.options = {\n      defaultTtl: 60000,\n      maxSize: 1000,\n      ...options,\n    };\n  }\n\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key as unknown as object);\n    if (!entry) {\n      this.misses++;\n      return undefined;\n    }\n\n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.cache.delete(key as unknown as object);\n      this.misses++;\n      return undefined;\n    }\n\n    this.hits++;\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      ttl: ttl ?? this.options.defaultTtl,\n    };\n    this.cache.set(key as unknown as object, entry);\n    this.logger.debug(`Cached key: ${key}`);\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key as unknown as object);\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      hitRate: total > 0 ? this.hits / total : 0,\n    };\n  }\n\n  clear(): void {\n    this.cache = new WeakMap();\n    this.hits = 0;\n    this.misses = 0;\n  }\n}\n\nexport function createRequestCache<T>(options?: Partial<CacheOptions>) {\n  return new RequestCache<T>(options);\n}\n",
          "patchWithLinesStr": "## file: 'packages/core/src/cache/RequestCache.ts'\n\n@@ -0,0 +1,82 @@\n__new hunk__\n1 +import { Logger } from '../utils/logger';\n2 +\n3 +interface CacheEntry<T> {\n4 +  value: T;\n5 +  timestamp: number;\n6 +  ttl: number;\n7 +}\n8 +\n9 +interface CacheOptions {\n10 +  defaultTtl: number;\n11 +  maxSize: number;\n12 +  onEvict?: (key: string, value: unknown) => void;\n13 +}\n14 +\n15 +export class RequestCache<T = unknown> {\n16 +  private readonly cache: WeakMap<object, CacheEntry<T>>;\n17 +  private readonly logger: Logger;\n18 +  private readonly options: CacheOptions;\n19 +  private hits = 0;\n20 +  private misses = 0;\n21 +\n22 +  constructor(options: Partial<CacheOptions> = {}) {\n23 +    this.cache = new WeakMap();\n24 +    this.logger = new Logger('RequestCache');\n25 +    this.options = {\n26 +      defaultTtl: 60000,\n27 +      maxSize: 1000,\n28 +      ...options,\n29 +    };\n30 +  }\n31 +\n32 +  get(key: string): T | undefined {\n33 +    const entry = this.cache.get(key as unknown as object);\n34 +    if (!entry) {\n35 +      this.misses++;\n36 +      return undefined;\n37 +    }\n38 +\n39 +    if (Date.now() - entry.timestamp > entry.ttl) {\n40 +      this.cache.delete(key as unknown as object);\n41 +      this.misses++;\n42 +      return undefined;\n43 +    }\n44 +\n45 +    this.hits++;\n46 +    return entry.value;\n47 +  }\n48 +\n49 +  set(key: string, value: T, ttl?: number): void {\n50 +    const entry: CacheEntry<T> = {\n51 +      value,\n52 +      timestamp: Date.now(),\n53 +      ttl: ttl ?? this.options.defaultTtl,\n54 +    };\n55 +    this.cache.set(key as unknown as object, entry);\n56 +    this.logger.debug(`Cached key: ${key}`);\n57 +  }\n58 +\n59 +  delete(key: string): boolean {\n60 +    return this.cache.delete(key as unknown as object);\n61 +  }\n62 +\n63 +  getStats() {\n64 +    const total = this.hits + this.misses;\n65 +    return {\n66 +      hits: this.hits,\n67 +      misses: this.misses,\n68 +      hitRate: total > 0 ? this.hits / total : 0,\n69 +    };\n70 +  }\n71 +\n72 +  clear(): void {\n73 +    this.cache = new WeakMap();\n74 +    this.hits = 0;\n75 +    this.misses = 0;\n76 +  }\n77 +}\n78 +\n79 +export function createRequestCache<T>(options?: Partial<CacheOptions>) {\n80 +  return new RequestCache<T>(options);\n81 +}\n82 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/core/src/cache/RequestCache.ts\",\"relevantLinesStart\":17,\"relevantLinesEnd\":17}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"private readonly cache: WeakMap<object, CacheEntry<T>>;\",\n    \"improvedCode\": \"private readonly cache: Map<string, CacheEntry<T>>;\",\n    \"relevantFile\": \"packages/core/src/cache/RequestCache.ts\",\n    \"relevantLinesEnd\": 17,\n    \"suggestionContent\": \"WeakMap only accepts objects as keys, not primitive values like strings. The code casts strings to objects with `as unknown as object`, but this doesn't actually convert the string to an object - it just bypasses TypeScript's type checking. At runtime, WeakMap.set() will throw a TypeError when called with a string key. Use a regular Map instead of WeakMap for string keys, or if you need weak references, use the string as a property of a wrapper object.\",\n    \"oneSentenceSummary\": \"WeakMap cannot use primitive string keys - will throw TypeError at runtime\",\n    \"relevantLinesStart\": 17\n  }\n]"
        },
        "metadata": {
          "_promptfooFileMetadata": {}
        },
        "failureReason": 1
      }
    ],
    "stats": {
      "successes": 0,
      "failures": 2,
      "errors": 0,
      "tokenUsage": {
        "prompt": 12067,
        "completion": 4272,
        "cached": 0,
        "total": 16339,
        "numRequests": 2,
        "completionDetails": {
          "reasoning": 0,
          "acceptedPrediction": 0,
          "rejectedPrediction": 0
        },
        "assertions": {
          "total": 0,
          "prompt": 0,
          "completion": 0,
          "cached": 0,
          "numRequests": 0,
          "completionDetails": {
            "reasoning": 0,
            "acceptedPrediction": 0,
            "rejectedPrediction": 0
          }
        }
      },
      "durationMs": 54728
    }
  },
  "config": {
    "tags": {},
    "description": "Code Review Evaluation - Exact Kodus Prompt",
    "prompts": [
      "file:///Users/gabrielmalinosqui/dev/kodus/kodus-ai/evals/promptfoo/prompt-loader.js"
    ],
    "providers": [
      {
        "id": "google:gemini-2.5-pro",
        "config": {
          "temperature": 0,
          "maxOutputTokens": 32768
        }
      },
      {
        "id": "anthropic:messages:claude-sonnet-4-5-20250929",
        "config": {
          "temperature": 0,
          "max_tokens": 16384
        }
      },
      {
        "id": "openai:gpt-5.2",
        "config": {
          "temperature": 0,
          "max_tokens": 16384
        }
      },
      {
        "id": "openai:gpt-5-mini",
        "config": {
          "temperature": 0,
          "max_tokens": 16384
        }
      },
      {
        "id": "google:gemini-3-pro-preview",
        "config": {
          "temperature": 0,
          "maxOutputTokens": 60000
        }
      },
      {
        "id": "google:gemini-3-flash-preview",
        "config": {
          "temperature": 0,
          "maxOutputTokens": 60000
        }
      },
      {
        "id": "openrouter:moonshotai/kimi-k2.5",
        "config": {
          "temperature": 0,
          "max_tokens": 16384
        }
      },
      {
        "id": "openrouter:z-ai/glm-4.7",
        "config": {
          "temperature": 0,
          "max_tokens": 16384
        }
      }
    ],
    "tests": [
      {
        "description": "Example 1: packages/auth/src/jwt/JwtService.ts",
        "vars": {
          "fileContent": "import * as crypto from 'crypto';\n\nexport interface JwtPayload {\n  sub: string;\n  iat: number;\n  exp: number;\n  iss?: string;\n  aud?: string;\n  [key: string]: unknown;\n}\n\nexport interface JwtHeader {\n  alg: string;\n  typ: string;\n}\n\nexport interface JwtConfig {\n  secret: string;\n  issuer: string;\n  audience: string;\n  expiresIn: number;\n}\n\nfunction base64UrlEncode(data: string | Buffer): string {\n  const base64 = Buffer.from(data).toString('base64');\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\n\nfunction base64UrlDecode(data: string): string {\n  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n  const padding = base64.length % 4;\n  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n  return Buffer.from(padded, 'base64').toString();\n}\n\nexport class JwtService {\n  private config: JwtConfig;\n\n  constructor(config: JwtConfig) {\n    this.config = config;\n  }\n\n  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n    const now = Math.floor(Date.now() / 1000);\n\n    const header: JwtHeader = {\n      alg: 'HS256',\n      typ: 'JWT',\n    };\n\n    const fullPayload: JwtPayload = {\n      ...payload,\n      iat: now,\n      exp: now + this.config.expiresIn,\n      iss: this.config.issuer,\n      aud: this.config.audience,\n    };\n\n    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n\n    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n\n    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n  }\n\n  verify(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    const [headerEncoded, payloadEncoded, signature] = parts;\n\n    try {\n      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n\n      // Verify algorithm\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\n        return null;\n      }\n\n      // Verify signature\n      if (header.alg !== 'none') {\n        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n        if (signature !== expectedSignature) {\n          return null;\n        }\n      }\n\n      // Check expiration\n      const now = Math.floor(Date.now() / 1000);\n      if (payload.exp && payload.exp < now) {\n        return null;\n      }\n\n      // Verify issuer and audience\n      if (payload.iss !== this.config.issuer) {\n        return null;\n      }\n\n      if (payload.aud !== this.config.audience) {\n        return null;\n      }\n\n      return payload;\n    } catch {\n      return null;\n    }\n  }\n\n  private createSignature(data: string): string {\n    const hmac = crypto.createHmac('sha256', this.config.secret);\n    hmac.update(data);\n    return base64UrlEncode(hmac.digest());\n  }\n\n  decode(token: string): JwtPayload | null {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  refresh(token: string): string | null {\n    const payload = this.verify(token);\n    if (!payload) {\n      return null;\n    }\n\n    const { iat, exp, ...rest } = payload;\n    return this.sign(rest);\n  }\n\n  isExpired(token: string): boolean {\n    const payload = this.decode(token);\n    if (!payload || !payload.exp) {\n      return true;\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n    return payload.exp < now;\n  }\n}\n\nexport function createJwtService(config: JwtConfig): JwtService {\n  return new JwtService(config);\n}\n",
          "patchWithLinesStr": "## file: 'packages/auth/src/jwt/JwtService.ts'\n\n@@ -0,0 +1,156 @@\n__new hunk__\n1 +import * as crypto from 'crypto';\n2 +\n3 +export interface JwtPayload {\n4 +  sub: string;\n5 +  iat: number;\n6 +  exp: number;\n7 +  iss?: string;\n8 +  aud?: string;\n9 +  [key: string]: unknown;\n10 +}\n11 +\n12 +export interface JwtHeader {\n13 +  alg: string;\n14 +  typ: string;\n15 +}\n16 +\n17 +export interface JwtConfig {\n18 +  secret: string;\n19 +  issuer: string;\n20 +  audience: string;\n21 +  expiresIn: number;\n22 +}\n23 +\n24 +function base64UrlEncode(data: string | Buffer): string {\n25 +  const base64 = Buffer.from(data).toString('base64');\n26 +  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n27 +}\n28 +\n29 +function base64UrlDecode(data: string): string {\n30 +  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n31 +  const padding = base64.length % 4;\n32 +  const padded = padding ? base64 + '='.repeat(4 - padding) : base64;\n33 +  return Buffer.from(padded, 'base64').toString();\n34 +}\n35 +\n36 +export class JwtService {\n37 +  private config: JwtConfig;\n38 +\n39 +  constructor(config: JwtConfig) {\n40 +    this.config = config;\n41 +  }\n42 +\n43 +  sign(payload: Omit<JwtPayload, 'iat' | 'exp'>): string {\n44 +    const now = Math.floor(Date.now() / 1000);\n45 +\n46 +    const header: JwtHeader = {\n47 +      alg: 'HS256',\n48 +      typ: 'JWT',\n49 +    };\n50 +\n51 +    const fullPayload: JwtPayload = {\n52 +      ...payload,\n53 +      iat: now,\n54 +      exp: now + this.config.expiresIn,\n55 +      iss: this.config.issuer,\n56 +      aud: this.config.audience,\n57 +    };\n58 +\n59 +    const headerEncoded = base64UrlEncode(JSON.stringify(header));\n60 +    const payloadEncoded = base64UrlEncode(JSON.stringify(fullPayload));\n61 +\n62 +    const signature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n63 +\n64 +    return `${headerEncoded}.${payloadEncoded}.${signature}`;\n65 +  }\n66 +\n67 +  verify(token: string): JwtPayload | null {\n68 +    const parts = token.split('.');\n69 +    if (parts.length !== 3) {\n70 +      return null;\n71 +    }\n72 +\n73 +    const [headerEncoded, payloadEncoded, signature] = parts;\n74 +\n75 +    try {\n76 +      const header = JSON.parse(base64UrlDecode(headerEncoded)) as JwtHeader;\n77 +      const payload = JSON.parse(base64UrlDecode(payloadEncoded)) as JwtPayload;\n78 +\n79 +      // Verify algorithm\n80 +      if (header.alg !== 'HS256' && header.alg !== 'none') {\n81 +        return null;\n82 +      }\n83 +\n84 +      // Verify signature\n85 +      if (header.alg !== 'none') {\n86 +        const expectedSignature = this.createSignature(`${headerEncoded}.${payloadEncoded}`);\n87 +        if (signature !== expectedSignature) {\n88 +          return null;\n89 +        }\n90 +      }\n91 +\n92 +      // Check expiration\n93 +      const now = Math.floor(Date.now() / 1000);\n94 +      if (payload.exp && payload.exp < now) {\n95 +        return null;\n96 +      }\n97 +\n98 +      // Verify issuer and audience\n99 +      if (payload.iss !== this.config.issuer) {\n100 +        return null;\n101 +      }\n102 +\n103 +      if (payload.aud !== this.config.audience) {\n104 +        return null;\n105 +      }\n106 +\n107 +      return payload;\n108 +    } catch {\n109 +      return null;\n110 +    }\n111 +  }\n112 +\n113 +  private createSignature(data: string): string {\n114 +    const hmac = crypto.createHmac('sha256', this.config.secret);\n115 +    hmac.update(data);\n116 +    return base64UrlEncode(hmac.digest());\n117 +  }\n118 +\n119 +  decode(token: string): JwtPayload | null {\n120 +    const parts = token.split('.');\n121 +    if (parts.length !== 3) {\n122 +      return null;\n123 +    }\n124 +\n125 +    try {\n126 +      return JSON.parse(base64UrlDecode(parts[1])) as JwtPayload;\n127 +    } catch {\n128 +      return null;\n129 +    }\n130 +  }\n131 +\n132 +  refresh(token: string): string | null {\n133 +    const payload = this.verify(token);\n134 +    if (!payload) {\n135 +      return null;\n136 +    }\n137 +\n138 +    const { iat, exp, ...rest } = payload;\n139 +    return this.sign(rest);\n140 +  }\n141 +\n142 +  isExpired(token: string): boolean {\n143 +    const payload = this.decode(token);\n144 +    if (!payload || !payload.exp) {\n145 +      return true;\n146 +    }\n147 +\n148 +    const now = Math.floor(Date.now() / 1000);\n149 +    return payload.exp < now;\n150 +  }\n151 +}\n152 +\n153 +export function createJwtService(config: JwtConfig): JwtService {\n154 +  return new JwtService(config);\n155 +}\n156 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/auth/src/jwt/JwtService.ts\",\"relevantLinesStart\":75,\"relevantLinesEnd\":81},{\"relevantFile\":\"packages/auth/src/jwt/JwtService.ts\",\"relevantLinesStart\":83,\"relevantLinesEnd\":85}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"// Verify algorithm\\n      if (header.alg !== 'HS256' && header.alg !== 'none') {\\n        return null;\\n      }\\n\\n      // Verify signature\\n      if (header.alg !== 'none') {\",\n    \"improvedCode\": \"// Verify algorithm - NEVER accept 'none'\\n      if (header.alg !== 'HS256') {\\n        return null;\\n      }\\n\\n      // Verify signature\",\n    \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n    \"relevantLinesEnd\": 81,\n    \"suggestionContent\": \"The `verify` method accepts tokens with `alg: 'none'`, which means an attacker can forge tokens by setting the algorithm to 'none' and providing an empty signature. This is the classic JWT algorithm confusion attack. Never accept 'none' as a valid algorithm.\",\n    \"oneSentenceSummary\": \"JWT algorithm confusion - accepting 'none' allows forged tokens\",\n    \"relevantLinesStart\": 75\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (signature !== expectedSignature) {\\n          return null;\\n        }\",\n    \"improvedCode\": \"if (!crypto.timingSafeEqual(\\n          Buffer.from(signature),\\n          Buffer.from(expectedSignature)\\n        )) {\\n          return null;\\n        }\",\n    \"relevantFile\": \"packages/auth/src/jwt/JwtService.ts\",\n    \"relevantLinesEnd\": 85,\n    \"suggestionContent\": \"The signature comparison `signature !== expectedSignature` uses JavaScript's standard string comparison, which is not constant-time. This allows timing attacks where an attacker can determine how many characters of the signature match by measuring response times. Use a constant-time comparison function.\",\n    \"oneSentenceSummary\": \"Timing attack vulnerability - signature comparison is not constant-time\",\n    \"relevantLinesStart\": 83\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 2: packages/core/src/cache/RequestCache.ts",
        "vars": {
          "fileContent": "import { Logger } from '../utils/logger';\n\ninterface CacheEntry<T> {\n  value: T;\n  timestamp: number;\n  ttl: number;\n}\n\ninterface CacheOptions {\n  defaultTtl: number;\n  maxSize: number;\n  onEvict?: (key: string, value: unknown) => void;\n}\n\nexport class RequestCache<T = unknown> {\n  private readonly cache: WeakMap<object, CacheEntry<T>>;\n  private readonly logger: Logger;\n  private readonly options: CacheOptions;\n  private hits = 0;\n  private misses = 0;\n\n  constructor(options: Partial<CacheOptions> = {}) {\n    this.cache = new WeakMap();\n    this.logger = new Logger('RequestCache');\n    this.options = {\n      defaultTtl: 60000,\n      maxSize: 1000,\n      ...options,\n    };\n  }\n\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key as unknown as object);\n    if (!entry) {\n      this.misses++;\n      return undefined;\n    }\n\n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.cache.delete(key as unknown as object);\n      this.misses++;\n      return undefined;\n    }\n\n    this.hits++;\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      ttl: ttl ?? this.options.defaultTtl,\n    };\n    this.cache.set(key as unknown as object, entry);\n    this.logger.debug(`Cached key: ${key}`);\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key as unknown as object);\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      hitRate: total > 0 ? this.hits / total : 0,\n    };\n  }\n\n  clear(): void {\n    this.cache = new WeakMap();\n    this.hits = 0;\n    this.misses = 0;\n  }\n}\n\nexport function createRequestCache<T>(options?: Partial<CacheOptions>) {\n  return new RequestCache<T>(options);\n}\n",
          "patchWithLinesStr": "## file: 'packages/core/src/cache/RequestCache.ts'\n\n@@ -0,0 +1,82 @@\n__new hunk__\n1 +import { Logger } from '../utils/logger';\n2 +\n3 +interface CacheEntry<T> {\n4 +  value: T;\n5 +  timestamp: number;\n6 +  ttl: number;\n7 +}\n8 +\n9 +interface CacheOptions {\n10 +  defaultTtl: number;\n11 +  maxSize: number;\n12 +  onEvict?: (key: string, value: unknown) => void;\n13 +}\n14 +\n15 +export class RequestCache<T = unknown> {\n16 +  private readonly cache: WeakMap<object, CacheEntry<T>>;\n17 +  private readonly logger: Logger;\n18 +  private readonly options: CacheOptions;\n19 +  private hits = 0;\n20 +  private misses = 0;\n21 +\n22 +  constructor(options: Partial<CacheOptions> = {}) {\n23 +    this.cache = new WeakMap();\n24 +    this.logger = new Logger('RequestCache');\n25 +    this.options = {\n26 +      defaultTtl: 60000,\n27 +      maxSize: 1000,\n28 +      ...options,\n29 +    };\n30 +  }\n31 +\n32 +  get(key: string): T | undefined {\n33 +    const entry = this.cache.get(key as unknown as object);\n34 +    if (!entry) {\n35 +      this.misses++;\n36 +      return undefined;\n37 +    }\n38 +\n39 +    if (Date.now() - entry.timestamp > entry.ttl) {\n40 +      this.cache.delete(key as unknown as object);\n41 +      this.misses++;\n42 +      return undefined;\n43 +    }\n44 +\n45 +    this.hits++;\n46 +    return entry.value;\n47 +  }\n48 +\n49 +  set(key: string, value: T, ttl?: number): void {\n50 +    const entry: CacheEntry<T> = {\n51 +      value,\n52 +      timestamp: Date.now(),\n53 +      ttl: ttl ?? this.options.defaultTtl,\n54 +    };\n55 +    this.cache.set(key as unknown as object, entry);\n56 +    this.logger.debug(`Cached key: ${key}`);\n57 +  }\n58 +\n59 +  delete(key: string): boolean {\n60 +    return this.cache.delete(key as unknown as object);\n61 +  }\n62 +\n63 +  getStats() {\n64 +    const total = this.hits + this.misses;\n65 +    return {\n66 +      hits: this.hits,\n67 +      misses: this.misses,\n68 +      hitRate: total > 0 ? this.hits / total : 0,\n69 +    };\n70 +  }\n71 +\n72 +  clear(): void {\n73 +    this.cache = new WeakMap();\n74 +    this.hits = 0;\n75 +    this.misses = 0;\n76 +  }\n77 +}\n78 +\n79 +export function createRequestCache<T>(options?: Partial<CacheOptions>) {\n80 +  return new RequestCache<T>(options);\n81 +}\n82 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/core/src/cache/RequestCache.ts\",\"relevantLinesStart\":17,\"relevantLinesEnd\":17}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"private readonly cache: WeakMap<object, CacheEntry<T>>;\",\n    \"improvedCode\": \"private readonly cache: Map<string, CacheEntry<T>>;\",\n    \"relevantFile\": \"packages/core/src/cache/RequestCache.ts\",\n    \"relevantLinesEnd\": 17,\n    \"suggestionContent\": \"WeakMap only accepts objects as keys, not primitive values like strings. The code casts strings to objects with `as unknown as object`, but this doesn't actually convert the string to an object - it just bypasses TypeScript's type checking. At runtime, WeakMap.set() will throw a TypeError when called with a string key. Use a regular Map instead of WeakMap for string keys, or if you need weak references, use the string as a property of a wrapper object.\",\n    \"oneSentenceSummary\": \"WeakMap cannot use primitive string keys - will throw TypeError at runtime\",\n    \"relevantLinesStart\": 17\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 3: packages/text/src/utils/TextTruncator.ts",
        "vars": {
          "fileContent": "export interface TruncateOptions {\n  maxLength: number;\n  ellipsis?: string;\n  wordBoundary?: boolean;\n  preserveWords?: boolean;\n}\n\nconst DEFAULT_ELLIPSIS = '...';\n\nexport function getCharacterCount(text: string): number {\n  return text.length;\n}\n\nexport function truncateText(\n  text: string,\n  options: TruncateOptions\n): string {\n  const {\n    maxLength,\n    ellipsis = DEFAULT_ELLIPSIS,\n    wordBoundary = false,\n  } = options;\n\n  if (text.length <= maxLength) {\n    return text;\n  }\n\n  const truncateAt = maxLength - ellipsis.length;\n\n  if (truncateAt <= 0) {\n    return ellipsis.slice(0, maxLength);\n  }\n\n  let truncated = text.slice(0, truncateAt);\n\n  if (wordBoundary) {\n    const lastSpace = truncated.lastIndexOf(' ');\n    if (lastSpace > truncateAt * 0.5) {\n      truncated = truncated.slice(0, lastSpace);\n    }\n  }\n\n  return truncated + ellipsis;\n}\n\nexport function truncateMiddle(\n  text: string,\n  maxLength: number,\n  separator: string = '...'\n): string {\n  if (text.length <= maxLength) {\n    return text;\n  }\n\n  const separatorLength = separator.length;\n  const charsToShow = maxLength - separatorLength;\n\n  if (charsToShow <= 0) {\n    return separator.slice(0, maxLength);\n  }\n\n  const frontChars = Math.ceil(charsToShow / 2);\n  const backChars = Math.floor(charsToShow / 2);\n\n  return text.slice(0, frontChars) + separator + text.slice(-backChars);\n}\n\nexport function countWords(text: string): number {\n  return text.trim().split(/\\s+/).filter(Boolean).length;\n}\n\nexport function truncateWords(\n  text: string,\n  maxWords: number,\n  ellipsis: string = DEFAULT_ELLIPSIS\n): string {\n  const words = text.trim().split(/\\s+/);\n\n  if (words.length <= maxWords) {\n    return text;\n  }\n\n  return words.slice(0, maxWords).join(' ') + ellipsis;\n}\n\nexport class TextTruncator {\n  private defaultOptions: TruncateOptions;\n\n  constructor(defaultOptions: Partial<TruncateOptions> = {}) {\n    this.defaultOptions = {\n      maxLength: 100,\n      ellipsis: DEFAULT_ELLIPSIS,\n      wordBoundary: true,\n      ...defaultOptions,\n    };\n  }\n\n  truncate(text: string, options?: Partial<TruncateOptions>): string {\n    return truncateText(text, { ...this.defaultOptions, ...options });\n  }\n\n  truncateForDisplay(text: string, maxLength: number): string {\n    return truncateText(text, {\n      ...this.defaultOptions,\n      maxLength,\n      wordBoundary: true,\n    });\n  }\n\n  getLength(text: string): number {\n    return getCharacterCount(text);\n  }\n\n  isWithinLimit(text: string, limit: number): boolean {\n    return this.getLength(text) <= limit;\n  }\n}\n\nexport default TextTruncator;\n",
          "patchWithLinesStr": "## file: 'packages/text/src/utils/TextTruncator.ts'\n\n@@ -0,0 +1,120 @@\n__new hunk__\n1 +export interface TruncateOptions {\n2 +  maxLength: number;\n3 +  ellipsis?: string;\n4 +  wordBoundary?: boolean;\n5 +  preserveWords?: boolean;\n6 +}\n7 +\n8 +const DEFAULT_ELLIPSIS = '...';\n9 +\n10 +export function getCharacterCount(text: string): number {\n11 +  return text.length;\n12 +}\n13 +\n14 +export function truncateText(\n15 +  text: string,\n16 +  options: TruncateOptions\n17 +): string {\n18 +  const {\n19 +    maxLength,\n20 +    ellipsis = DEFAULT_ELLIPSIS,\n21 +    wordBoundary = false,\n22 +  } = options;\n23 +\n24 +  if (text.length <= maxLength) {\n25 +    return text;\n26 +  }\n27 +\n28 +  const truncateAt = maxLength - ellipsis.length;\n29 +\n30 +  if (truncateAt <= 0) {\n31 +    return ellipsis.slice(0, maxLength);\n32 +  }\n33 +\n34 +  let truncated = text.slice(0, truncateAt);\n35 +\n36 +  if (wordBoundary) {\n37 +    const lastSpace = truncated.lastIndexOf(' ');\n38 +    if (lastSpace > truncateAt * 0.5) {\n39 +      truncated = truncated.slice(0, lastSpace);\n40 +    }\n41 +  }\n42 +\n43 +  return truncated + ellipsis;\n44 +}\n45 +\n46 +export function truncateMiddle(\n47 +  text: string,\n48 +  maxLength: number,\n49 +  separator: string = '...'\n50 +): string {\n51 +  if (text.length <= maxLength) {\n52 +    return text;\n53 +  }\n54 +\n55 +  const separatorLength = separator.length;\n56 +  const charsToShow = maxLength - separatorLength;\n57 +\n58 +  if (charsToShow <= 0) {\n59 +    return separator.slice(0, maxLength);\n60 +  }\n61 +\n62 +  const frontChars = Math.ceil(charsToShow / 2);\n63 +  const backChars = Math.floor(charsToShow / 2);\n64 +\n65 +  return text.slice(0, frontChars) + separator + text.slice(-backChars);\n66 +}\n67 +\n68 +export function countWords(text: string): number {\n69 +  return text.trim().split(/\\s+/).filter(Boolean).length;\n70 +}\n71 +\n72 +export function truncateWords(\n73 +  text: string,\n74 +  maxWords: number,\n75 +  ellipsis: string = DEFAULT_ELLIPSIS\n76 +): string {\n77 +  const words = text.trim().split(/\\s+/);\n78 +\n79 +  if (words.length <= maxWords) {\n80 +    return text;\n81 +  }\n82 +\n83 +  return words.slice(0, maxWords).join(' ') + ellipsis;\n84 +}\n85 +\n86 +export class TextTruncator {\n87 +  private defaultOptions: TruncateOptions;\n88 +\n89 +  constructor(defaultOptions: Partial<TruncateOptions> = {}) {\n90 +    this.defaultOptions = {\n91 +      maxLength: 100,\n92 +      ellipsis: DEFAULT_ELLIPSIS,\n93 +      wordBoundary: true,\n94 +      ...defaultOptions,\n95 +    };\n96 +  }\n97 +\n98 +  truncate(text: string, options?: Partial<TruncateOptions>): string {\n99 +    return truncateText(text, { ...this.defaultOptions, ...options });\n100 +  }\n101 +\n102 +  truncateForDisplay(text: string, maxLength: number): string {\n103 +    return truncateText(text, {\n104 +      ...this.defaultOptions,\n105 +      maxLength,\n106 +      wordBoundary: true,\n107 +    });\n108 +  }\n109 +\n110 +  getLength(text: string): number {\n111 +    return getCharacterCount(text);\n112 +  }\n113 +\n114 +  isWithinLimit(text: string, limit: number): boolean {\n115 +    return this.getLength(text) <= limit;\n116 +  }\n117 +}\n118 +\n119 +export default TextTruncator;\n120 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/text/src/utils/TextTruncator.ts\",\"relevantLinesStart\":10,\"relevantLinesEnd\":12}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"export function getCharacterCount(text: string): number {\\n  return text.length;\\n}\",\n    \"improvedCode\": \"export function getCharacterCount(text: string): number {\\n  return [...text].length;\\n}\",\n    \"relevantFile\": \"packages/text/src/utils/TextTruncator.ts\",\n    \"relevantLinesEnd\": 12,\n    \"suggestionContent\": \"The `getCharacterCount` function and all length checks use `string.length`, which counts UTF-16 code units, not actual characters (graphemes). This causes incorrect behavior with emojis, accented characters, and other Unicode text. For example, '👨‍👩‍👧‍👦' has `.length` of 11 but is visually 1 character; '🇺🇸' has `.length` of 4 but is 1 flag emoji. Text could be truncated in the middle of a multi-code-unit character, producing invalid Unicode or broken emoji. Use `Intl.Segmenter` or spread syntax `[...text].length` for accurate character counting.\",\n    \"oneSentenceSummary\": \"String.length counts UTF-16 code units not characters - breaks with emoji/Unicode\",\n    \"relevantLinesStart\": 10\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 4: packages/realtime/src/client/WebSocketManager.ts",
        "vars": {
          "fileContent": "export type MessageHandler = (data: unknown) => void;\nexport type ConnectionHandler = () => void;\nexport type ErrorHandler = (error: Event) => void;\n\nexport interface WebSocketConfig {\n  url: string;\n  protocols?: string[];\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n  heartbeatInterval: number;\n  messageQueueSize: number;\n}\n\nexport interface QueuedMessage {\n  data: string;\n  timestamp: number;\n  priority: number;\n}\n\nconst DEFAULT_CONFIG: Partial<WebSocketConfig> = {\n  reconnectInterval: 1000,\n  maxReconnectAttempts: 10,\n  heartbeatInterval: 30000,\n  messageQueueSize: 100,\n};\n\nexport class WebSocketManager {\n  private socket: WebSocket | null = null;\n  private config: WebSocketConfig;\n  private messageHandlers: Map<string, Set<MessageHandler>> = new Map();\n  private connectionHandlers: Set<ConnectionHandler> = new Set();\n  private errorHandlers: Set<ErrorHandler> = new Set();\n  private messageQueue: QueuedMessage[] = [];\n  private reconnectAttempts = 0;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private isConnecting = false;\n  private isIntentionallyClosed = false;\n\n  constructor(config: Partial<WebSocketConfig> & { url: string }) {\n    this.config = { ...DEFAULT_CONFIG, ...config } as WebSocketConfig;\n  }\n\n  connect(): void {\n    if (this.socket?.readyState === WebSocket.OPEN || this.isConnecting) {\n      return;\n    }\n\n    this.isConnecting = true;\n    this.isIntentionallyClosed = false;\n\n    try {\n      this.socket = new WebSocket(this.config.url, this.config.protocols);\n      this.setupEventHandlers();\n    } catch (error) {\n      this.isConnecting = false;\n      this.handleReconnect();\n    }\n  }\n\n  private setupEventHandlers(): void {\n    if (!this.socket) return;\n\n    this.socket.onopen = () => {\n      this.isConnecting = false;\n      this.reconnectAttempts = 0;\n      this.startHeartbeat();\n      this.flushMessageQueue();\n      this.connectionHandlers.forEach(handler => handler());\n    };\n\n    this.socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        const type = message.type || 'default';\n        const handlers = this.messageHandlers.get(type);\n\n        if (handlers) {\n          handlers.forEach(handler => handler(message.payload));\n        }\n      } catch (error) {\n        console.error('Failed to parse WebSocket message:', error);\n      }\n    };\n\n    this.socket.onclose = (event) => {\n      this.stopHeartbeat();\n      this.isConnecting = false;\n\n      if (!this.isIntentionallyClosed && !event.wasClean) {\n        this.handleReconnect();\n      }\n    };\n\n    this.socket.onerror = (error) => {\n      this.errorHandlers.forEach(handler => handler(error));\n    };\n  }\n\n  private handleReconnect(): void {\n    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      return;\n    }\n\n    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\n    this.reconnectAttempts++;\n\n    this.reconnectTimeout = setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      if (this.socket?.readyState === WebSocket.OPEN) {\n        this.socket.send(JSON.stringify({ type: 'ping' }));\n      }\n    }, this.config.heartbeatInterval);\n  }\n\n  private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n  }\n\n  private flushMessageQueue(): void {\n    while (this.messageQueue.length > 0 && this.socket?.readyState === WebSocket.OPEN) {\n      const message = this.messageQueue.shift();\n      if (message) {\n        this.socket.send(message.data);\n      }\n    }\n  }\n\n  send(type: string, payload: unknown, priority = 0): boolean {\n    const message = JSON.stringify({ type, payload });\n\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      this.socket.send(message);\n      return true;\n    }\n\n    if (this.messageQueue.length < this.config.messageQueueSize) {\n      this.messageQueue.push({\n        data: message,\n        timestamp: Date.now(),\n        priority,\n      });\n      this.messageQueue.sort((a, b) => b.priority - a.priority);\n      return true;\n    }\n\n    return false;\n  }\n\n  on(type: string, handler: MessageHandler): () => void {\n    if (!this.messageHandlers.has(type)) {\n      this.messageHandlers.set(type, new Set());\n    }\n    this.messageHandlers.get(type)!.add(handler);\n\n    return () => {\n      this.messageHandlers.get(type)?.delete(handler);\n    };\n  }\n\n  onConnect(handler: ConnectionHandler): () => void {\n    this.connectionHandlers.add(handler);\n    return () => this.connectionHandlers.delete(handler);\n  }\n\n  onError(handler: ErrorHandler): () => void {\n    this.errorHandlers.add(handler);\n    return () => this.errorHandlers.delete(handler);\n  }\n\n  disconnect(): void {\n    this.isIntentionallyClosed = true;\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n\n    this.stopHeartbeat();\n\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  getReadyState(): number {\n    return this.socket?.readyState ?? WebSocket.CLOSED;\n  }\n\n  isConnected(): boolean {\n    return this.socket?.readyState === WebSocket.OPEN;\n  }\n}\n\nexport function createWebSocketManager(\n  config: Partial<WebSocketConfig> & { url: string }\n): WebSocketManager {\n  return new WebSocketManager(config);\n}\n",
          "patchWithLinesStr": "## file: 'packages/realtime/src/client/WebSocketManager.ts'\n\n@@ -0,0 +1,208 @@\n__new hunk__\n1 +export type MessageHandler = (data: unknown) => void;\n2 +export type ConnectionHandler = () => void;\n3 +export type ErrorHandler = (error: Event) => void;\n4 +\n5 +export interface WebSocketConfig {\n6 +  url: string;\n7 +  protocols?: string[];\n8 +  reconnectInterval: number;\n9 +  maxReconnectAttempts: number;\n10 +  heartbeatInterval: number;\n11 +  messageQueueSize: number;\n12 +}\n13 +\n14 +export interface QueuedMessage {\n15 +  data: string;\n16 +  timestamp: number;\n17 +  priority: number;\n18 +}\n19 +\n20 +const DEFAULT_CONFIG: Partial<WebSocketConfig> = {\n21 +  reconnectInterval: 1000,\n22 +  maxReconnectAttempts: 10,\n23 +  heartbeatInterval: 30000,\n24 +  messageQueueSize: 100,\n25 +};\n26 +\n27 +export class WebSocketManager {\n28 +  private socket: WebSocket | null = null;\n29 +  private config: WebSocketConfig;\n30 +  private messageHandlers: Map<string, Set<MessageHandler>> = new Map();\n31 +  private connectionHandlers: Set<ConnectionHandler> = new Set();\n32 +  private errorHandlers: Set<ErrorHandler> = new Set();\n33 +  private messageQueue: QueuedMessage[] = [];\n34 +  private reconnectAttempts = 0;\n35 +  private reconnectTimeout: NodeJS.Timeout | null = null;\n36 +  private heartbeatInterval: NodeJS.Timeout | null = null;\n37 +  private isConnecting = false;\n38 +  private isIntentionallyClosed = false;\n39 +\n40 +  constructor(config: Partial<WebSocketConfig> & { url: string }) {\n41 +    this.config = { ...DEFAULT_CONFIG, ...config } as WebSocketConfig;\n42 +  }\n43 +\n44 +  connect(): void {\n45 +    if (this.socket?.readyState === WebSocket.OPEN || this.isConnecting) {\n46 +      return;\n47 +    }\n48 +\n49 +    this.isConnecting = true;\n50 +    this.isIntentionallyClosed = false;\n51 +\n52 +    try {\n53 +      this.socket = new WebSocket(this.config.url, this.config.protocols);\n54 +      this.setupEventHandlers();\n55 +    } catch (error) {\n56 +      this.isConnecting = false;\n57 +      this.handleReconnect();\n58 +    }\n59 +  }\n60 +\n61 +  private setupEventHandlers(): void {\n62 +    if (!this.socket) return;\n63 +\n64 +    this.socket.onopen = () => {\n65 +      this.isConnecting = false;\n66 +      this.reconnectAttempts = 0;\n67 +      this.startHeartbeat();\n68 +      this.flushMessageQueue();\n69 +      this.connectionHandlers.forEach(handler => handler());\n70 +    };\n71 +\n72 +    this.socket.onmessage = (event) => {\n73 +      try {\n74 +        const message = JSON.parse(event.data);\n75 +        const type = message.type || 'default';\n76 +        const handlers = this.messageHandlers.get(type);\n77 +\n78 +        if (handlers) {\n79 +          handlers.forEach(handler => handler(message.payload));\n80 +        }\n81 +      } catch (error) {\n82 +        console.error('Failed to parse WebSocket message:', error);\n83 +      }\n84 +    };\n85 +\n86 +    this.socket.onclose = (event) => {\n87 +      this.stopHeartbeat();\n88 +      this.isConnecting = false;\n89 +\n90 +      if (!this.isIntentionallyClosed && !event.wasClean) {\n91 +        this.handleReconnect();\n92 +      }\n93 +    };\n94 +\n95 +    this.socket.onerror = (error) => {\n96 +      this.errorHandlers.forEach(handler => handler(error));\n97 +    };\n98 +  }\n99 +\n100 +  private handleReconnect(): void {\n101 +    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\n102 +      console.error('Max reconnection attempts reached');\n103 +      return;\n104 +    }\n105 +\n106 +    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\n107 +    this.reconnectAttempts++;\n108 +\n109 +    this.reconnectTimeout = setTimeout(() => {\n110 +      this.connect();\n111 +    }, delay);\n112 +  }\n113 +\n114 +  private startHeartbeat(): void {\n115 +    this.heartbeatInterval = setInterval(() => {\n116 +      if (this.socket?.readyState === WebSocket.OPEN) {\n117 +        this.socket.send(JSON.stringify({ type: 'ping' }));\n118 +      }\n119 +    }, this.config.heartbeatInterval);\n120 +  }\n121 +\n122 +  private stopHeartbeat(): void {\n123 +    if (this.heartbeatInterval) {\n124 +      clearInterval(this.heartbeatInterval);\n125 +    }\n126 +  }\n127 +\n128 +  private flushMessageQueue(): void {\n129 +    while (this.messageQueue.length > 0 && this.socket?.readyState === WebSocket.OPEN) {\n130 +      const message = this.messageQueue.shift();\n131 +      if (message) {\n132 +        this.socket.send(message.data);\n133 +      }\n134 +    }\n135 +  }\n136 +\n137 +  send(type: string, payload: unknown, priority = 0): boolean {\n138 +    const message = JSON.stringify({ type, payload });\n139 +\n140 +    if (this.socket?.readyState === WebSocket.OPEN) {\n141 +      this.socket.send(message);\n142 +      return true;\n143 +    }\n144 +\n145 +    if (this.messageQueue.length < this.config.messageQueueSize) {\n146 +      this.messageQueue.push({\n147 +        data: message,\n148 +        timestamp: Date.now(),\n149 +        priority,\n150 +      });\n151 +      this.messageQueue.sort((a, b) => b.priority - a.priority);\n152 +      return true;\n153 +    }\n154 +\n155 +    return false;\n156 +  }\n157 +\n158 +  on(type: string, handler: MessageHandler): () => void {\n159 +    if (!this.messageHandlers.has(type)) {\n160 +      this.messageHandlers.set(type, new Set());\n161 +    }\n162 +    this.messageHandlers.get(type)!.add(handler);\n163 +\n164 +    return () => {\n165 +      this.messageHandlers.get(type)?.delete(handler);\n166 +    };\n167 +  }\n168 +\n169 +  onConnect(handler: ConnectionHandler): () => void {\n170 +    this.connectionHandlers.add(handler);\n171 +    return () => this.connectionHandlers.delete(handler);\n172 +  }\n173 +\n174 +  onError(handler: ErrorHandler): () => void {\n175 +    this.errorHandlers.add(handler);\n176 +    return () => this.errorHandlers.delete(handler);\n177 +  }\n178 +\n179 +  disconnect(): void {\n180 +    this.isIntentionallyClosed = true;\n181 +\n182 +    if (this.reconnectTimeout) {\n183 +      clearTimeout(this.reconnectTimeout);\n184 +    }\n185 +\n186 +    this.stopHeartbeat();\n187 +\n188 +    if (this.socket) {\n189 +      this.socket.close();\n190 +      this.socket = null;\n191 +    }\n192 +  }\n193 +\n194 +  getReadyState(): number {\n195 +    return this.socket?.readyState ?? WebSocket.CLOSED;\n196 +  }\n197 +\n198 +  isConnected(): boolean {\n199 +    return this.socket?.readyState === WebSocket.OPEN;\n200 +  }\n201 +}\n202 +\n203 +export function createWebSocketManager(\n204 +  config: Partial<WebSocketConfig> & { url: string }\n205 +): WebSocketManager {\n206 +  return new WebSocketManager(config);\n207 +}\n208 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/realtime/src/client/WebSocketManager.ts\",\"relevantLinesStart\":108,\"relevantLinesEnd\":112},{\"relevantFile\":\"packages/realtime/src/client/WebSocketManager.ts\",\"relevantLinesStart\":91,\"relevantLinesEnd\":100},{\"relevantFile\":\"packages/realtime/src/client/WebSocketManager.ts\",\"relevantLinesStart\":131,\"relevantLinesEnd\":138}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"private stopHeartbeat(): void {\\n    if (this.heartbeatInterval) {\\n      clearInterval(this.heartbeatInterval);\\n    }\\n  }\",\n    \"improvedCode\": \"private stopHeartbeat(): void {\\n    if (this.heartbeatInterval) {\\n      clearInterval(this.heartbeatInterval);\\n      this.heartbeatInterval = null;\\n    }\\n  }\",\n    \"relevantFile\": \"packages/realtime/src/client/WebSocketManager.ts\",\n    \"relevantLinesEnd\": 112,\n    \"suggestionContent\": \"The `stopHeartbeat` method clears the interval but doesn't set `this.heartbeatInterval` to null. When `startHeartbeat` is called again after reconnection, it creates a new interval without clearing the previous one (which may still exist if the reference wasn't properly cleaned). This can cause multiple heartbeat intervals running simultaneously after several reconnects.\",\n    \"oneSentenceSummary\": \"Heartbeat interval not nullified after clear - multiple intervals after reconnects\",\n    \"relevantLinesStart\": 108\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"private handleReconnect(): void {\\n    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\\n      console.error('Max reconnection attempts reached');\\n      return;\\n    }\\n\\n    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\\n    this.reconnectAttempts++;\\n\\n    this.reconnectTimeout = setTimeout(() => {\",\n    \"improvedCode\": \"private handleReconnect(): void {\\n    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {\\n      console.error('Max reconnection attempts reached');\\n      return;\\n    }\\n\\n    if (this.reconnectTimeout) {\\n      clearTimeout(this.reconnectTimeout);\\n    }\\n\\n    const delay = this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts);\\n    this.reconnectAttempts++;\\n\\n    this.reconnectTimeout = setTimeout(() => {\",\n    \"relevantFile\": \"packages/realtime/src/client/WebSocketManager.ts\",\n    \"relevantLinesEnd\": 100,\n    \"suggestionContent\": \"The `handleReconnect` method doesn't clear an existing `reconnectTimeout` before setting a new one. If `handleReconnect` is called multiple times quickly (e.g., due to rapid close/error events), multiple reconnection timeouts will be scheduled, causing multiple simultaneous connection attempts.\",\n    \"oneSentenceSummary\": \"Missing timeout clear before reconnect - multiple concurrent reconnection attempts\",\n    \"relevantLinesStart\": 91\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (this.messageQueue.length < this.config.messageQueueSize) {\\n      this.messageQueue.push({\\n        data: message,\\n        timestamp: Date.now(),\\n        priority,\\n      });\\n      this.messageQueue.sort((a, b) => b.priority - a.priority);\\n      return true;\\n    }\",\n    \"improvedCode\": \"if (this.messageQueue.length < this.config.messageQueueSize) {\\n      // Remove expired messages (older than 30 seconds)\\n      const now = Date.now();\\n      this.messageQueue = this.messageQueue.filter(m => now - m.timestamp < 30000);\\n      \\n      this.messageQueue.push({\\n        data: message,\\n        timestamp: now,\\n        priority,\\n      });\\n      this.messageQueue.sort((a, b) => b.priority - a.priority);\\n      return true;\\n    }\",\n    \"relevantFile\": \"packages/realtime/src/client/WebSocketManager.ts\",\n    \"relevantLinesEnd\": 138,\n    \"suggestionContent\": \"The message queue's `sort` by priority is called every time a message is added, which is O(n log n). More importantly, when flushing the queue with `shift()`, messages are dequeued in array order, not priority order since shift() removes from the front but sort() put highest priority at the front - wait, that's correct. However, there's still an issue: the queue doesn't expire old messages. Messages queued while offline could be sent much later when they're no longer relevant, causing stale data issues.\",\n    \"oneSentenceSummary\": \"Message queue never expires old messages - stale data sent after reconnection\",\n    \"relevantLinesStart\": 131\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 5: packages/validation/src/validators/InputValidator.ts",
        "vars": {
          "fileContent": "export interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nexport interface ValidationRule {\n  name: string;\n  validate: (value: string) => boolean;\n  message: string;\n}\n\nconst PATTERNS = {\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/g,\n  phone: /^\\+?[1-9]\\d{1,14}$/g,\n  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/g,\n  username: /^[a-zA-Z][a-zA-Z0-9_]{2,29}$/g,\n  alphanumeric: /^[a-zA-Z0-9]+$/g,\n  numeric: /^\\d+$/g,\n  url: /^https?:\\/\\/[^\\s/$.?#].[^\\s]*$/gi,\n};\n\nexport function validateEmail(email: string): boolean {\n  return PATTERNS.email.test(email);\n}\n\nexport function validatePhone(phone: string): boolean {\n  return PATTERNS.phone.test(phone);\n}\n\nexport function validateSlug(slug: string): boolean {\n  return PATTERNS.slug.test(slug);\n}\n\nexport function validateUsername(username: string): boolean {\n  return PATTERNS.username.test(username);\n}\n\nexport function validateUrl(url: string): boolean {\n  return PATTERNS.url.test(url);\n}\n\nexport function validateField(\n  value: string,\n  rules: ValidationRule[]\n): ValidationResult {\n  const errors: string[] = [];\n\n  for (const rule of rules) {\n    if (!rule.validate(value)) {\n      errors.push(rule.message);\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\nexport function createPatternRule(\n  name: string,\n  pattern: RegExp,\n  message: string\n): ValidationRule {\n  return {\n    name,\n    validate: (value: string) => pattern.test(value),\n    message,\n  };\n}\n\nexport class InputValidator {\n  private rules: Map<string, ValidationRule[]> = new Map();\n\n  addRule(fieldName: string, rule: ValidationRule): this {\n    const existing = this.rules.get(fieldName) ?? [];\n    existing.push(rule);\n    this.rules.set(fieldName, existing);\n    return this;\n  }\n\n  addEmailRule(fieldName: string, message?: string): this {\n    return this.addRule(fieldName, {\n      name: 'email',\n      validate: validateEmail,\n      message: message ?? 'Invalid email address',\n    });\n  }\n\n  addPhoneRule(fieldName: string, message?: string): this {\n    return this.addRule(fieldName, {\n      name: 'phone',\n      validate: validatePhone,\n      message: message ?? 'Invalid phone number',\n    });\n  }\n\n  addSlugRule(fieldName: string, message?: string): this {\n    return this.addRule(fieldName, {\n      name: 'slug',\n      validate: validateSlug,\n      message: message ?? 'Invalid slug format',\n    });\n  }\n\n  validate(fieldName: string, value: string): ValidationResult {\n    const rules = this.rules.get(fieldName);\n    if (!rules) {\n      return { isValid: true, errors: [] };\n    }\n    return validateField(value, rules);\n  }\n\n  validateAll(data: Record<string, string>): Map<string, ValidationResult> {\n    const results = new Map<string, ValidationResult>();\n\n    for (const [fieldName, value] of Object.entries(data)) {\n      results.set(fieldName, this.validate(fieldName, value));\n    }\n\n    return results;\n  }\n}\n\nexport const defaultValidator = new InputValidator();\n",
          "patchWithLinesStr": "## file: 'packages/validation/src/validators/InputValidator.ts'\n\n@@ -0,0 +1,126 @@\n__new hunk__\n1 +export interface ValidationResult {\n2 +  isValid: boolean;\n3 +  errors: string[];\n4 +}\n5 +\n6 +export interface ValidationRule {\n7 +  name: string;\n8 +  validate: (value: string) => boolean;\n9 +  message: string;\n10 +}\n11 +\n12 +const PATTERNS = {\n13 +  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/g,\n14 +  phone: /^\\+?[1-9]\\d{1,14}$/g,\n15 +  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/g,\n16 +  username: /^[a-zA-Z][a-zA-Z0-9_]{2,29}$/g,\n17 +  alphanumeric: /^[a-zA-Z0-9]+$/g,\n18 +  numeric: /^\\d+$/g,\n19 +  url: /^https?:\\/\\/[^\\s/$.?#].[^\\s]*$/gi,\n20 +};\n21 +\n22 +export function validateEmail(email: string): boolean {\n23 +  return PATTERNS.email.test(email);\n24 +}\n25 +\n26 +export function validatePhone(phone: string): boolean {\n27 +  return PATTERNS.phone.test(phone);\n28 +}\n29 +\n30 +export function validateSlug(slug: string): boolean {\n31 +  return PATTERNS.slug.test(slug);\n32 +}\n33 +\n34 +export function validateUsername(username: string): boolean {\n35 +  return PATTERNS.username.test(username);\n36 +}\n37 +\n38 +export function validateUrl(url: string): boolean {\n39 +  return PATTERNS.url.test(url);\n40 +}\n41 +\n42 +export function validateField(\n43 +  value: string,\n44 +  rules: ValidationRule[]\n45 +): ValidationResult {\n46 +  const errors: string[] = [];\n47 +\n48 +  for (const rule of rules) {\n49 +    if (!rule.validate(value)) {\n50 +      errors.push(rule.message);\n51 +    }\n52 +  }\n53 +\n54 +  return {\n55 +    isValid: errors.length === 0,\n56 +    errors,\n57 +  };\n58 +}\n59 +\n60 +export function createPatternRule(\n61 +  name: string,\n62 +  pattern: RegExp,\n63 +  message: string\n64 +): ValidationRule {\n65 +  return {\n66 +    name,\n67 +    validate: (value: string) => pattern.test(value),\n68 +    message,\n69 +  };\n70 +}\n71 +\n72 +export class InputValidator {\n73 +  private rules: Map<string, ValidationRule[]> = new Map();\n74 +\n75 +  addRule(fieldName: string, rule: ValidationRule): this {\n76 +    const existing = this.rules.get(fieldName) ?? [];\n77 +    existing.push(rule);\n78 +    this.rules.set(fieldName, existing);\n79 +    return this;\n80 +  }\n81 +\n82 +  addEmailRule(fieldName: string, message?: string): this {\n83 +    return this.addRule(fieldName, {\n84 +      name: 'email',\n85 +      validate: validateEmail,\n86 +      message: message ?? 'Invalid email address',\n87 +    });\n88 +  }\n89 +\n90 +  addPhoneRule(fieldName: string, message?: string): this {\n91 +    return this.addRule(fieldName, {\n92 +      name: 'phone',\n93 +      validate: validatePhone,\n94 +      message: message ?? 'Invalid phone number',\n95 +    });\n96 +  }\n97 +\n98 +  addSlugRule(fieldName: string, message?: string): this {\n99 +    return this.addRule(fieldName, {\n100 +      name: 'slug',\n101 +      validate: validateSlug,\n102 +      message: message ?? 'Invalid slug format',\n103 +    });\n104 +  }\n105 +\n106 +  validate(fieldName: string, value: string): ValidationResult {\n107 +    const rules = this.rules.get(fieldName);\n108 +    if (!rules) {\n109 +      return { isValid: true, errors: [] };\n110 +    }\n111 +    return validateField(value, rules);\n112 +  }\n113 +\n114 +  validateAll(data: Record<string, string>): Map<string, ValidationResult> {\n115 +    const results = new Map<string, ValidationResult>();\n116 +\n117 +    for (const [fieldName, value] of Object.entries(data)) {\n118 +      results.set(fieldName, this.validate(fieldName, value));\n119 +    }\n120 +\n121 +    return results;\n122 +  }\n123 +}\n124 +\n125 +export const defaultValidator = new InputValidator();\n126 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/validation/src/validators/InputValidator.ts\",\"relevantLinesStart\":13,\"relevantLinesEnd\":20}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"const PATTERNS = {\\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$/g,\\n  phone: /^\\\\+?[1-9]\\\\d{1,14}$/g,\\n  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/g,\",\n    \"improvedCode\": \"const PATTERNS = {\\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$/,\\n  phone: /^\\\\+?[1-9]\\\\d{1,14}$/,\\n  slug: /^[a-z0-9]+(?:-[a-z0-9]+)*$/,\",\n    \"relevantFile\": \"packages/validation/src/validators/InputValidator.ts\",\n    \"relevantLinesEnd\": 20,\n    \"suggestionContent\": \"All regex patterns in PATTERNS object have the global flag (`/g`), which causes them to maintain state via `lastIndex`. When `test()` is called multiple times on the same regex, it alternates between true/false because `lastIndex` advances after each match. For example, `validateEmail('test@test.com')` will return true, then false, then true on consecutive calls. Remove the `g` flag from patterns used with `.test()` or create new RegExp instances for each validation.\",\n    \"oneSentenceSummary\": \"RegExp global flag causes validation to alternate true/false on repeated calls\",\n    \"relevantLinesStart\": 13\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 6: packages/data/src/sorting/ProductSorter.ts",
        "vars": {
          "fileContent": "export interface Product {\n  id: string;\n  name: string;\n  price: number;\n  category: string;\n  rating: number | null;\n  reviewCount: number;\n  inStock: boolean;\n  createdAt: Date;\n}\n\nexport type SortField = 'name' | 'price' | 'rating' | 'reviewCount' | 'createdAt';\nexport type SortDirection = 'asc' | 'desc';\n\ninterface SortConfig {\n  field: SortField;\n  direction: SortDirection;\n}\n\nfunction compareValues(a: unknown, b: unknown, direction: SortDirection): number {\n  const modifier = direction === 'asc' ? 1 : -1;\n\n  if (a === null || a === undefined) return 1;\n  if (b === null || b === undefined) return -1;\n\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a.localeCompare(b) * modifier;\n  }\n\n  if (typeof a === 'number' && typeof b === 'number') {\n    return (a - b) * modifier;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return (a.getTime() - b.getTime()) * modifier;\n  }\n\n  return 0;\n}\n\nexport function sortProducts(\n  products: Product[],\n  configs: SortConfig[]\n): Product[] {\n  if (configs.length === 0) return products;\n\n  return [...products].sort((a, b) => {\n    for (const config of configs) {\n      const aValue = a[config.field];\n      const bValue = b[config.field];\n      const result = compareValues(aValue, bValue, config.direction);\n      if (result !== 0) return result;\n    }\n    return 0;\n  });\n}\n\nexport function sortByPopularity(products: Product[]): Product[] {\n  return [...products].sort((a, b) => {\n    const aScore = (a.rating ?? 0) * Math.log(a.reviewCount + 1);\n    const bScore = (b.rating ?? 0) * Math.log(b.reviewCount + 1);\n    return bScore - aScore;\n  });\n}\n\nexport function sortByRelevance(\n  products: Product[],\n  searchTerm: string\n): Product[] {\n  const term = searchTerm.toLowerCase();\n\n  return [...products].sort((a, b) => {\n    const aNameMatch = a.name.toLowerCase().includes(term);\n    const bNameMatch = b.name.toLowerCase().includes(term);\n\n    if (aNameMatch && !bNameMatch) return -1;\n    if (!aNameMatch && bNameMatch) return 1;\n\n    const aExact = a.name.toLowerCase() === term;\n    const bExact = b.name.toLowerCase() === term;\n\n    if (aExact && !bExact) return -1;\n    if (!aExact && bExact) return 1;\n\n    return (b.rating ?? 0) - (a.rating ?? 0);\n  });\n}\n\nexport class ProductSorter {\n  private defaultConfigs: SortConfig[] = [];\n\n  setDefaults(configs: SortConfig[]): void {\n    this.defaultConfigs = configs;\n  }\n\n  sort(products: Product[], configs?: SortConfig[]): Product[] {\n    return sortProducts(products, configs ?? this.defaultConfigs);\n  }\n}\n",
          "patchWithLinesStr": "## file: 'packages/data/src/sorting/ProductSorter.ts'\n\n@@ -0,0 +1,100 @@\n__new hunk__\n1 +export interface Product {\n2 +  id: string;\n3 +  name: string;\n4 +  price: number;\n5 +  category: string;\n6 +  rating: number | null;\n7 +  reviewCount: number;\n8 +  inStock: boolean;\n9 +  createdAt: Date;\n10 +}\n11 +\n12 +export type SortField = 'name' | 'price' | 'rating' | 'reviewCount' | 'createdAt';\n13 +export type SortDirection = 'asc' | 'desc';\n14 +\n15 +interface SortConfig {\n16 +  field: SortField;\n17 +  direction: SortDirection;\n18 +}\n19 +\n20 +function compareValues(a: unknown, b: unknown, direction: SortDirection): number {\n21 +  const modifier = direction === 'asc' ? 1 : -1;\n22 +\n23 +  if (a === null || a === undefined) return 1;\n24 +  if (b === null || b === undefined) return -1;\n25 +\n26 +  if (typeof a === 'string' && typeof b === 'string') {\n27 +    return a.localeCompare(b) * modifier;\n28 +  }\n29 +\n30 +  if (typeof a === 'number' && typeof b === 'number') {\n31 +    return (a - b) * modifier;\n32 +  }\n33 +\n34 +  if (a instanceof Date && b instanceof Date) {\n35 +    return (a.getTime() - b.getTime()) * modifier;\n36 +  }\n37 +\n38 +  return 0;\n39 +}\n40 +\n41 +export function sortProducts(\n42 +  products: Product[],\n43 +  configs: SortConfig[]\n44 +): Product[] {\n45 +  if (configs.length === 0) return products;\n46 +\n47 +  return [...products].sort((a, b) => {\n48 +    for (const config of configs) {\n49 +      const aValue = a[config.field];\n50 +      const bValue = b[config.field];\n51 +      const result = compareValues(aValue, bValue, config.direction);\n52 +      if (result !== 0) return result;\n53 +    }\n54 +    return 0;\n55 +  });\n56 +}\n57 +\n58 +export function sortByPopularity(products: Product[]): Product[] {\n59 +  return [...products].sort((a, b) => {\n60 +    const aScore = (a.rating ?? 0) * Math.log(a.reviewCount + 1);\n61 +    const bScore = (b.rating ?? 0) * Math.log(b.reviewCount + 1);\n62 +    return bScore - aScore;\n63 +  });\n64 +}\n65 +\n66 +export function sortByRelevance(\n67 +  products: Product[],\n68 +  searchTerm: string\n69 +): Product[] {\n70 +  const term = searchTerm.toLowerCase();\n71 +\n72 +  return [...products].sort((a, b) => {\n73 +    const aNameMatch = a.name.toLowerCase().includes(term);\n74 +    const bNameMatch = b.name.toLowerCase().includes(term);\n75 +\n76 +    if (aNameMatch && !bNameMatch) return -1;\n77 +    if (!aNameMatch && bNameMatch) return 1;\n78 +\n79 +    const aExact = a.name.toLowerCase() === term;\n80 +    const bExact = b.name.toLowerCase() === term;\n81 +\n82 +    if (aExact && !bExact) return -1;\n83 +    if (!aExact && bExact) return 1;\n84 +\n85 +    return (b.rating ?? 0) - (a.rating ?? 0);\n86 +  });\n87 +}\n88 +\n89 +export class ProductSorter {\n90 +  private defaultConfigs: SortConfig[] = [];\n91 +\n92 +  setDefaults(configs: SortConfig[]): void {\n93 +    this.defaultConfigs = configs;\n94 +  }\n95 +\n96 +  sort(products: Product[], configs?: SortConfig[]): Product[] {\n97 +    return sortProducts(products, configs ?? this.defaultConfigs);\n98 +  }\n99 +}\n100 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/data/src/sorting/ProductSorter.ts\",\"relevantLinesStart\":21,\"relevantLinesEnd\":23}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (a === null || a === undefined) return 1;\\n  if (b === null || b === undefined) return -1;\",\n    \"improvedCode\": \"if (a === null || a === undefined) {\\n    return b === null || b === undefined ? 0 : 1;\\n  }\\n  if (b === null || b === undefined) return -1;\",\n    \"relevantFile\": \"packages/data/src/sorting/ProductSorter.ts\",\n    \"relevantLinesEnd\": 23,\n    \"suggestionContent\": \"The `compareValues` function returns inconsistent values when comparing null/undefined values, violating the sort comparator contract. When `a` is null it returns 1, and when `b` is null it returns -1. But when both are null, neither condition triggers and it falls through to return 0. However, if you have [null, 1, null], comparing positions 0-1 says null>1, but comparing 1-2 says 1>null, creating an inconsistent ordering that can cause Array.sort to produce unpredictable results or infinite loops in some JS engines.\",\n    \"oneSentenceSummary\": \"Sort comparator violates transitivity when handling null values causing unstable sort\",\n    \"relevantLinesStart\": 21\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 7: packages/network/src/utils/withTimeout.ts",
        "vars": {
          "fileContent": "import { NetworkError } from '../errors/NetworkError';\n\ninterface TimeoutOptions {\n  timeoutMs: number;\n  errorMessage?: string;\n  onTimeout?: () => void;\n}\n\ntype Awaitable<T> = T | Promise<T>;\n\nexport class TimeoutError extends Error {\n  readonly code = 'TIMEOUT';\n\n  constructor(message: string, public readonly timeoutMs: number) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n\nfunction createTimeoutPromise(ms: number, message: string): Promise<never> {\n  return new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new TimeoutError(message, ms));\n    }, ms);\n  });\n}\n\nexport async function withTimeout<T>(\n  operation: Awaitable<T>,\n  options: TimeoutOptions\n): Promise<T> {\n  const { timeoutMs, errorMessage, onTimeout } = options;\n\n  const timeoutPromise = createTimeoutPromise(\n    timeoutMs,\n    errorMessage ?? `Operation timed out after ${timeoutMs}ms`\n  );\n\n  try {\n    const result = await Promise.race([\n      Promise.resolve(operation),\n      timeoutPromise,\n    ]);\n    return result;\n  } catch (error) {\n    if (error instanceof TimeoutError) {\n      onTimeout?.();\n    }\n    throw error;\n  }\n}\n\nexport async function withRetryAndTimeout<T>(\n  operation: () => Promise<T>,\n  options: {\n    timeoutMs: number;\n    maxRetries: number;\n    retryDelayMs: number;\n  }\n): Promise<T> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {\n    try {\n      return await withTimeout(operation(), {\n        timeoutMs: options.timeoutMs,\n      });\n    } catch (error) {\n      lastError = error as Error;\n      if (attempt < options.maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, options.retryDelayMs));\n      }\n    }\n  }\n\n  throw lastError ?? new NetworkError('All retries exhausted');\n}\n\nexport function isTimeoutError(error: unknown): error is TimeoutError {\n  return error instanceof TimeoutError;\n}\n",
          "patchWithLinesStr": "## file: 'packages/network/src/utils/withTimeout.ts'\n\n@@ -0,0 +1,82 @@\n__new hunk__\n1 +import { NetworkError } from '../errors/NetworkError';\n2 +\n3 +interface TimeoutOptions {\n4 +  timeoutMs: number;\n5 +  errorMessage?: string;\n6 +  onTimeout?: () => void;\n7 +}\n8 +\n9 +type Awaitable<T> = T | Promise<T>;\n10 +\n11 +export class TimeoutError extends Error {\n12 +  readonly code = 'TIMEOUT';\n13 +\n14 +  constructor(message: string, public readonly timeoutMs: number) {\n15 +    super(message);\n16 +    this.name = 'TimeoutError';\n17 +  }\n18 +}\n19 +\n20 +function createTimeoutPromise(ms: number, message: string): Promise<never> {\n21 +  return new Promise((_, reject) => {\n22 +    setTimeout(() => {\n23 +      reject(new TimeoutError(message, ms));\n24 +    }, ms);\n25 +  });\n26 +}\n27 +\n28 +export async function withTimeout<T>(\n29 +  operation: Awaitable<T>,\n30 +  options: TimeoutOptions\n31 +): Promise<T> {\n32 +  const { timeoutMs, errorMessage, onTimeout } = options;\n33 +\n34 +  const timeoutPromise = createTimeoutPromise(\n35 +    timeoutMs,\n36 +    errorMessage ?? `Operation timed out after ${timeoutMs}ms`\n37 +  );\n38 +\n39 +  try {\n40 +    const result = await Promise.race([\n41 +      Promise.resolve(operation),\n42 +      timeoutPromise,\n43 +    ]);\n44 +    return result;\n45 +  } catch (error) {\n46 +    if (error instanceof TimeoutError) {\n47 +      onTimeout?.();\n48 +    }\n49 +    throw error;\n50 +  }\n51 +}\n52 +\n53 +export async function withRetryAndTimeout<T>(\n54 +  operation: () => Promise<T>,\n55 +  options: {\n56 +    timeoutMs: number;\n57 +    maxRetries: number;\n58 +    retryDelayMs: number;\n59 +  }\n60 +): Promise<T> {\n61 +  let lastError: Error | undefined;\n62 +\n63 +  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {\n64 +    try {\n65 +      return await withTimeout(operation(), {\n66 +        timeoutMs: options.timeoutMs,\n67 +      });\n68 +    } catch (error) {\n69 +      lastError = error as Error;\n70 +      if (attempt < options.maxRetries) {\n71 +        await new Promise(resolve => setTimeout(resolve, options.retryDelayMs));\n72 +      }\n73 +    }\n74 +  }\n75 +\n76 +  throw lastError ?? new NetworkError('All retries exhausted');\n77 +}\n78 +\n79 +export function isTimeoutError(error: unknown): error is TimeoutError {\n80 +  return error instanceof TimeoutError;\n81 +}\n82 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/network/src/utils/withTimeout.ts\",\"relevantLinesStart\":19,\"relevantLinesEnd\":25}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"function createTimeoutPromise(ms: number, message: string): Promise<never> {\\n  return new Promise((_, reject) => {\\n    setTimeout(() => {\\n      reject(new TimeoutError(message, ms));\\n    }, ms);\\n  });\\n}\",\n    \"improvedCode\": \"function createTimeoutPromise(ms: number, message: string, signal: AbortSignal): Promise<never> {\\n  return new Promise((_, reject) => {\\n    const timeoutId = setTimeout(() => {\\n      reject(new TimeoutError(message, ms));\\n    }, ms);\\n    signal.addEventListener('abort', () => clearTimeout(timeoutId));\\n  });\\n}\",\n    \"relevantFile\": \"packages/network/src/utils/withTimeout.ts\",\n    \"relevantLinesEnd\": 25,\n    \"suggestionContent\": \"The timeout promise created by `createTimeoutPromise` is never cancelled when the operation succeeds. In Promise.race, losing promises continue to exist and their timers keep running. If `withTimeout` is called frequently (e.g., for every API request), these orphaned setTimeout callbacks accumulate in memory until they fire, causing a memory leak. Use AbortController or manually clear the timeout when the operation completes.\",\n    \"oneSentenceSummary\": \"Promise.race memory leak - timeout timer is never cancelled when operation succeeds\",\n    \"relevantLinesStart\": 19\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 8: packages/sync/src/services/DataSyncService.ts",
        "vars": {
          "fileContent": "import { EventEmitter } from 'events';\n\nexport interface SyncItem {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  entity: string;\n  data: Record<string, unknown>;\n  timestamp: number;\n}\n\nexport interface SyncResult {\n  success: boolean;\n  itemId: string;\n  error?: Error;\n}\n\nexport interface SyncConfig {\n  batchSize: number;\n  retryAttempts: number;\n  retryDelayMs: number;\n  onProgress?: (completed: number, total: number) => void;\n}\n\nconst DEFAULT_CONFIG: SyncConfig = {\n  batchSize: 50,\n  retryAttempts: 3,\n  retryDelayMs: 1000,\n};\n\nexport class DataSyncService extends EventEmitter {\n  private config: SyncConfig;\n  private isRunning = false;\n  private queue: SyncItem[] = [];\n\n  constructor(config: Partial<SyncConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async syncItem(item: SyncItem): Promise<SyncResult> {\n    // Simulated sync operation\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    if (Math.random() < 0.1) {\n      throw new Error(`Failed to sync item ${item.id}`);\n    }\n\n    return { success: true, itemId: item.id };\n  }\n\n  async syncBatch(items: SyncItem[]): Promise<SyncResult[]> {\n    const results: SyncResult[] = [];\n\n    await items.forEach(async (item) => {\n      try {\n        const result = await this.syncItem(item);\n        results.push(result);\n        this.emit('itemSynced', result);\n      } catch (error) {\n        results.push({\n          success: false,\n          itemId: item.id,\n          error: error as Error,\n        });\n        this.emit('itemFailed', { itemId: item.id, error });\n      }\n    });\n\n    return results;\n  }\n\n  async syncAll(items: SyncItem[]): Promise<SyncResult[]> {\n    if (this.isRunning) {\n      throw new Error('Sync already in progress');\n    }\n\n    this.isRunning = true;\n    this.emit('syncStarted', { total: items.length });\n\n    const allResults: SyncResult[] = [];\n    const batches: SyncItem[][] = [];\n\n    for (let i = 0; i < items.length; i += this.config.batchSize) {\n      batches.push(items.slice(i, i + this.config.batchSize));\n    }\n\n    for (const batch of batches) {\n      const batchResults = await this.syncBatch(batch);\n      allResults.push(...batchResults);\n\n      this.config.onProgress?.(\n        allResults.length,\n        items.length\n      );\n    }\n\n    this.isRunning = false;\n    this.emit('syncCompleted', { results: allResults });\n\n    return allResults;\n  }\n\n  addToQueue(item: SyncItem): void {\n    this.queue.push(item);\n  }\n\n  async processQueue(): Promise<SyncResult[]> {\n    const items = [...this.queue];\n    this.queue = [];\n    return this.syncAll(items);\n  }\n\n  getQueueLength(): number {\n    return this.queue.length;\n  }\n}\n\nexport async function createSyncService(\n  config?: Partial<SyncConfig>\n): Promise<DataSyncService> {\n  return new DataSyncService(config);\n}\n",
          "patchWithLinesStr": "## file: 'packages/sync/src/services/DataSyncService.ts'\n\n@@ -0,0 +1,123 @@\n__new hunk__\n1 +import { EventEmitter } from 'events';\n2 +\n3 +export interface SyncItem {\n4 +  id: string;\n5 +  type: 'create' | 'update' | 'delete';\n6 +  entity: string;\n7 +  data: Record<string, unknown>;\n8 +  timestamp: number;\n9 +}\n10 +\n11 +export interface SyncResult {\n12 +  success: boolean;\n13 +  itemId: string;\n14 +  error?: Error;\n15 +}\n16 +\n17 +export interface SyncConfig {\n18 +  batchSize: number;\n19 +  retryAttempts: number;\n20 +  retryDelayMs: number;\n21 +  onProgress?: (completed: number, total: number) => void;\n22 +}\n23 +\n24 +const DEFAULT_CONFIG: SyncConfig = {\n25 +  batchSize: 50,\n26 +  retryAttempts: 3,\n27 +  retryDelayMs: 1000,\n28 +};\n29 +\n30 +export class DataSyncService extends EventEmitter {\n31 +  private config: SyncConfig;\n32 +  private isRunning = false;\n33 +  private queue: SyncItem[] = [];\n34 +\n35 +  constructor(config: Partial<SyncConfig> = {}) {\n36 +    super();\n37 +    this.config = { ...DEFAULT_CONFIG, ...config };\n38 +  }\n39 +\n40 +  async syncItem(item: SyncItem): Promise<SyncResult> {\n41 +    // Simulated sync operation\n42 +    await new Promise(resolve => setTimeout(resolve, 100));\n43 +\n44 +    if (Math.random() < 0.1) {\n45 +      throw new Error(`Failed to sync item ${item.id}`);\n46 +    }\n47 +\n48 +    return { success: true, itemId: item.id };\n49 +  }\n50 +\n51 +  async syncBatch(items: SyncItem[]): Promise<SyncResult[]> {\n52 +    const results: SyncResult[] = [];\n53 +\n54 +    await items.forEach(async (item) => {\n55 +      try {\n56 +        const result = await this.syncItem(item);\n57 +        results.push(result);\n58 +        this.emit('itemSynced', result);\n59 +      } catch (error) {\n60 +        results.push({\n61 +          success: false,\n62 +          itemId: item.id,\n63 +          error: error as Error,\n64 +        });\n65 +        this.emit('itemFailed', { itemId: item.id, error });\n66 +      }\n67 +    });\n68 +\n69 +    return results;\n70 +  }\n71 +\n72 +  async syncAll(items: SyncItem[]): Promise<SyncResult[]> {\n73 +    if (this.isRunning) {\n74 +      throw new Error('Sync already in progress');\n75 +    }\n76 +\n77 +    this.isRunning = true;\n78 +    this.emit('syncStarted', { total: items.length });\n79 +\n80 +    const allResults: SyncResult[] = [];\n81 +    const batches: SyncItem[][] = [];\n82 +\n83 +    for (let i = 0; i < items.length; i += this.config.batchSize) {\n84 +      batches.push(items.slice(i, i + this.config.batchSize));\n85 +    }\n86 +\n87 +    for (const batch of batches) {\n88 +      const batchResults = await this.syncBatch(batch);\n89 +      allResults.push(...batchResults);\n90 +\n91 +      this.config.onProgress?.(\n92 +        allResults.length,\n93 +        items.length\n94 +      );\n95 +    }\n96 +\n97 +    this.isRunning = false;\n98 +    this.emit('syncCompleted', { results: allResults });\n99 +\n100 +    return allResults;\n101 +  }\n102 +\n103 +  addToQueue(item: SyncItem): void {\n104 +    this.queue.push(item);\n105 +  }\n106 +\n107 +  async processQueue(): Promise<SyncResult[]> {\n108 +    const items = [...this.queue];\n109 +    this.queue = [];\n110 +    return this.syncAll(items);\n111 +  }\n112 +\n113 +  getQueueLength(): number {\n114 +    return this.queue.length;\n115 +  }\n116 +}\n117 +\n118 +export async function createSyncService(\n119 +  config?: Partial<SyncConfig>\n120 +): Promise<DataSyncService> {\n121 +  return new DataSyncService(config);\n122 +}\n123 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/sync/src/services/DataSyncService.ts\",\"relevantLinesStart\":50,\"relevantLinesEnd\":63}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"await items.forEach(async (item) => {\\n      try {\\n        const result = await this.syncItem(item);\\n        results.push(result);\",\n    \"improvedCode\": \"await Promise.all(items.map(async (item) => {\\n      try {\\n        const result = await this.syncItem(item);\\n        results.push(result);\",\n    \"relevantFile\": \"packages/sync/src/services/DataSyncService.ts\",\n    \"relevantLinesEnd\": 63,\n    \"suggestionContent\": \"The `syncBatch` method uses `await items.forEach(async ...)` which does not actually wait for the async callbacks to complete. `Array.forEach` ignores the return value of callbacks (including Promises), so this returns an empty `results` array immediately while the sync operations continue in the background. Use `Promise.all` with `map`, or a for...of loop to properly await each operation.\",\n    \"oneSentenceSummary\": \"await forEach does not wait for async callbacks - returns empty array\",\n    \"relevantLinesStart\": 50\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 9: packages/api/src/client/ApiClient.ts",
        "vars": {
          "fileContent": "import { EventEmitter } from 'events';\n\nexport interface RequestConfig {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  url: string;\n  data?: unknown;\n  headers?: Record<string, string>;\n  timeout?: number;\n  retries?: number;\n}\n\nexport interface ApiResponse<T = unknown> {\n  data: T;\n  status: number;\n  headers: Record<string, string>;\n}\n\nexport interface ApiClientConfig {\n  baseUrl: string;\n  defaultTimeout: number;\n  defaultRetries: number;\n  authToken?: string;\n}\n\ntype RequestInterceptor = (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\ntype ResponseInterceptor = <T>(response: ApiResponse<T>) => ApiResponse<T> | Promise<ApiResponse<T>>;\n\nconst RETRY_STATUS_CODES = [408, 429, 500, 502, 503, 504];\n\nexport class ApiClient extends EventEmitter {\n  private config: ApiClientConfig;\n  private requestInterceptors: RequestInterceptor[] = [];\n  private responseInterceptors: ResponseInterceptor[] = [];\n  private pendingRequests: Map<string, AbortController> = new Map();\n  private requestCount = 0;\n  private isRefreshingToken = false;\n  private tokenRefreshPromise: Promise<string> | null = null;\n\n  constructor(config: ApiClientConfig) {\n    super();\n    this.config = config;\n  }\n\n  addRequestInterceptor(interceptor: RequestInterceptor): () => void {\n    this.requestInterceptors.push(interceptor);\n    return () => {\n      const index = this.requestInterceptors.indexOf(interceptor);\n      if (index > -1) this.requestInterceptors.splice(index, 1);\n    };\n  }\n\n  addResponseInterceptor(interceptor: ResponseInterceptor): () => void {\n    this.responseInterceptors.push(interceptor);\n    return () => {\n      const index = this.responseInterceptors.indexOf(interceptor);\n      if (index > -1) this.responseInterceptors.splice(index, 1);\n    };\n  }\n\n  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n    let currentConfig = config;\n    for (const interceptor of this.requestInterceptors) {\n      currentConfig = await interceptor(currentConfig);\n    }\n    return currentConfig;\n  }\n\n  private async applyResponseInterceptors<T>(response: ApiResponse<T>): Promise<ApiResponse<T>> {\n    let currentResponse = response;\n    for (const interceptor of this.responseInterceptors) {\n      currentResponse = await interceptor(currentResponse);\n    }\n    return currentResponse;\n  }\n\n  private generateRequestId(): string {\n    return `req_${++this.requestCount}_${Date.now()}`;\n  }\n\n  async refreshAuthToken(): Promise<string> {\n    if (this.isRefreshingToken) {\n      return this.tokenRefreshPromise!;\n    }\n\n    this.isRefreshingToken = true;\n    this.tokenRefreshPromise = this.doRefreshToken();\n\n    const newToken = await this.tokenRefreshPromise;\n    this.config.authToken = newToken;\n    this.isRefreshingToken = false;\n\n    return newToken;\n  }\n\n  private async doRefreshToken(): Promise<string> {\n    const response = await fetch(`${this.config.baseUrl}/auth/refresh`, {\n      method: 'POST',\n      credentials: 'include',\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to refresh token');\n    }\n\n    const data = await response.json();\n    return data.token;\n  }\n\n  async request<T>(config: RequestConfig): Promise<ApiResponse<T>> {\n    const requestId = this.generateRequestId();\n    const abortController = new AbortController();\n    this.pendingRequests.set(requestId, abortController);\n\n    const finalConfig = await this.applyRequestInterceptors({\n      ...config,\n      timeout: config.timeout ?? this.config.defaultTimeout,\n      retries: config.retries ?? this.config.defaultRetries,\n    });\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      ...finalConfig.headers,\n    };\n\n    if (this.config.authToken) {\n      headers['Authorization'] = `Bearer ${this.config.authToken}`;\n    }\n\n    let lastError: Error | null = null;\n    const maxRetries = finalConfig.retries ?? 0;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const timeoutId = setTimeout(() => {\n          abortController.abort();\n        }, finalConfig.timeout);\n\n        const response = await fetch(`${this.config.baseUrl}${finalConfig.url}`, {\n          method: finalConfig.method,\n          headers,\n          body: finalConfig.data ? JSON.stringify(finalConfig.data) : undefined,\n          signal: abortController.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (response.status === 401 && this.config.authToken) {\n          await this.refreshAuthToken();\n          headers['Authorization'] = `Bearer ${this.config.authToken}`;\n          continue;\n        }\n\n        if (!response.ok) {\n          if (RETRY_STATUS_CODES.includes(response.status) && attempt < maxRetries) {\n            await this.delay(Math.pow(2, attempt) * 1000);\n            continue;\n          }\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        const apiResponse: ApiResponse<T> = {\n          data,\n          status: response.status,\n          headers: Object.fromEntries(response.headers.entries()),\n        };\n\n        this.emit('requestComplete', { requestId, response: apiResponse });\n        return this.applyResponseInterceptors(apiResponse);\n\n      } catch (error) {\n        lastError = error as Error;\n        if (attempt < maxRetries) {\n          await this.delay(Math.pow(2, attempt) * 1000);\n        }\n      }\n    }\n\n    this.emit('requestFailed', { requestId, error: lastError });\n    throw lastError;\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  cancelRequest(requestId: string): void {\n    const controller = this.pendingRequests.get(requestId);\n    if (controller) {\n      controller.abort();\n      this.pendingRequests.delete(requestId);\n    }\n  }\n\n  cancelAllRequests(): void {\n    for (const [id, controller] of this.pendingRequests) {\n      controller.abort();\n    }\n    this.pendingRequests.clear();\n  }\n\n  async get<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'GET', url, ...config });\n  }\n\n  async post<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'POST', url, data, ...config });\n  }\n\n  async put<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'PUT', url, data, ...config });\n  }\n\n  async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n    return this.request<T>({ method: 'DELETE', url, ...config });\n  }\n}\n\nexport function createApiClient(config: ApiClientConfig): ApiClient {\n  return new ApiClient(config);\n}\n",
          "patchWithLinesStr": "## file: 'packages/api/src/client/ApiClient.ts'\n\n@@ -0,0 +1,222 @@\n__new hunk__\n1 +import { EventEmitter } from 'events';\n2 +\n3 +export interface RequestConfig {\n4 +  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n5 +  url: string;\n6 +  data?: unknown;\n7 +  headers?: Record<string, string>;\n8 +  timeout?: number;\n9 +  retries?: number;\n10 +}\n11 +\n12 +export interface ApiResponse<T = unknown> {\n13 +  data: T;\n14 +  status: number;\n15 +  headers: Record<string, string>;\n16 +}\n17 +\n18 +export interface ApiClientConfig {\n19 +  baseUrl: string;\n20 +  defaultTimeout: number;\n21 +  defaultRetries: number;\n22 +  authToken?: string;\n23 +}\n24 +\n25 +type RequestInterceptor = (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\n26 +type ResponseInterceptor = <T>(response: ApiResponse<T>) => ApiResponse<T> | Promise<ApiResponse<T>>;\n27 +\n28 +const RETRY_STATUS_CODES = [408, 429, 500, 502, 503, 504];\n29 +\n30 +export class ApiClient extends EventEmitter {\n31 +  private config: ApiClientConfig;\n32 +  private requestInterceptors: RequestInterceptor[] = [];\n33 +  private responseInterceptors: ResponseInterceptor[] = [];\n34 +  private pendingRequests: Map<string, AbortController> = new Map();\n35 +  private requestCount = 0;\n36 +  private isRefreshingToken = false;\n37 +  private tokenRefreshPromise: Promise<string> | null = null;\n38 +\n39 +  constructor(config: ApiClientConfig) {\n40 +    super();\n41 +    this.config = config;\n42 +  }\n43 +\n44 +  addRequestInterceptor(interceptor: RequestInterceptor): () => void {\n45 +    this.requestInterceptors.push(interceptor);\n46 +    return () => {\n47 +      const index = this.requestInterceptors.indexOf(interceptor);\n48 +      if (index > -1) this.requestInterceptors.splice(index, 1);\n49 +    };\n50 +  }\n51 +\n52 +  addResponseInterceptor(interceptor: ResponseInterceptor): () => void {\n53 +    this.responseInterceptors.push(interceptor);\n54 +    return () => {\n55 +      const index = this.responseInterceptors.indexOf(interceptor);\n56 +      if (index > -1) this.responseInterceptors.splice(index, 1);\n57 +    };\n58 +  }\n59 +\n60 +  private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {\n61 +    let currentConfig = config;\n62 +    for (const interceptor of this.requestInterceptors) {\n63 +      currentConfig = await interceptor(currentConfig);\n64 +    }\n65 +    return currentConfig;\n66 +  }\n67 +\n68 +  private async applyResponseInterceptors<T>(response: ApiResponse<T>): Promise<ApiResponse<T>> {\n69 +    let currentResponse = response;\n70 +    for (const interceptor of this.responseInterceptors) {\n71 +      currentResponse = await interceptor(currentResponse);\n72 +    }\n73 +    return currentResponse;\n74 +  }\n75 +\n76 +  private generateRequestId(): string {\n77 +    return `req_${++this.requestCount}_${Date.now()}`;\n78 +  }\n79 +\n80 +  async refreshAuthToken(): Promise<string> {\n81 +    if (this.isRefreshingToken) {\n82 +      return this.tokenRefreshPromise!;\n83 +    }\n84 +\n85 +    this.isRefreshingToken = true;\n86 +    this.tokenRefreshPromise = this.doRefreshToken();\n87 +\n88 +    const newToken = await this.tokenRefreshPromise;\n89 +    this.config.authToken = newToken;\n90 +    this.isRefreshingToken = false;\n91 +\n92 +    return newToken;\n93 +  }\n94 +\n95 +  private async doRefreshToken(): Promise<string> {\n96 +    const response = await fetch(`${this.config.baseUrl}/auth/refresh`, {\n97 +      method: 'POST',\n98 +      credentials: 'include',\n99 +    });\n100 +\n101 +    if (!response.ok) {\n102 +      throw new Error('Failed to refresh token');\n103 +    }\n104 +\n105 +    const data = await response.json();\n106 +    return data.token;\n107 +  }\n108 +\n109 +  async request<T>(config: RequestConfig): Promise<ApiResponse<T>> {\n110 +    const requestId = this.generateRequestId();\n111 +    const abortController = new AbortController();\n112 +    this.pendingRequests.set(requestId, abortController);\n113 +\n114 +    const finalConfig = await this.applyRequestInterceptors({\n115 +      ...config,\n116 +      timeout: config.timeout ?? this.config.defaultTimeout,\n117 +      retries: config.retries ?? this.config.defaultRetries,\n118 +    });\n119 +\n120 +    const headers: Record<string, string> = {\n121 +      'Content-Type': 'application/json',\n122 +      ...finalConfig.headers,\n123 +    };\n124 +\n125 +    if (this.config.authToken) {\n126 +      headers['Authorization'] = `Bearer ${this.config.authToken}`;\n127 +    }\n128 +\n129 +    let lastError: Error | null = null;\n130 +    const maxRetries = finalConfig.retries ?? 0;\n131 +\n132 +    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n133 +      try {\n134 +        const timeoutId = setTimeout(() => {\n135 +          abortController.abort();\n136 +        }, finalConfig.timeout);\n137 +\n138 +        const response = await fetch(`${this.config.baseUrl}${finalConfig.url}`, {\n139 +          method: finalConfig.method,\n140 +          headers,\n141 +          body: finalConfig.data ? JSON.stringify(finalConfig.data) : undefined,\n142 +          signal: abortController.signal,\n143 +        });\n144 +\n145 +        clearTimeout(timeoutId);\n146 +\n147 +        if (response.status === 401 && this.config.authToken) {\n148 +          await this.refreshAuthToken();\n149 +          headers['Authorization'] = `Bearer ${this.config.authToken}`;\n150 +          continue;\n151 +        }\n152 +\n153 +        if (!response.ok) {\n154 +          if (RETRY_STATUS_CODES.includes(response.status) && attempt < maxRetries) {\n155 +            await this.delay(Math.pow(2, attempt) * 1000);\n156 +            continue;\n157 +          }\n158 +          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n159 +        }\n160 +\n161 +        const data = await response.json();\n162 +        const apiResponse: ApiResponse<T> = {\n163 +          data,\n164 +          status: response.status,\n165 +          headers: Object.fromEntries(response.headers.entries()),\n166 +        };\n167 +\n168 +        this.emit('requestComplete', { requestId, response: apiResponse });\n169 +        return this.applyResponseInterceptors(apiResponse);\n170 +\n171 +      } catch (error) {\n172 +        lastError = error as Error;\n173 +        if (attempt < maxRetries) {\n174 +          await this.delay(Math.pow(2, attempt) * 1000);\n175 +        }\n176 +      }\n177 +    }\n178 +\n179 +    this.emit('requestFailed', { requestId, error: lastError });\n180 +    throw lastError;\n181 +  }\n182 +\n183 +  private delay(ms: number): Promise<void> {\n184 +    return new Promise(resolve => setTimeout(resolve, ms));\n185 +  }\n186 +\n187 +  cancelRequest(requestId: string): void {\n188 +    const controller = this.pendingRequests.get(requestId);\n189 +    if (controller) {\n190 +      controller.abort();\n191 +      this.pendingRequests.delete(requestId);\n192 +    }\n193 +  }\n194 +\n195 +  cancelAllRequests(): void {\n196 +    for (const [id, controller] of this.pendingRequests) {\n197 +      controller.abort();\n198 +    }\n199 +    this.pendingRequests.clear();\n200 +  }\n201 +\n202 +  async get<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n203 +    return this.request<T>({ method: 'GET', url, ...config });\n204 +  }\n205 +\n206 +  async post<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n207 +    return this.request<T>({ method: 'POST', url, data, ...config });\n208 +  }\n209 +\n210 +  async put<T>(url: string, data?: unknown, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n211 +    return this.request<T>({ method: 'PUT', url, data, ...config });\n212 +  }\n213 +\n214 +  async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<ApiResponse<T>> {\n215 +    return this.request<T>({ method: 'DELETE', url, ...config });\n216 +  }\n217 +}\n218 +\n219 +export function createApiClient(config: ApiClientConfig): ApiClient {\n220 +  return new ApiClient(config);\n221 +}\n222 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/api/src/client/ApiClient.ts\",\"relevantLinesStart\":78,\"relevantLinesEnd\":90},{\"relevantFile\":\"packages/api/src/client/ApiClient.ts\",\"relevantLinesStart\":156,\"relevantLinesEnd\":157},{\"relevantFile\":\"packages/api/src/client/ApiClient.ts\",\"relevantLinesStart\":140,\"relevantLinesEnd\":145}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"async refreshAuthToken(): Promise<string> {\\n    if (this.isRefreshingToken) {\\n      return this.tokenRefreshPromise!;\\n    }\\n\\n    this.isRefreshingToken = true;\\n    this.tokenRefreshPromise = this.doRefreshToken();\",\n    \"improvedCode\": \"async refreshAuthToken(): Promise<string> {\\n    if (this.tokenRefreshPromise) {\\n      return this.tokenRefreshPromise;\\n    }\\n\\n    this.tokenRefreshPromise = this.doRefreshToken().finally(() => {\\n      this.tokenRefreshPromise = null;\\n    });\",\n    \"relevantFile\": \"packages/api/src/client/ApiClient.ts\",\n    \"relevantLinesEnd\": 90,\n    \"suggestionContent\": \"The `refreshAuthToken` method has a race condition. After checking `this.isRefreshingToken` and before setting it to `true`, another call could pass the check. Also, after the token refresh completes, `this.isRefreshingToken` is set to `false` but `this.tokenRefreshPromise` is not cleared, so subsequent checks of `this.tokenRefreshPromise!` could return a stale resolved promise.\",\n    \"oneSentenceSummary\": \"Race condition in token refresh - multiple concurrent refreshes possible\",\n    \"relevantLinesStart\": 78\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"this.emit('requestComplete', { requestId, response: apiResponse });\\n        return this.applyResponseInterceptors(apiResponse);\",\n    \"improvedCode\": \"this.pendingRequests.delete(requestId);\\n        this.emit('requestComplete', { requestId, response: apiResponse });\\n        return this.applyResponseInterceptors(apiResponse);\",\n    \"relevantFile\": \"packages/api/src/client/ApiClient.ts\",\n    \"relevantLinesEnd\": 157,\n    \"suggestionContent\": \"The `pendingRequests` Map stores AbortControllers but never removes them after a request completes successfully. Only `cancelRequest` removes entries. Over time, this causes a memory leak as the Map grows unboundedly with completed request entries.\",\n    \"oneSentenceSummary\": \"Memory leak - pendingRequests Map never cleaned up after successful requests\",\n    \"relevantLinesStart\": 156\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (response.status === 401 && this.config.authToken) {\\n          await this.refreshAuthToken();\\n          headers['Authorization'] = `Bearer ${this.config.authToken}`;\\n          continue;\\n        }\",\n    \"improvedCode\": \"if (response.status === 401 && this.config.authToken) {\\n          await this.refreshAuthToken();\\n          headers['Authorization'] = `Bearer ${this.config.authToken}`;\\n          attempt--; // Don't count 401 retry against retry limit\\n          continue;\\n        }\",\n    \"relevantFile\": \"packages/api/src/client/ApiClient.ts\",\n    \"relevantLinesEnd\": 145,\n    \"suggestionContent\": \"The retry loop continues after a 401 response and token refresh, but the `attempt` counter is still incremented. This means if token refresh happens on the last retry attempt, the request won't be retried with the new token. Also, the finally block doesn't clean up the pendingRequests entry on failure.\",\n    \"oneSentenceSummary\": \"401 retry consumes retry attempt - may fail if token expires on last retry\",\n    \"relevantLinesStart\": 140\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 10: packages/scheduling/src/utils/DateScheduler.ts",
        "vars": {
          "fileContent": "export interface ScheduleConfig {\n  startDate: string;\n  endDate: string;\n  timezone: string;\n  recurrence?: 'daily' | 'weekly' | 'monthly';\n  excludeWeekends?: boolean;\n}\n\nexport interface ScheduledEvent {\n  id: string;\n  date: Date;\n  originalDate: string;\n}\n\nexport function parseDate(dateString: string): Date {\n  return new Date(dateString);\n}\n\nexport function formatDate(date: Date): string {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\nexport function addDays(date: Date, days: number): Date {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n}\n\nexport function addMonths(date: Date, months: number): Date {\n  const result = new Date(date);\n  result.setMonth(result.getMonth() + months);\n  return result;\n}\n\nexport function isWeekend(date: Date): boolean {\n  const day = date.getDay();\n  return day === 0 || day === 6;\n}\n\nexport function getBusinessDaysBetween(start: Date, end: Date): number {\n  let count = 0;\n  const current = new Date(start);\n\n  while (current <= end) {\n    if (!isWeekend(current)) {\n      count++;\n    }\n    current.setDate(current.getDate() + 1);\n  }\n\n  return count;\n}\n\nexport function generateSchedule(config: ScheduleConfig): ScheduledEvent[] {\n  const events: ScheduledEvent[] = [];\n  const start = parseDate(config.startDate);\n  const end = parseDate(config.endDate);\n\n  let current = start;\n  let eventId = 1;\n\n  while (current <= end) {\n    if (!config.excludeWeekends || !isWeekend(current)) {\n      events.push({\n        id: `event_${eventId++}`,\n        date: current,\n        originalDate: formatDate(current),\n      });\n    }\n\n    switch (config.recurrence) {\n      case 'daily':\n        current = addDays(current, 1);\n        break;\n      case 'weekly':\n        current = addDays(current, 7);\n        break;\n      case 'monthly':\n        current = addMonths(current, 1);\n        break;\n      default:\n        current = addDays(current, 1);\n    }\n  }\n\n  return events;\n}\n\nexport function getNextBusinessDay(date: Date): Date {\n  let next = addDays(date, 1);\n  while (isWeekend(next)) {\n    next = addDays(next, 1);\n  }\n  return next;\n}\n\nexport function isSameDay(date1: Date, date2: Date): boolean {\n  return (\n    date1.getFullYear() === date2.getFullYear() &&\n    date1.getMonth() === date2.getMonth() &&\n    date1.getDate() === date2.getDate()\n  );\n}\n\nexport function getDaysDifference(date1: Date, date2: Date): number {\n  const diffTime = date2.getTime() - date1.getTime();\n  return diffTime / (1000 * 60 * 60 * 24);\n}\n\nexport class DateScheduler {\n  private config: ScheduleConfig;\n\n  constructor(config: ScheduleConfig) {\n    this.config = config;\n  }\n\n  generate(): ScheduledEvent[] {\n    return generateSchedule(this.config);\n  }\n\n  isValidDate(date: Date): boolean {\n    const start = parseDate(this.config.startDate);\n    const end = parseDate(this.config.endDate);\n    return date >= start && date <= end;\n  }\n}\n",
          "patchWithLinesStr": "## file: 'packages/scheduling/src/utils/DateScheduler.ts'\n\n@@ -0,0 +1,130 @@\n__new hunk__\n1 +export interface ScheduleConfig {\n2 +  startDate: string;\n3 +  endDate: string;\n4 +  timezone: string;\n5 +  recurrence?: 'daily' | 'weekly' | 'monthly';\n6 +  excludeWeekends?: boolean;\n7 +}\n8 +\n9 +export interface ScheduledEvent {\n10 +  id: string;\n11 +  date: Date;\n12 +  originalDate: string;\n13 +}\n14 +\n15 +export function parseDate(dateString: string): Date {\n16 +  return new Date(dateString);\n17 +}\n18 +\n19 +export function formatDate(date: Date): string {\n20 +  const year = date.getFullYear();\n21 +  const month = String(date.getMonth() + 1).padStart(2, '0');\n22 +  const day = String(date.getDate()).padStart(2, '0');\n23 +  return `${year}-${month}-${day}`;\n24 +}\n25 +\n26 +export function addDays(date: Date, days: number): Date {\n27 +  const result = new Date(date);\n28 +  result.setDate(result.getDate() + days);\n29 +  return result;\n30 +}\n31 +\n32 +export function addMonths(date: Date, months: number): Date {\n33 +  const result = new Date(date);\n34 +  result.setMonth(result.getMonth() + months);\n35 +  return result;\n36 +}\n37 +\n38 +export function isWeekend(date: Date): boolean {\n39 +  const day = date.getDay();\n40 +  return day === 0 || day === 6;\n41 +}\n42 +\n43 +export function getBusinessDaysBetween(start: Date, end: Date): number {\n44 +  let count = 0;\n45 +  const current = new Date(start);\n46 +\n47 +  while (current <= end) {\n48 +    if (!isWeekend(current)) {\n49 +      count++;\n50 +    }\n51 +    current.setDate(current.getDate() + 1);\n52 +  }\n53 +\n54 +  return count;\n55 +}\n56 +\n57 +export function generateSchedule(config: ScheduleConfig): ScheduledEvent[] {\n58 +  const events: ScheduledEvent[] = [];\n59 +  const start = parseDate(config.startDate);\n60 +  const end = parseDate(config.endDate);\n61 +\n62 +  let current = start;\n63 +  let eventId = 1;\n64 +\n65 +  while (current <= end) {\n66 +    if (!config.excludeWeekends || !isWeekend(current)) {\n67 +      events.push({\n68 +        id: `event_${eventId++}`,\n69 +        date: current,\n70 +        originalDate: formatDate(current),\n71 +      });\n72 +    }\n73 +\n74 +    switch (config.recurrence) {\n75 +      case 'daily':\n76 +        current = addDays(current, 1);\n77 +        break;\n78 +      case 'weekly':\n79 +        current = addDays(current, 7);\n80 +        break;\n81 +      case 'monthly':\n82 +        current = addMonths(current, 1);\n83 +        break;\n84 +      default:\n85 +        current = addDays(current, 1);\n86 +    }\n87 +  }\n88 +\n89 +  return events;\n90 +}\n91 +\n92 +export function getNextBusinessDay(date: Date): Date {\n93 +  let next = addDays(date, 1);\n94 +  while (isWeekend(next)) {\n95 +    next = addDays(next, 1);\n96 +  }\n97 +  return next;\n98 +}\n99 +\n100 +export function isSameDay(date1: Date, date2: Date): boolean {\n101 +  return (\n102 +    date1.getFullYear() === date2.getFullYear() &&\n103 +    date1.getMonth() === date2.getMonth() &&\n104 +    date1.getDate() === date2.getDate()\n105 +  );\n106 +}\n107 +\n108 +export function getDaysDifference(date1: Date, date2: Date): number {\n109 +  const diffTime = date2.getTime() - date1.getTime();\n110 +  return diffTime / (1000 * 60 * 60 * 24);\n111 +}\n112 +\n113 +export class DateScheduler {\n114 +  private config: ScheduleConfig;\n115 +\n116 +  constructor(config: ScheduleConfig) {\n117 +    this.config = config;\n118 +  }\n119 +\n120 +  generate(): ScheduledEvent[] {\n121 +    return generateSchedule(this.config);\n122 +  }\n123 +\n124 +  isValidDate(date: Date): boolean {\n125 +    const start = parseDate(this.config.startDate);\n126 +    const end = parseDate(this.config.endDate);\n127 +    return date >= start && date <= end;\n128 +  }\n129 +}\n130 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/scheduling/src/utils/DateScheduler.ts\",\"relevantLinesStart\":63,\"relevantLinesEnd\":67},{\"relevantFile\":\"packages/scheduling/src/utils/DateScheduler.ts\",\"relevantLinesStart\":99,\"relevantLinesEnd\":102}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"events.push({\\n        id: `event_${eventId++}`,\\n        date: current,\\n        originalDate: formatDate(current),\\n      });\",\n    \"improvedCode\": \"events.push({\\n        id: `event_${eventId++}`,\\n        date: new Date(current),\\n        originalDate: formatDate(current),\\n      });\",\n    \"relevantFile\": \"packages/scheduling/src/utils/DateScheduler.ts\",\n    \"relevantLinesEnd\": 67,\n    \"suggestionContent\": \"The `generateSchedule` function pushes the same Date object reference into the events array instead of creating a new Date for each event. Since `current` is mutated in the loop, all events end up pointing to the same Date object, which will have the final value after the loop completes. All events will show the same date.\",\n    \"oneSentenceSummary\": \"Same Date object reference pushed to array - all events have same final date\",\n    \"relevantLinesStart\": 63\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"export function getDaysDifference(date1: Date, date2: Date): number {\\n  const diffTime = date2.getTime() - date1.getTime();\\n  return diffTime / (1000 * 60 * 60 * 24);\\n}\",\n    \"improvedCode\": \"export function getDaysDifference(date1: Date, date2: Date): number {\\n  // Use UTC to avoid DST issues\\n  const utc1 = Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate());\\n  const utc2 = Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate());\\n  return (utc2 - utc1) / (1000 * 60 * 60 * 24);\\n}\",\n    \"relevantFile\": \"packages/scheduling/src/utils/DateScheduler.ts\",\n    \"relevantLinesEnd\": 102,\n    \"suggestionContent\": \"The `getDaysDifference` function divides by milliseconds per day but doesn't account for daylight saving time transitions. When crossing DST boundaries, a 'day' might be 23 or 25 hours, causing the function to return incorrect fractional values (e.g., 0.958 instead of 1 for a single day across DST).\",\n    \"oneSentenceSummary\": \"Days calculation doesn't handle DST - returns wrong value across timezone changes\",\n    \"relevantLinesStart\": 99\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 11: packages/database/src/query/QueryBuilder.ts",
        "vars": {
          "fileContent": "export type WhereOperator = '=' | '!=' | '>' | '<' | '>=' | '<=' | 'LIKE' | 'IN' | 'NOT IN';\nexport type OrderDirection = 'ASC' | 'DESC';\n\nexport interface WhereClause {\n  column: string;\n  operator: WhereOperator;\n  value: unknown;\n}\n\nexport interface OrderByClause {\n  column: string;\n  direction: OrderDirection;\n}\n\nexport interface JoinClause {\n  table: string;\n  type: 'INNER' | 'LEFT' | 'RIGHT';\n  on: string;\n}\n\nexport interface QueryResult<T> {\n  rows: T[];\n  rowCount: number;\n}\n\nexport class QueryBuilder<T = unknown> {\n  private tableName: string;\n  private selectColumns: string[] = ['*'];\n  private whereClauses: WhereClause[] = [];\n  private orderByClauses: OrderByClause[] = [];\n  private joinClauses: JoinClause[] = [];\n  private limitValue?: number;\n  private offsetValue?: number;\n  private params: unknown[] = [];\n\n  constructor(table: string) {\n    this.tableName = table;\n  }\n\n  select(...columns: string[]): this {\n    this.selectColumns = columns.length > 0 ? columns : ['*'];\n    return this;\n  }\n\n  where(column: string, operator: WhereOperator, value: unknown): this {\n    this.whereClauses.push({ column, operator, value });\n    return this;\n  }\n\n  whereEquals(column: string, value: unknown): this {\n    return this.where(column, '=', value);\n  }\n\n  whereLike(column: string, pattern: string): this {\n    return this.where(column, 'LIKE', pattern);\n  }\n\n  whereIn(column: string, values: unknown[]): this {\n    return this.where(column, 'IN', values);\n  }\n\n  orderBy(column: string, direction: OrderDirection = 'ASC'): this {\n    this.orderByClauses.push({ column, direction });\n    return this;\n  }\n\n  join(table: string, on: string, type: 'INNER' | 'LEFT' | 'RIGHT' = 'INNER'): this {\n    this.joinClauses.push({ table, type, on });\n    return this;\n  }\n\n  limit(count: number): this {\n    this.limitValue = count;\n    return this;\n  }\n\n  offset(count: number): this {\n    this.offsetValue = count;\n    return this;\n  }\n\n  buildSelect(): { sql: string; params: unknown[] } {\n    this.params = [];\n    let sql = `SELECT ${this.selectColumns.join(', ')} FROM ${this.tableName}`;\n\n    for (const join of this.joinClauses) {\n      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\n    }\n\n    if (this.whereClauses.length > 0) {\n      const conditions = this.whereClauses.map(clause => {\n        if (clause.operator === 'IN' || clause.operator === 'NOT IN') {\n          const values = clause.value as unknown[];\n          const placeholders = values.map(() => '?').join(', ');\n          this.params.push(...values);\n          return `${clause.column} ${clause.operator} (${placeholders})`;\n        }\n        this.params.push(clause.value);\n        return `${clause.column} ${clause.operator} ?`;\n      });\n      sql += ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    if (this.orderByClauses.length > 0) {\n      const orders = this.orderByClauses.map(\n        clause => `${clause.column} ${clause.direction}`\n      );\n      sql += ` ORDER BY ${orders.join(', ')}`;\n    }\n\n    if (this.limitValue !== undefined) {\n      sql += ` LIMIT ${this.limitValue}`;\n    }\n\n    if (this.offsetValue !== undefined) {\n      sql += ` OFFSET ${this.offsetValue}`;\n    }\n\n    return { sql, params: this.params };\n  }\n\n  buildInsert(data: Partial<T>): { sql: string; params: unknown[] } {\n    const columns = Object.keys(data);\n    const values = Object.values(data);\n    const placeholders = columns.map(() => '?').join(', ');\n\n    const sql = `INSERT INTO ${this.tableName} (${columns.join(', ')}) VALUES (${placeholders})`;\n\n    return { sql, params: values };\n  }\n\n  buildUpdate(data: Partial<T>): { sql: string; params: unknown[] } {\n    this.params = [];\n    const setClauses = Object.entries(data).map(([column, value]) => {\n      this.params.push(value);\n      return `${column} = ?`;\n    });\n\n    let sql = `UPDATE ${this.tableName} SET ${setClauses.join(', ')}`;\n\n    if (this.whereClauses.length > 0) {\n      const conditions = this.whereClauses.map(clause => {\n        this.params.push(clause.value);\n        return `${clause.column} ${clause.operator} ?`;\n      });\n      sql += ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    return { sql, params: this.params };\n  }\n\n  buildDelete(): { sql: string; params: unknown[] } {\n    this.params = [];\n    let sql = `DELETE FROM ${this.tableName}`;\n\n    if (this.whereClauses.length > 0) {\n      const conditions = this.whereClauses.map(clause => {\n        this.params.push(clause.value);\n        return `${clause.column} ${clause.operator} ?`;\n      });\n      sql += ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    return { sql, params: this.params };\n  }\n\n  reset(): this {\n    this.selectColumns = ['*'];\n    this.whereClauses = [];\n    this.orderByClauses = [];\n    this.joinClauses = [];\n    this.limitValue = undefined;\n    this.offsetValue = undefined;\n    this.params = [];\n    return this;\n  }\n}\n\nexport function query<T>(table: string): QueryBuilder<T> {\n  return new QueryBuilder<T>(table);\n}\n",
          "patchWithLinesStr": "## file: 'packages/database/src/query/QueryBuilder.ts'\n\n@@ -0,0 +1,182 @@\n__new hunk__\n1 +export type WhereOperator = '=' | '!=' | '>' | '<' | '>=' | '<=' | 'LIKE' | 'IN' | 'NOT IN';\n2 +export type OrderDirection = 'ASC' | 'DESC';\n3 +\n4 +export interface WhereClause {\n5 +  column: string;\n6 +  operator: WhereOperator;\n7 +  value: unknown;\n8 +}\n9 +\n10 +export interface OrderByClause {\n11 +  column: string;\n12 +  direction: OrderDirection;\n13 +}\n14 +\n15 +export interface JoinClause {\n16 +  table: string;\n17 +  type: 'INNER' | 'LEFT' | 'RIGHT';\n18 +  on: string;\n19 +}\n20 +\n21 +export interface QueryResult<T> {\n22 +  rows: T[];\n23 +  rowCount: number;\n24 +}\n25 +\n26 +export class QueryBuilder<T = unknown> {\n27 +  private tableName: string;\n28 +  private selectColumns: string[] = ['*'];\n29 +  private whereClauses: WhereClause[] = [];\n30 +  private orderByClauses: OrderByClause[] = [];\n31 +  private joinClauses: JoinClause[] = [];\n32 +  private limitValue?: number;\n33 +  private offsetValue?: number;\n34 +  private params: unknown[] = [];\n35 +\n36 +  constructor(table: string) {\n37 +    this.tableName = table;\n38 +  }\n39 +\n40 +  select(...columns: string[]): this {\n41 +    this.selectColumns = columns.length > 0 ? columns : ['*'];\n42 +    return this;\n43 +  }\n44 +\n45 +  where(column: string, operator: WhereOperator, value: unknown): this {\n46 +    this.whereClauses.push({ column, operator, value });\n47 +    return this;\n48 +  }\n49 +\n50 +  whereEquals(column: string, value: unknown): this {\n51 +    return this.where(column, '=', value);\n52 +  }\n53 +\n54 +  whereLike(column: string, pattern: string): this {\n55 +    return this.where(column, 'LIKE', pattern);\n56 +  }\n57 +\n58 +  whereIn(column: string, values: unknown[]): this {\n59 +    return this.where(column, 'IN', values);\n60 +  }\n61 +\n62 +  orderBy(column: string, direction: OrderDirection = 'ASC'): this {\n63 +    this.orderByClauses.push({ column, direction });\n64 +    return this;\n65 +  }\n66 +\n67 +  join(table: string, on: string, type: 'INNER' | 'LEFT' | 'RIGHT' = 'INNER'): this {\n68 +    this.joinClauses.push({ table, type, on });\n69 +    return this;\n70 +  }\n71 +\n72 +  limit(count: number): this {\n73 +    this.limitValue = count;\n74 +    return this;\n75 +  }\n76 +\n77 +  offset(count: number): this {\n78 +    this.offsetValue = count;\n79 +    return this;\n80 +  }\n81 +\n82 +  buildSelect(): { sql: string; params: unknown[] } {\n83 +    this.params = [];\n84 +    let sql = `SELECT ${this.selectColumns.join(', ')} FROM ${this.tableName}`;\n85 +\n86 +    for (const join of this.joinClauses) {\n87 +      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\n88 +    }\n89 +\n90 +    if (this.whereClauses.length > 0) {\n91 +      const conditions = this.whereClauses.map(clause => {\n92 +        if (clause.operator === 'IN' || clause.operator === 'NOT IN') {\n93 +          const values = clause.value as unknown[];\n94 +          const placeholders = values.map(() => '?').join(', ');\n95 +          this.params.push(...values);\n96 +          return `${clause.column} ${clause.operator} (${placeholders})`;\n97 +        }\n98 +        this.params.push(clause.value);\n99 +        return `${clause.column} ${clause.operator} ?`;\n100 +      });\n101 +      sql += ` WHERE ${conditions.join(' AND ')}`;\n102 +    }\n103 +\n104 +    if (this.orderByClauses.length > 0) {\n105 +      const orders = this.orderByClauses.map(\n106 +        clause => `${clause.column} ${clause.direction}`\n107 +      );\n108 +      sql += ` ORDER BY ${orders.join(', ')}`;\n109 +    }\n110 +\n111 +    if (this.limitValue !== undefined) {\n112 +      sql += ` LIMIT ${this.limitValue}`;\n113 +    }\n114 +\n115 +    if (this.offsetValue !== undefined) {\n116 +      sql += ` OFFSET ${this.offsetValue}`;\n117 +    }\n118 +\n119 +    return { sql, params: this.params };\n120 +  }\n121 +\n122 +  buildInsert(data: Partial<T>): { sql: string; params: unknown[] } {\n123 +    const columns = Object.keys(data);\n124 +    const values = Object.values(data);\n125 +    const placeholders = columns.map(() => '?').join(', ');\n126 +\n127 +    const sql = `INSERT INTO ${this.tableName} (${columns.join(', ')}) VALUES (${placeholders})`;\n128 +\n129 +    return { sql, params: values };\n130 +  }\n131 +\n132 +  buildUpdate(data: Partial<T>): { sql: string; params: unknown[] } {\n133 +    this.params = [];\n134 +    const setClauses = Object.entries(data).map(([column, value]) => {\n135 +      this.params.push(value);\n136 +      return `${column} = ?`;\n137 +    });\n138 +\n139 +    let sql = `UPDATE ${this.tableName} SET ${setClauses.join(', ')}`;\n140 +\n141 +    if (this.whereClauses.length > 0) {\n142 +      const conditions = this.whereClauses.map(clause => {\n143 +        this.params.push(clause.value);\n144 +        return `${clause.column} ${clause.operator} ?`;\n145 +      });\n146 +      sql += ` WHERE ${conditions.join(' AND ')}`;\n147 +    }\n148 +\n149 +    return { sql, params: this.params };\n150 +  }\n151 +\n152 +  buildDelete(): { sql: string; params: unknown[] } {\n153 +    this.params = [];\n154 +    let sql = `DELETE FROM ${this.tableName}`;\n155 +\n156 +    if (this.whereClauses.length > 0) {\n157 +      const conditions = this.whereClauses.map(clause => {\n158 +        this.params.push(clause.value);\n159 +        return `${clause.column} ${clause.operator} ?`;\n160 +      });\n161 +      sql += ` WHERE ${conditions.join(' AND ')}`;\n162 +    }\n163 +\n164 +    return { sql, params: this.params };\n165 +  }\n166 +\n167 +  reset(): this {\n168 +    this.selectColumns = ['*'];\n169 +    this.whereClauses = [];\n170 +    this.orderByClauses = [];\n171 +    this.joinClauses = [];\n172 +    this.limitValue = undefined;\n173 +    this.offsetValue = undefined;\n174 +    this.params = [];\n175 +    return this;\n176 +  }\n177 +}\n178 +\n179 +export function query<T>(table: string): QueryBuilder<T> {\n180 +  return new QueryBuilder<T>(table);\n181 +}\n182 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/database/src/query/QueryBuilder.ts\",\"relevantLinesStart\":76,\"relevantLinesEnd\":76},{\"relevantFile\":\"packages/database/src/query/QueryBuilder.ts\",\"relevantLinesStart\":95,\"relevantLinesEnd\":100},{\"relevantFile\":\"packages/database/src/query/QueryBuilder.ts\",\"relevantLinesStart\":78,\"relevantLinesEnd\":80}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"let sql = `SELECT ${this.selectColumns.join(', ')} FROM ${this.tableName}`;\",\n    \"improvedCode\": \"const safeColumns = this.selectColumns.map(col => {\\n      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(col) && col !== '*') {\\n        throw new Error(`Invalid column name: ${col}`);\\n      }\\n      return col;\\n    });\\n    let sql = `SELECT ${safeColumns.join(', ')} FROM ${this.tableName}`;\",\n    \"relevantFile\": \"packages/database/src/query/QueryBuilder.ts\",\n    \"relevantLinesEnd\": 76,\n    \"suggestionContent\": \"The `buildSelect` method directly interpolates `this.selectColumns` into the SQL query without sanitization. If column names come from user input, an attacker can inject SQL like `*; DROP TABLE users; --`. Column names should be validated against an allowlist or properly escaped.\",\n    \"oneSentenceSummary\": \"SQL injection via column names - user input interpolated without sanitization\",\n    \"relevantLinesStart\": 76\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (this.orderByClauses.length > 0) {\\n      const orders = this.orderByClauses.map(\\n        clause => `${clause.column} ${clause.direction}`\\n      );\\n      sql += ` ORDER BY ${orders.join(', ')}`;\\n    }\",\n    \"improvedCode\": \"if (this.orderByClauses.length > 0) {\\n      const orders = this.orderByClauses.map(clause => {\\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(clause.column)) {\\n          throw new Error(`Invalid column name: ${clause.column}`);\\n        }\\n        return `${clause.column} ${clause.direction}`;\\n      });\\n      sql += ` ORDER BY ${orders.join(', ')}`;\\n    }\",\n    \"relevantFile\": \"packages/database/src/query/QueryBuilder.ts\",\n    \"relevantLinesEnd\": 100,\n    \"suggestionContent\": \"The `orderBy` clause uses `clause.column` and `clause.direction` directly in string interpolation. While direction is constrained by the type, column is not validated. An attacker can inject SQL via the column parameter like `id; DROP TABLE users; --`.\",\n    \"oneSentenceSummary\": \"SQL injection in ORDER BY clause - column name not validated\",\n    \"relevantLinesStart\": 95\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"for (const join of this.joinClauses) {\\n      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\\n    }\",\n    \"improvedCode\": \"for (const join of this.joinClauses) {\\n      // Validate table name\\n      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(join.table)) {\\n        throw new Error(`Invalid table name: ${join.table}`);\\n      }\\n      // ON clause should use parameterized format or be validated\\n      if (!/^[a-zA-Z_][a-zA-Z0-9_.]+\\\\s*=\\\\s*[a-zA-Z_][a-zA-Z0-9_.]+$/.test(join.on)) {\\n        throw new Error(`Invalid join condition: ${join.on}`);\\n      }\\n      sql += ` ${join.type} JOIN ${join.table} ON ${join.on}`;\\n    }\",\n    \"relevantFile\": \"packages/database/src/query/QueryBuilder.ts\",\n    \"relevantLinesEnd\": 80,\n    \"suggestionContent\": \"The `join` method takes an `on` parameter that is directly interpolated into the SQL query. This allows SQL injection via the join condition, e.g., `users.id = posts.user_id; DROP TABLE users; --`.\",\n    \"oneSentenceSummary\": \"SQL injection in JOIN clause - on condition not sanitized\",\n    \"relevantLinesStart\": 78\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 12: packages/security/src/middleware/RateLimiter.ts",
        "vars": {
          "fileContent": "export interface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  keyGenerator?: (req: Request) => string;\n  onLimitReached?: (key: string) => void;\n  skipFailedRequests?: boolean;\n}\n\ninterface RateLimitEntry {\n  count: number;\n  resetTime: number;\n}\n\ninterface Request {\n  ip: string;\n  headers: Record<string, string>;\n  path: string;\n}\n\ninterface Response {\n  status: (code: number) => Response;\n  json: (data: unknown) => void;\n  setHeader: (name: string, value: string) => void;\n}\n\ntype NextFunction = () => void;\n\nconst DEFAULT_CONFIG: RateLimitConfig = {\n  windowMs: 60000,\n  maxRequests: 100,\n};\n\nexport class RateLimiter {\n  private config: RateLimitConfig;\n  private store: Map<string, RateLimitEntry> = new Map();\n  private cleanupInterval: NodeJS.Timeout;\n\n  constructor(config: Partial<RateLimitConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.cleanupInterval = setInterval(() => this.cleanup(), this.config.windowMs);\n  }\n\n  private getKey(req: Request): string {\n    if (this.config.keyGenerator) {\n      return this.config.keyGenerator(req);\n    }\n    return req.headers['x-forwarded-for'] || req.ip;\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.store) {\n      if (now > entry.resetTime) {\n        this.store.delete(key);\n      }\n    }\n  }\n\n  isRateLimited(req: Request): { limited: boolean; remaining: number; resetTime: number } {\n    const key = this.getKey(req);\n    const now = Date.now();\n\n    let entry = this.store.get(key);\n\n    if (!entry || now > entry.resetTime) {\n      entry = {\n        count: 0,\n        resetTime: now + this.config.windowMs,\n      };\n      this.store.set(key, entry);\n    }\n\n    entry.count++;\n\n    const remaining = Math.max(0, this.config.maxRequests - entry.count);\n    const limited = entry.count > this.config.maxRequests;\n\n    if (limited && this.config.onLimitReached) {\n      this.config.onLimitReached(key);\n    }\n\n    return { limited, remaining, resetTime: entry.resetTime };\n  }\n\n  middleware() {\n    return (req: Request, res: Response, next: NextFunction) => {\n      const { limited, remaining, resetTime } = this.isRateLimited(req);\n\n      res.setHeader('X-RateLimit-Limit', String(this.config.maxRequests));\n      res.setHeader('X-RateLimit-Remaining', String(remaining));\n      res.setHeader('X-RateLimit-Reset', String(Math.ceil(resetTime / 1000)));\n\n      if (limited) {\n        res.status(429).json({\n          error: 'Too many requests',\n          retryAfter: Math.ceil((resetTime - Date.now()) / 1000),\n        });\n        return;\n      }\n\n      next();\n    };\n  }\n\n  reset(key: string): void {\n    this.store.delete(key);\n  }\n\n  resetAll(): void {\n    this.store.clear();\n  }\n\n  getStats(): { totalKeys: number; totalRequests: number } {\n    let totalRequests = 0;\n    for (const entry of this.store.values()) {\n      totalRequests += entry.count;\n    }\n    return {\n      totalKeys: this.store.size,\n      totalRequests,\n    };\n  }\n\n  destroy(): void {\n    clearInterval(this.cleanupInterval);\n    this.store.clear();\n  }\n}\n\nexport function createRateLimiter(config?: Partial<RateLimitConfig>): RateLimiter {\n  return new RateLimiter(config);\n}\n",
          "patchWithLinesStr": "## file: 'packages/security/src/middleware/RateLimiter.ts'\n\n@@ -0,0 +1,133 @@\n__new hunk__\n1 +export interface RateLimitConfig {\n2 +  windowMs: number;\n3 +  maxRequests: number;\n4 +  keyGenerator?: (req: Request) => string;\n5 +  onLimitReached?: (key: string) => void;\n6 +  skipFailedRequests?: boolean;\n7 +}\n8 +\n9 +interface RateLimitEntry {\n10 +  count: number;\n11 +  resetTime: number;\n12 +}\n13 +\n14 +interface Request {\n15 +  ip: string;\n16 +  headers: Record<string, string>;\n17 +  path: string;\n18 +}\n19 +\n20 +interface Response {\n21 +  status: (code: number) => Response;\n22 +  json: (data: unknown) => void;\n23 +  setHeader: (name: string, value: string) => void;\n24 +}\n25 +\n26 +type NextFunction = () => void;\n27 +\n28 +const DEFAULT_CONFIG: RateLimitConfig = {\n29 +  windowMs: 60000,\n30 +  maxRequests: 100,\n31 +};\n32 +\n33 +export class RateLimiter {\n34 +  private config: RateLimitConfig;\n35 +  private store: Map<string, RateLimitEntry> = new Map();\n36 +  private cleanupInterval: NodeJS.Timeout;\n37 +\n38 +  constructor(config: Partial<RateLimitConfig> = {}) {\n39 +    this.config = { ...DEFAULT_CONFIG, ...config };\n40 +    this.cleanupInterval = setInterval(() => this.cleanup(), this.config.windowMs);\n41 +  }\n42 +\n43 +  private getKey(req: Request): string {\n44 +    if (this.config.keyGenerator) {\n45 +      return this.config.keyGenerator(req);\n46 +    }\n47 +    return req.headers['x-forwarded-for'] || req.ip;\n48 +  }\n49 +\n50 +  private cleanup(): void {\n51 +    const now = Date.now();\n52 +    for (const [key, entry] of this.store) {\n53 +      if (now > entry.resetTime) {\n54 +        this.store.delete(key);\n55 +      }\n56 +    }\n57 +  }\n58 +\n59 +  isRateLimited(req: Request): { limited: boolean; remaining: number; resetTime: number } {\n60 +    const key = this.getKey(req);\n61 +    const now = Date.now();\n62 +\n63 +    let entry = this.store.get(key);\n64 +\n65 +    if (!entry || now > entry.resetTime) {\n66 +      entry = {\n67 +        count: 0,\n68 +        resetTime: now + this.config.windowMs,\n69 +      };\n70 +      this.store.set(key, entry);\n71 +    }\n72 +\n73 +    entry.count++;\n74 +\n75 +    const remaining = Math.max(0, this.config.maxRequests - entry.count);\n76 +    const limited = entry.count > this.config.maxRequests;\n77 +\n78 +    if (limited && this.config.onLimitReached) {\n79 +      this.config.onLimitReached(key);\n80 +    }\n81 +\n82 +    return { limited, remaining, resetTime: entry.resetTime };\n83 +  }\n84 +\n85 +  middleware() {\n86 +    return (req: Request, res: Response, next: NextFunction) => {\n87 +      const { limited, remaining, resetTime } = this.isRateLimited(req);\n88 +\n89 +      res.setHeader('X-RateLimit-Limit', String(this.config.maxRequests));\n90 +      res.setHeader('X-RateLimit-Remaining', String(remaining));\n91 +      res.setHeader('X-RateLimit-Reset', String(Math.ceil(resetTime / 1000)));\n92 +\n93 +      if (limited) {\n94 +        res.status(429).json({\n95 +          error: 'Too many requests',\n96 +          retryAfter: Math.ceil((resetTime - Date.now()) / 1000),\n97 +        });\n98 +        return;\n99 +      }\n100 +\n101 +      next();\n102 +    };\n103 +  }\n104 +\n105 +  reset(key: string): void {\n106 +    this.store.delete(key);\n107 +  }\n108 +\n109 +  resetAll(): void {\n110 +    this.store.clear();\n111 +  }\n112 +\n113 +  getStats(): { totalKeys: number; totalRequests: number } {\n114 +    let totalRequests = 0;\n115 +    for (const entry of this.store.values()) {\n116 +      totalRequests += entry.count;\n117 +    }\n118 +    return {\n119 +      totalKeys: this.store.size,\n120 +      totalRequests,\n121 +    };\n122 +  }\n123 +\n124 +  destroy(): void {\n125 +    clearInterval(this.cleanupInterval);\n126 +    this.store.clear();\n127 +  }\n128 +}\n129 +\n130 +export function createRateLimiter(config?: Partial<RateLimitConfig>): RateLimiter {\n131 +  return new RateLimiter(config);\n132 +}\n133 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/security/src/middleware/RateLimiter.ts\",\"relevantLinesStart\":57,\"relevantLinesEnd\":67}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"let entry = this.store.get(key);\\n\\n    if (!entry || now > entry.resetTime) {\\n      entry = {\\n        count: 0,\\n        resetTime: now + this.config.windowMs,\\n      };\\n      this.store.set(key, entry);\\n    }\\n\\n    entry.count++;\",\n    \"improvedCode\": \"// Use atomic check-and-increment pattern\\n    let entry = this.store.get(key);\\n    const needsReset = !entry || now > entry.resetTime;\\n    \\n    if (needsReset) {\\n      entry = {\\n        count: 1,  // Start at 1, not 0 then increment\\n        resetTime: now + this.config.windowMs,\\n      };\\n      this.store.set(key, entry);\\n    } else {\\n      entry.count++;\\n    }\",\n    \"relevantFile\": \"packages/security/src/middleware/RateLimiter.ts\",\n    \"relevantLinesEnd\": 67,\n    \"suggestionContent\": \"The `isRateLimited` method has a race condition. Between checking if the entry exists and incrementing the count, another concurrent request could create or modify the entry. In a high-concurrency environment (or when using clustering), this allows more requests than the limit because multiple requests can pass the check before any of them increment the counter. Use atomic operations or a mutex for thread-safe rate limiting.\",\n    \"oneSentenceSummary\": \"Race condition in rate limiting - concurrent requests can bypass limit\",\n    \"relevantLinesStart\": 57\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 13: packages/state/src/reducers/cartReducer.ts",
        "vars": {
          "fileContent": "export interface CartItem {\n  productId: string;\n  name: string;\n  price: number;\n  quantity: number;\n  options?: Record<string, string>;\n}\n\nexport interface CartState {\n  items: CartItem[];\n  couponCode: string | null;\n  discountPercent: number;\n  lastUpdated: number;\n}\n\nexport type CartAction =\n  | { type: 'ADD_ITEM'; payload: CartItem }\n  | { type: 'REMOVE_ITEM'; payload: { productId: string } }\n  | { type: 'UPDATE_QUANTITY'; payload: { productId: string; quantity: number } }\n  | { type: 'APPLY_COUPON'; payload: { code: string; discount: number } }\n  | { type: 'CLEAR_CART' }\n  | { type: 'RESTORE_CART'; payload: CartState };\n\nexport const initialCartState: CartState = {\n  items: [],\n  couponCode: null,\n  discountPercent: 0,\n  lastUpdated: Date.now(),\n};\n\nfunction findItemIndex(items: CartItem[], productId: string): number {\n  return items.findIndex(item => item.productId === productId);\n}\n\nexport function cartReducer(\n  state: CartState = initialCartState,\n  action: CartAction\n): CartState {\n  switch (action.type) {\n    case 'ADD_ITEM': {\n      const existingIndex = findItemIndex(state.items, action.payload.productId);\n\n      if (existingIndex >= 0) {\n        const updatedItems = [...state.items];\n        updatedItems[existingIndex].quantity += action.payload.quantity;\n        return {\n          ...state,\n          items: updatedItems,\n          lastUpdated: Date.now(),\n        };\n      }\n\n      return {\n        ...state,\n        items: [...state.items, action.payload],\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'REMOVE_ITEM': {\n      return {\n        ...state,\n        items: state.items.filter(\n          item => item.productId !== action.payload.productId\n        ),\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'UPDATE_QUANTITY': {\n      const index = findItemIndex(state.items, action.payload.productId);\n      if (index < 0) return state;\n\n      if (action.payload.quantity <= 0) {\n        return cartReducer(state, {\n          type: 'REMOVE_ITEM',\n          payload: { productId: action.payload.productId },\n        });\n      }\n\n      const updatedItems = [...state.items];\n      updatedItems[index].quantity = action.payload.quantity;\n      return {\n        ...state,\n        items: updatedItems,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'APPLY_COUPON': {\n      return {\n        ...state,\n        couponCode: action.payload.code,\n        discountPercent: action.payload.discount,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'CLEAR_CART': {\n      return {\n        ...initialCartState,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    case 'RESTORE_CART': {\n      return {\n        ...action.payload,\n        lastUpdated: Date.now(),\n      };\n    }\n\n    default:\n      return state;\n  }\n}\n\nexport function selectCartTotal(state: CartState): number {\n  const subtotal = state.items.reduce(\n    (sum, item) => sum + item.price * item.quantity,\n    0\n  );\n  return subtotal * (1 - state.discountPercent / 100);\n}\n\nexport function selectItemCount(state: CartState): number {\n  return state.items.reduce((sum, item) => sum + item.quantity, 0);\n}\n",
          "patchWithLinesStr": "## file: 'packages/state/src/reducers/cartReducer.ts'\n\n@@ -0,0 +1,129 @@\n__new hunk__\n1 +export interface CartItem {\n2 +  productId: string;\n3 +  name: string;\n4 +  price: number;\n5 +  quantity: number;\n6 +  options?: Record<string, string>;\n7 +}\n8 +\n9 +export interface CartState {\n10 +  items: CartItem[];\n11 +  couponCode: string | null;\n12 +  discountPercent: number;\n13 +  lastUpdated: number;\n14 +}\n15 +\n16 +export type CartAction =\n17 +  | { type: 'ADD_ITEM'; payload: CartItem }\n18 +  | { type: 'REMOVE_ITEM'; payload: { productId: string } }\n19 +  | { type: 'UPDATE_QUANTITY'; payload: { productId: string; quantity: number } }\n20 +  | { type: 'APPLY_COUPON'; payload: { code: string; discount: number } }\n21 +  | { type: 'CLEAR_CART' }\n22 +  | { type: 'RESTORE_CART'; payload: CartState };\n23 +\n24 +export const initialCartState: CartState = {\n25 +  items: [],\n26 +  couponCode: null,\n27 +  discountPercent: 0,\n28 +  lastUpdated: Date.now(),\n29 +};\n30 +\n31 +function findItemIndex(items: CartItem[], productId: string): number {\n32 +  return items.findIndex(item => item.productId === productId);\n33 +}\n34 +\n35 +export function cartReducer(\n36 +  state: CartState = initialCartState,\n37 +  action: CartAction\n38 +): CartState {\n39 +  switch (action.type) {\n40 +    case 'ADD_ITEM': {\n41 +      const existingIndex = findItemIndex(state.items, action.payload.productId);\n42 +\n43 +      if (existingIndex >= 0) {\n44 +        const updatedItems = [...state.items];\n45 +        updatedItems[existingIndex].quantity += action.payload.quantity;\n46 +        return {\n47 +          ...state,\n48 +          items: updatedItems,\n49 +          lastUpdated: Date.now(),\n50 +        };\n51 +      }\n52 +\n53 +      return {\n54 +        ...state,\n55 +        items: [...state.items, action.payload],\n56 +        lastUpdated: Date.now(),\n57 +      };\n58 +    }\n59 +\n60 +    case 'REMOVE_ITEM': {\n61 +      return {\n62 +        ...state,\n63 +        items: state.items.filter(\n64 +          item => item.productId !== action.payload.productId\n65 +        ),\n66 +        lastUpdated: Date.now(),\n67 +      };\n68 +    }\n69 +\n70 +    case 'UPDATE_QUANTITY': {\n71 +      const index = findItemIndex(state.items, action.payload.productId);\n72 +      if (index < 0) return state;\n73 +\n74 +      if (action.payload.quantity <= 0) {\n75 +        return cartReducer(state, {\n76 +          type: 'REMOVE_ITEM',\n77 +          payload: { productId: action.payload.productId },\n78 +        });\n79 +      }\n80 +\n81 +      const updatedItems = [...state.items];\n82 +      updatedItems[index].quantity = action.payload.quantity;\n83 +      return {\n84 +        ...state,\n85 +        items: updatedItems,\n86 +        lastUpdated: Date.now(),\n87 +      };\n88 +    }\n89 +\n90 +    case 'APPLY_COUPON': {\n91 +      return {\n92 +        ...state,\n93 +        couponCode: action.payload.code,\n94 +        discountPercent: action.payload.discount,\n95 +        lastUpdated: Date.now(),\n96 +      };\n97 +    }\n98 +\n99 +    case 'CLEAR_CART': {\n100 +      return {\n101 +        ...initialCartState,\n102 +        lastUpdated: Date.now(),\n103 +      };\n104 +    }\n105 +\n106 +    case 'RESTORE_CART': {\n107 +      return {\n108 +        ...action.payload,\n109 +        lastUpdated: Date.now(),\n110 +      };\n111 +    }\n112 +\n113 +    default:\n114 +      return state;\n115 +  }\n116 +}\n117 +\n118 +export function selectCartTotal(state: CartState): number {\n119 +  const subtotal = state.items.reduce(\n120 +    (sum, item) => sum + item.price * item.quantity,\n121 +    0\n122 +  );\n123 +  return subtotal * (1 - state.discountPercent / 100);\n124 +}\n125 +\n126 +export function selectItemCount(state: CartState): number {\n127 +  return state.items.reduce((sum, item) => sum + item.quantity, 0);\n128 +}\n129 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/state/src/reducers/cartReducer.ts\",\"relevantLinesStart\":43,\"relevantLinesEnd\":44}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"const updatedItems = [...state.items];\\n        updatedItems[existingIndex].quantity += action.payload.quantity;\",\n    \"improvedCode\": \"const updatedItems = state.items.map((item, index) =>\\n          index === existingIndex\\n            ? { ...item, quantity: item.quantity + action.payload.quantity }\\n            : item\\n        );\",\n    \"relevantFile\": \"packages/state/src/reducers/cartReducer.ts\",\n    \"relevantLinesEnd\": 44,\n    \"suggestionContent\": \"In the 'ADD_ITEM' and 'UPDATE_QUANTITY' cases, the code creates a shallow copy of the items array with `[...state.items]`, but then mutates the object at `updatedItems[index]` directly. Since array spread only creates a shallow copy, `updatedItems[existingIndex]` still references the same object as `state.items[existingIndex]`. This mutates the original state, breaking Redux/reducer immutability principles and causing issues with change detection, memoization, and time-travel debugging.\",\n    \"oneSentenceSummary\": \"Shallow array copy followed by object mutation breaks reducer immutability\",\n    \"relevantLinesStart\": 43\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 14: packages/state/src/store/StateManager.ts",
        "vars": {
          "fileContent": "export type StateListener<T> = (state: T, prevState: T) => void;\nexport type StateSelector<T, R> = (state: T) => R;\nexport type StateUpdater<T> = (state: T) => Partial<T>;\n\nexport interface StateManagerOptions<T> {\n  initialState: T;\n  persist?: boolean;\n  storageKey?: string;\n  middleware?: Array<(state: T, action: string) => T>;\n}\n\nexport interface StateSnapshot<T> {\n  state: T;\n  timestamp: number;\n  action: string;\n}\n\nfunction deepMerge<T extends object>(target: T, source: Partial<T>): T {\n  const result = { ...target };\n\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      const sourceValue = source[key];\n      const targetValue = target[key];\n\n      if (\n        sourceValue !== null &&\n        typeof sourceValue === 'object' &&\n        !Array.isArray(sourceValue) &&\n        targetValue !== null &&\n        typeof targetValue === 'object' &&\n        !Array.isArray(targetValue)\n      ) {\n        (result as any)[key] = deepMerge(targetValue as object, sourceValue as object);\n      } else {\n        (result as any)[key] = sourceValue;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepClone(item)) as unknown as T;\n  }\n\n  const cloned = {} as T;\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      (cloned as any)[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}\n\nexport class StateManager<T extends object> {\n  private state: T;\n  private listeners: Set<StateListener<T>> = new Set();\n  private history: StateSnapshot<T>[] = [];\n  private maxHistoryLength = 50;\n  private options: StateManagerOptions<T>;\n\n  constructor(options: StateManagerOptions<T>) {\n    this.options = options;\n    this.state = this.loadPersistedState() || deepClone(options.initialState);\n    this.saveSnapshot('init');\n  }\n\n  private loadPersistedState(): T | null {\n    if (!this.options.persist || !this.options.storageKey) {\n      return null;\n    }\n\n    try {\n      const stored = localStorage.getItem(this.options.storageKey);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n    } catch (error) {\n      console.warn('Failed to load persisted state:', error);\n    }\n\n    return null;\n  }\n\n  private persistState(): void {\n    if (!this.options.persist || !this.options.storageKey) {\n      return;\n    }\n\n    try {\n      localStorage.setItem(this.options.storageKey, JSON.stringify(this.state));\n    } catch (error) {\n      console.warn('Failed to persist state:', error);\n    }\n  }\n\n  private saveSnapshot(action: string): void {\n    this.history.push({\n      state: deepClone(this.state),\n      timestamp: Date.now(),\n      action,\n    });\n\n    if (this.history.length > this.maxHistoryLength) {\n      this.history.shift();\n    }\n  }\n\n  private notifyListeners(prevState: T): void {\n    this.listeners.forEach(listener => {\n      listener(this.state, prevState);\n    });\n  }\n\n  getState(): T {\n    return this.state;\n  }\n\n  setState(updater: StateUpdater<T> | Partial<T>, action = 'setState'): void {\n    const prevState = this.state;\n    const updates = typeof updater === 'function' ? updater(this.state) : updater;\n\n    this.state = deepMerge(this.state, updates);\n\n    if (this.options.middleware) {\n      for (const mw of this.options.middleware) {\n        this.state = mw(this.state, action);\n      }\n    }\n\n    this.saveSnapshot(action);\n    this.persistState();\n    this.notifyListeners(prevState);\n  }\n\n  subscribe(listener: StateListener<T>): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  select<R>(selector: StateSelector<T, R>): R {\n    return selector(this.state);\n  }\n\n  undo(): boolean {\n    if (this.history.length < 2) {\n      return false;\n    }\n\n    this.history.pop(); // Remove current state\n    const previousSnapshot = this.history[this.history.length - 1];\n\n    if (previousSnapshot) {\n      const prevState = this.state;\n      this.state = deepClone(previousSnapshot.state);\n      this.persistState();\n      this.notifyListeners(prevState);\n      return true;\n    }\n\n    return false;\n  }\n\n  getHistory(): StateSnapshot<T>[] {\n    return [...this.history];\n  }\n\n  importState(serialized: string): void {\n    const imported = JSON.parse(serialized);\n    this.setState(imported, 'import');\n  }\n\n  exportState(): string {\n    return JSON.stringify(this.state);\n  }\n\n  reset(): void {\n    const prevState = this.state;\n    this.state = deepClone(this.options.initialState);\n    this.history = [];\n    this.saveSnapshot('reset');\n    this.persistState();\n    this.notifyListeners(prevState);\n  }\n}\n\nexport function createStateManager<T extends object>(\n  options: StateManagerOptions<T>\n): StateManager<T> {\n  return new StateManager(options);\n}\n",
          "patchWithLinesStr": "## file: 'packages/state/src/store/StateManager.ts'\n\n@@ -0,0 +1,199 @@\n__new hunk__\n1 +export type StateListener<T> = (state: T, prevState: T) => void;\n2 +export type StateSelector<T, R> = (state: T) => R;\n3 +export type StateUpdater<T> = (state: T) => Partial<T>;\n4 +\n5 +export interface StateManagerOptions<T> {\n6 +  initialState: T;\n7 +  persist?: boolean;\n8 +  storageKey?: string;\n9 +  middleware?: Array<(state: T, action: string) => T>;\n10 +}\n11 +\n12 +export interface StateSnapshot<T> {\n13 +  state: T;\n14 +  timestamp: number;\n15 +  action: string;\n16 +}\n17 +\n18 +function deepMerge<T extends object>(target: T, source: Partial<T>): T {\n19 +  const result = { ...target };\n20 +\n21 +  for (const key in source) {\n22 +    if (source.hasOwnProperty(key)) {\n23 +      const sourceValue = source[key];\n24 +      const targetValue = target[key];\n25 +\n26 +      if (\n27 +        sourceValue !== null &&\n28 +        typeof sourceValue === 'object' &&\n29 +        !Array.isArray(sourceValue) &&\n30 +        targetValue !== null &&\n31 +        typeof targetValue === 'object' &&\n32 +        !Array.isArray(targetValue)\n33 +      ) {\n34 +        (result as any)[key] = deepMerge(targetValue as object, sourceValue as object);\n35 +      } else {\n36 +        (result as any)[key] = sourceValue;\n37 +      }\n38 +    }\n39 +  }\n40 +\n41 +  return result;\n42 +}\n43 +\n44 +function deepClone<T>(obj: T): T {\n45 +  if (obj === null || typeof obj !== 'object') {\n46 +    return obj;\n47 +  }\n48 +\n49 +  if (Array.isArray(obj)) {\n50 +    return obj.map(item => deepClone(item)) as unknown as T;\n51 +  }\n52 +\n53 +  const cloned = {} as T;\n54 +  for (const key in obj) {\n55 +    if (obj.hasOwnProperty(key)) {\n56 +      (cloned as any)[key] = deepClone(obj[key]);\n57 +    }\n58 +  }\n59 +  return cloned;\n60 +}\n61 +\n62 +export class StateManager<T extends object> {\n63 +  private state: T;\n64 +  private listeners: Set<StateListener<T>> = new Set();\n65 +  private history: StateSnapshot<T>[] = [];\n66 +  private maxHistoryLength = 50;\n67 +  private options: StateManagerOptions<T>;\n68 +\n69 +  constructor(options: StateManagerOptions<T>) {\n70 +    this.options = options;\n71 +    this.state = this.loadPersistedState() || deepClone(options.initialState);\n72 +    this.saveSnapshot('init');\n73 +  }\n74 +\n75 +  private loadPersistedState(): T | null {\n76 +    if (!this.options.persist || !this.options.storageKey) {\n77 +      return null;\n78 +    }\n79 +\n80 +    try {\n81 +      const stored = localStorage.getItem(this.options.storageKey);\n82 +      if (stored) {\n83 +        return JSON.parse(stored);\n84 +      }\n85 +    } catch (error) {\n86 +      console.warn('Failed to load persisted state:', error);\n87 +    }\n88 +\n89 +    return null;\n90 +  }\n91 +\n92 +  private persistState(): void {\n93 +    if (!this.options.persist || !this.options.storageKey) {\n94 +      return;\n95 +    }\n96 +\n97 +    try {\n98 +      localStorage.setItem(this.options.storageKey, JSON.stringify(this.state));\n99 +    } catch (error) {\n100 +      console.warn('Failed to persist state:', error);\n101 +    }\n102 +  }\n103 +\n104 +  private saveSnapshot(action: string): void {\n105 +    this.history.push({\n106 +      state: deepClone(this.state),\n107 +      timestamp: Date.now(),\n108 +      action,\n109 +    });\n110 +\n111 +    if (this.history.length > this.maxHistoryLength) {\n112 +      this.history.shift();\n113 +    }\n114 +  }\n115 +\n116 +  private notifyListeners(prevState: T): void {\n117 +    this.listeners.forEach(listener => {\n118 +      listener(this.state, prevState);\n119 +    });\n120 +  }\n121 +\n122 +  getState(): T {\n123 +    return this.state;\n124 +  }\n125 +\n126 +  setState(updater: StateUpdater<T> | Partial<T>, action = 'setState'): void {\n127 +    const prevState = this.state;\n128 +    const updates = typeof updater === 'function' ? updater(this.state) : updater;\n129 +\n130 +    this.state = deepMerge(this.state, updates);\n131 +\n132 +    if (this.options.middleware) {\n133 +      for (const mw of this.options.middleware) {\n134 +        this.state = mw(this.state, action);\n135 +      }\n136 +    }\n137 +\n138 +    this.saveSnapshot(action);\n139 +    this.persistState();\n140 +    this.notifyListeners(prevState);\n141 +  }\n142 +\n143 +  subscribe(listener: StateListener<T>): () => void {\n144 +    this.listeners.add(listener);\n145 +    return () => this.listeners.delete(listener);\n146 +  }\n147 +\n148 +  select<R>(selector: StateSelector<T, R>): R {\n149 +    return selector(this.state);\n150 +  }\n151 +\n152 +  undo(): boolean {\n153 +    if (this.history.length < 2) {\n154 +      return false;\n155 +    }\n156 +\n157 +    this.history.pop(); // Remove current state\n158 +    const previousSnapshot = this.history[this.history.length - 1];\n159 +\n160 +    if (previousSnapshot) {\n161 +      const prevState = this.state;\n162 +      this.state = deepClone(previousSnapshot.state);\n163 +      this.persistState();\n164 +      this.notifyListeners(prevState);\n165 +      return true;\n166 +    }\n167 +\n168 +    return false;\n169 +  }\n170 +\n171 +  getHistory(): StateSnapshot<T>[] {\n172 +    return [...this.history];\n173 +  }\n174 +\n175 +  importState(serialized: string): void {\n176 +    const imported = JSON.parse(serialized);\n177 +    this.setState(imported, 'import');\n178 +  }\n179 +\n180 +  exportState(): string {\n181 +    return JSON.stringify(this.state);\n182 +  }\n183 +\n184 +  reset(): void {\n185 +    const prevState = this.state;\n186 +    this.state = deepClone(this.options.initialState);\n187 +    this.history = [];\n188 +    this.saveSnapshot('reset');\n189 +    this.persistState();\n190 +    this.notifyListeners(prevState);\n191 +  }\n192 +}\n193 +\n194 +export function createStateManager<T extends object>(\n195 +  options: StateManagerOptions<T>\n196 +): StateManager<T> {\n197 +  return new StateManager(options);\n198 +}\n199 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/state/src/store/StateManager.ts\",\"relevantLinesStart\":20,\"relevantLinesEnd\":22},{\"relevantFile\":\"packages/state/src/store/StateManager.ts\",\"relevantLinesStart\":158,\"relevantLinesEnd\":161}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"for (const key in source) {\\n    if (source.hasOwnProperty(key)) {\",\n    \"improvedCode\": \"for (const key in source) {\\n    if (source.hasOwnProperty(key) && key !== '__proto__' && key !== 'constructor' && key !== 'prototype') {\",\n    \"relevantFile\": \"packages/state/src/store/StateManager.ts\",\n    \"relevantLinesEnd\": 22,\n    \"suggestionContent\": \"The `deepMerge` function uses `hasOwnProperty` check but doesn't guard against `__proto__` or `constructor` keys. An attacker can pass `{\\\"__proto__\\\": {\\\"polluted\\\": true}}` as the source object, which will modify `Object.prototype` and affect all objects in the application. This is a prototype pollution vulnerability.\",\n    \"oneSentenceSummary\": \"Prototype pollution vulnerability - deepMerge doesn't sanitize __proto__ keys\",\n    \"relevantLinesStart\": 20\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"importState(serialized: string): void {\\n    const imported = JSON.parse(serialized);\\n    this.setState(imported, 'import');\\n  }\",\n    \"improvedCode\": \"importState(serialized: string, validator?: (state: unknown) => state is Partial<T>): void {\\n    const imported = JSON.parse(serialized);\\n    if (validator && !validator(imported)) {\\n      throw new Error('Invalid state format');\\n    }\\n    // Use Object.assign for flat merge to avoid prototype pollution\\n    this.setState(imported as Partial<T>, 'import');\\n  }\",\n    \"relevantFile\": \"packages/state/src/store/StateManager.ts\",\n    \"relevantLinesEnd\": 161,\n    \"suggestionContent\": \"The `importState` method parses untrusted JSON and passes it directly to `setState`, which uses `deepMerge`. Combined with the prototype pollution in `deepMerge`, an attacker can pollute prototypes by importing malicious state. Also, there's no validation that the imported state matches the expected schema.\",\n    \"oneSentenceSummary\": \"Unsafe deserialization - importState accepts untrusted JSON without validation\",\n    \"relevantLinesStart\": 158\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 15: packages/billing/src/services/InvoiceCalculator.ts",
        "vars": {
          "fileContent": "export interface LineItem {\n  id: string;\n  description: string;\n  quantity: number;\n  unitPrice: number;\n  taxRate: number;\n  discountPercent?: number;\n}\n\nexport interface Invoice {\n  id: string;\n  customerId: string;\n  items: LineItem[];\n  currency: string;\n  issuedAt: Date;\n  dueAt: Date;\n}\n\nexport interface InvoiceTotals {\n  subtotal: number;\n  totalDiscount: number;\n  totalTax: number;\n  grandTotal: number;\n}\n\nexport function calculateLineItemTotal(item: LineItem): number {\n  const baseAmount = item.quantity * item.unitPrice;\n  const discount = item.discountPercent\n    ? baseAmount * (item.discountPercent / 100)\n    : 0;\n  const afterDiscount = baseAmount - discount;\n  const tax = afterDiscount * (item.taxRate / 100);\n  return afterDiscount + tax;\n}\n\nexport function calculateInvoiceTotals(invoice: Invoice): InvoiceTotals {\n  let subtotal = 0;\n  let totalDiscount = 0;\n  let totalTax = 0;\n\n  for (const item of invoice.items) {\n    const baseAmount = item.quantity * item.unitPrice;\n    const discount = item.discountPercent\n      ? baseAmount * (item.discountPercent / 100)\n      : 0;\n    const afterDiscount = baseAmount - discount;\n    const tax = afterDiscount * (item.taxRate / 100);\n\n    subtotal += baseAmount;\n    totalDiscount += discount;\n    totalTax += tax;\n  }\n\n  const grandTotal = subtotal - totalDiscount + totalTax;\n\n  return {\n    subtotal,\n    totalDiscount,\n    totalTax,\n    grandTotal,\n  };\n}\n\nexport function formatCurrency(amount: number, currency: string): string {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency,\n  }).format(amount);\n}\n\nexport function splitPayment(\n  total: number,\n  installments: number\n): number[] {\n  const baseAmount = total / installments;\n  const payments = Array(installments).fill(baseAmount);\n\n  const sum = payments.reduce((a, b) => a + b, 0);\n  const remainder = total - sum;\n\n  if (remainder !== 0) {\n    payments[payments.length - 1] += remainder;\n  }\n\n  return payments;\n}\n\nexport class InvoiceCalculator {\n  calculateTotals(invoice: Invoice): InvoiceTotals {\n    return calculateInvoiceTotals(invoice);\n  }\n\n  calculateMonthlyPayments(\n    invoice: Invoice,\n    months: number\n  ): number[] {\n    const totals = this.calculateTotals(invoice);\n    return splitPayment(totals.grandTotal, months);\n  }\n\n  applyPromoCode(\n    invoice: Invoice,\n    discountPercent: number\n  ): Invoice {\n    return {\n      ...invoice,\n      items: invoice.items.map(item => ({\n        ...item,\n        discountPercent: (item.discountPercent ?? 0) + discountPercent,\n      })),\n    };\n  }\n\n  validateInvoice(invoice: Invoice): string[] {\n    const errors: string[] = [];\n\n    if (invoice.items.length === 0) {\n      errors.push('Invoice must have at least one line item');\n    }\n\n    for (const item of invoice.items) {\n      if (item.quantity <= 0) {\n        errors.push(`Item ${item.id}: quantity must be positive`);\n      }\n      if (item.unitPrice < 0) {\n        errors.push(`Item ${item.id}: unit price cannot be negative`);\n      }\n      if (item.taxRate < 0 || item.taxRate > 100) {\n        errors.push(`Item ${item.id}: tax rate must be between 0 and 100`);\n      }\n    }\n\n    return errors;\n  }\n}\n\nexport default InvoiceCalculator;\n",
          "patchWithLinesStr": "## file: 'packages/billing/src/services/InvoiceCalculator.ts'\n\n@@ -0,0 +1,138 @@\n__new hunk__\n1 +export interface LineItem {\n2 +  id: string;\n3 +  description: string;\n4 +  quantity: number;\n5 +  unitPrice: number;\n6 +  taxRate: number;\n7 +  discountPercent?: number;\n8 +}\n9 +\n10 +export interface Invoice {\n11 +  id: string;\n12 +  customerId: string;\n13 +  items: LineItem[];\n14 +  currency: string;\n15 +  issuedAt: Date;\n16 +  dueAt: Date;\n17 +}\n18 +\n19 +export interface InvoiceTotals {\n20 +  subtotal: number;\n21 +  totalDiscount: number;\n22 +  totalTax: number;\n23 +  grandTotal: number;\n24 +}\n25 +\n26 +export function calculateLineItemTotal(item: LineItem): number {\n27 +  const baseAmount = item.quantity * item.unitPrice;\n28 +  const discount = item.discountPercent\n29 +    ? baseAmount * (item.discountPercent / 100)\n30 +    : 0;\n31 +  const afterDiscount = baseAmount - discount;\n32 +  const tax = afterDiscount * (item.taxRate / 100);\n33 +  return afterDiscount + tax;\n34 +}\n35 +\n36 +export function calculateInvoiceTotals(invoice: Invoice): InvoiceTotals {\n37 +  let subtotal = 0;\n38 +  let totalDiscount = 0;\n39 +  let totalTax = 0;\n40 +\n41 +  for (const item of invoice.items) {\n42 +    const baseAmount = item.quantity * item.unitPrice;\n43 +    const discount = item.discountPercent\n44 +      ? baseAmount * (item.discountPercent / 100)\n45 +      : 0;\n46 +    const afterDiscount = baseAmount - discount;\n47 +    const tax = afterDiscount * (item.taxRate / 100);\n48 +\n49 +    subtotal += baseAmount;\n50 +    totalDiscount += discount;\n51 +    totalTax += tax;\n52 +  }\n53 +\n54 +  const grandTotal = subtotal - totalDiscount + totalTax;\n55 +\n56 +  return {\n57 +    subtotal,\n58 +    totalDiscount,\n59 +    totalTax,\n60 +    grandTotal,\n61 +  };\n62 +}\n63 +\n64 +export function formatCurrency(amount: number, currency: string): string {\n65 +  return new Intl.NumberFormat('en-US', {\n66 +    style: 'currency',\n67 +    currency,\n68 +  }).format(amount);\n69 +}\n70 +\n71 +export function splitPayment(\n72 +  total: number,\n73 +  installments: number\n74 +): number[] {\n75 +  const baseAmount = total / installments;\n76 +  const payments = Array(installments).fill(baseAmount);\n77 +\n78 +  const sum = payments.reduce((a, b) => a + b, 0);\n79 +  const remainder = total - sum;\n80 +\n81 +  if (remainder !== 0) {\n82 +    payments[payments.length - 1] += remainder;\n83 +  }\n84 +\n85 +  return payments;\n86 +}\n87 +\n88 +export class InvoiceCalculator {\n89 +  calculateTotals(invoice: Invoice): InvoiceTotals {\n90 +    return calculateInvoiceTotals(invoice);\n91 +  }\n92 +\n93 +  calculateMonthlyPayments(\n94 +    invoice: Invoice,\n95 +    months: number\n96 +  ): number[] {\n97 +    const totals = this.calculateTotals(invoice);\n98 +    return splitPayment(totals.grandTotal, months);\n99 +  }\n100 +\n101 +  applyPromoCode(\n102 +    invoice: Invoice,\n103 +    discountPercent: number\n104 +  ): Invoice {\n105 +    return {\n106 +      ...invoice,\n107 +      items: invoice.items.map(item => ({\n108 +        ...item,\n109 +        discountPercent: (item.discountPercent ?? 0) + discountPercent,\n110 +      })),\n111 +    };\n112 +  }\n113 +\n114 +  validateInvoice(invoice: Invoice): string[] {\n115 +    const errors: string[] = [];\n116 +\n117 +    if (invoice.items.length === 0) {\n118 +      errors.push('Invoice must have at least one line item');\n119 +    }\n120 +\n121 +    for (const item of invoice.items) {\n122 +      if (item.quantity <= 0) {\n123 +        errors.push(`Item ${item.id}: quantity must be positive`);\n124 +      }\n125 +      if (item.unitPrice < 0) {\n126 +        errors.push(`Item ${item.id}: unit price cannot be negative`);\n127 +      }\n128 +      if (item.taxRate < 0 || item.taxRate > 100) {\n129 +        errors.push(`Item ${item.id}: tax rate must be between 0 and 100`);\n130 +      }\n131 +    }\n132 +\n133 +    return errors;\n134 +  }\n135 +}\n136 +\n137 +export default InvoiceCalculator;\n138 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/billing/src/services/InvoiceCalculator.ts\",\"relevantLinesStart\":40,\"relevantLinesEnd\":47}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"const baseAmount = item.quantity * item.unitPrice;\\n    const discount = item.discountPercent\\n      ? baseAmount * (item.discountPercent / 100)\\n      : 0;\\n    const afterDiscount = baseAmount - discount;\\n    const tax = afterDiscount * (item.taxRate / 100);\",\n    \"improvedCode\": \"const baseAmount = Math.round(item.quantity * item.unitPrice * 100) / 100;\\n    const discount = item.discountPercent\\n      ? Math.round(baseAmount * (item.discountPercent / 100) * 100) / 100\\n      : 0;\\n    const afterDiscount = Math.round((baseAmount - discount) * 100) / 100;\\n    const tax = Math.round(afterDiscount * (item.taxRate / 100) * 100) / 100;\",\n    \"relevantFile\": \"packages/billing/src/services/InvoiceCalculator.ts\",\n    \"relevantLinesEnd\": 47,\n    \"suggestionContent\": \"Financial calculations using floating point arithmetic will accumulate precision errors. For example, `0.1 + 0.2 = 0.30000000000000004` in JavaScript. When calculating invoice totals with multiple line items, these errors compound and can result in incorrect totals (e.g., $99.99999999 instead of $100.00). Use integer arithmetic with cents, a decimal library like decimal.js, or round intermediate results to avoid displaying incorrect amounts to customers.\",\n    \"oneSentenceSummary\": \"Floating point arithmetic in financial calculations causes precision errors\",\n    \"relevantLinesStart\": 40\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 16: packages/events/src/emitter/TypedEventEmitter.ts",
        "vars": {
          "fileContent": "export type EventCallback<T = unknown> = (data: T) => void | Promise<void>;\nexport type UnsubscribeFn = () => void;\n\ninterface EventSubscription<T> {\n  callback: EventCallback<T>;\n  once: boolean;\n  priority: number;\n}\n\nexport class TypedEventEmitter<TEvents extends Record<string, unknown>> {\n  private listeners: Map<keyof TEvents, EventSubscription<any>[]> = new Map();\n  private maxListeners = 10;\n  private eventHistory: Map<keyof TEvents, unknown[]> = new Map();\n  private historySize = 100;\n\n  setMaxListeners(n: number): this {\n    this.maxListeners = n;\n    return this;\n  }\n\n  on<K extends keyof TEvents>(\n    event: K,\n    callback: EventCallback<TEvents[K]>,\n    priority = 0\n  ): UnsubscribeFn {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n\n    const subscriptions = this.listeners.get(event)!;\n\n    if (subscriptions.length >= this.maxListeners) {\n      console.warn(\n        `MaxListenersExceededWarning: Possible memory leak detected. ` +\n        `${subscriptions.length + 1} listeners added for event \"${String(event)}\".`\n      );\n    }\n\n    subscriptions.push({ callback, once: false, priority });\n    subscriptions.sort((a, b) => b.priority - a.priority);\n\n    return () => this.off(event, callback);\n  }\n\n  once<K extends keyof TEvents>(\n    event: K,\n    callback: EventCallback<TEvents[K]>,\n    priority = 0\n  ): UnsubscribeFn {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n\n    const subscriptions = this.listeners.get(event)!;\n    subscriptions.push({ callback, once: true, priority });\n    subscriptions.sort((a, b) => b.priority - a.priority);\n\n    return () => this.off(event, callback);\n  }\n\n  off<K extends keyof TEvents>(\n    event: K,\n    callback: EventCallback<TEvents[K]>\n  ): this {\n    const subscriptions = this.listeners.get(event);\n    if (!subscriptions) return this;\n\n    const index = subscriptions.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n      subscriptions.splice(index, 1);\n    }\n\n    return this;\n  }\n\n  emit<K extends keyof TEvents>(event: K, data: TEvents[K]): this {\n    this.recordHistory(event, data);\n\n    const subscriptions = this.listeners.get(event);\n    if (!subscriptions) return this;\n\n    const toRemove: EventSubscription<TEvents[K]>[] = [];\n\n    for (const sub of subscriptions) {\n      sub.callback(data);\n\n      if (sub.once) {\n        toRemove.push(sub);\n      }\n    }\n\n    for (const sub of toRemove) {\n      const index = subscriptions.indexOf(sub);\n      if (index !== -1) {\n        subscriptions.splice(index, 1);\n      }\n    }\n\n    return this;\n  }\n\n  async emitAsync<K extends keyof TEvents>(\n    event: K,\n    data: TEvents[K]\n  ): Promise<void> {\n    this.recordHistory(event, data);\n\n    const subscriptions = this.listeners.get(event);\n    if (!subscriptions) return;\n\n    for (const sub of subscriptions) {\n      await sub.callback(data);\n\n      if (sub.once) {\n        this.off(event, sub.callback);\n      }\n    }\n  }\n\n  private recordHistory<K extends keyof TEvents>(event: K, data: TEvents[K]): void {\n    if (!this.eventHistory.has(event)) {\n      this.eventHistory.set(event, []);\n    }\n\n    const history = this.eventHistory.get(event)!;\n    history.push(data);\n\n    if (history.length > this.historySize) {\n      history.shift();\n    }\n  }\n\n  getHistory<K extends keyof TEvents>(event: K): TEvents[K][] {\n    return (this.eventHistory.get(event) as TEvents[K][]) || [];\n  }\n\n  listenerCount<K extends keyof TEvents>(event: K): number {\n    return this.listeners.get(event)?.length ?? 0;\n  }\n\n  removeAllListeners<K extends keyof TEvents>(event?: K): this {\n    if (event) {\n      this.listeners.delete(event);\n    } else {\n      this.listeners.clear();\n    }\n    return this;\n  }\n\n  eventNames(): (keyof TEvents)[] {\n    return Array.from(this.listeners.keys());\n  }\n}\n\nexport function createEventEmitter<TEvents extends Record<string, unknown>>(): TypedEventEmitter<TEvents> {\n  return new TypedEventEmitter<TEvents>();\n}\n",
          "patchWithLinesStr": "## file: 'packages/events/src/emitter/TypedEventEmitter.ts'\n\n@@ -0,0 +1,158 @@\n__new hunk__\n1 +export type EventCallback<T = unknown> = (data: T) => void | Promise<void>;\n2 +export type UnsubscribeFn = () => void;\n3 +\n4 +interface EventSubscription<T> {\n5 +  callback: EventCallback<T>;\n6 +  once: boolean;\n7 +  priority: number;\n8 +}\n9 +\n10 +export class TypedEventEmitter<TEvents extends Record<string, unknown>> {\n11 +  private listeners: Map<keyof TEvents, EventSubscription<any>[]> = new Map();\n12 +  private maxListeners = 10;\n13 +  private eventHistory: Map<keyof TEvents, unknown[]> = new Map();\n14 +  private historySize = 100;\n15 +\n16 +  setMaxListeners(n: number): this {\n17 +    this.maxListeners = n;\n18 +    return this;\n19 +  }\n20 +\n21 +  on<K extends keyof TEvents>(\n22 +    event: K,\n23 +    callback: EventCallback<TEvents[K]>,\n24 +    priority = 0\n25 +  ): UnsubscribeFn {\n26 +    if (!this.listeners.has(event)) {\n27 +      this.listeners.set(event, []);\n28 +    }\n29 +\n30 +    const subscriptions = this.listeners.get(event)!;\n31 +\n32 +    if (subscriptions.length >= this.maxListeners) {\n33 +      console.warn(\n34 +        `MaxListenersExceededWarning: Possible memory leak detected. ` +\n35 +        `${subscriptions.length + 1} listeners added for event \"${String(event)}\".`\n36 +      );\n37 +    }\n38 +\n39 +    subscriptions.push({ callback, once: false, priority });\n40 +    subscriptions.sort((a, b) => b.priority - a.priority);\n41 +\n42 +    return () => this.off(event, callback);\n43 +  }\n44 +\n45 +  once<K extends keyof TEvents>(\n46 +    event: K,\n47 +    callback: EventCallback<TEvents[K]>,\n48 +    priority = 0\n49 +  ): UnsubscribeFn {\n50 +    if (!this.listeners.has(event)) {\n51 +      this.listeners.set(event, []);\n52 +    }\n53 +\n54 +    const subscriptions = this.listeners.get(event)!;\n55 +    subscriptions.push({ callback, once: true, priority });\n56 +    subscriptions.sort((a, b) => b.priority - a.priority);\n57 +\n58 +    return () => this.off(event, callback);\n59 +  }\n60 +\n61 +  off<K extends keyof TEvents>(\n62 +    event: K,\n63 +    callback: EventCallback<TEvents[K]>\n64 +  ): this {\n65 +    const subscriptions = this.listeners.get(event);\n66 +    if (!subscriptions) return this;\n67 +\n68 +    const index = subscriptions.findIndex(sub => sub.callback === callback);\n69 +    if (index !== -1) {\n70 +      subscriptions.splice(index, 1);\n71 +    }\n72 +\n73 +    return this;\n74 +  }\n75 +\n76 +  emit<K extends keyof TEvents>(event: K, data: TEvents[K]): this {\n77 +    this.recordHistory(event, data);\n78 +\n79 +    const subscriptions = this.listeners.get(event);\n80 +    if (!subscriptions) return this;\n81 +\n82 +    const toRemove: EventSubscription<TEvents[K]>[] = [];\n83 +\n84 +    for (const sub of subscriptions) {\n85 +      sub.callback(data);\n86 +\n87 +      if (sub.once) {\n88 +        toRemove.push(sub);\n89 +      }\n90 +    }\n91 +\n92 +    for (const sub of toRemove) {\n93 +      const index = subscriptions.indexOf(sub);\n94 +      if (index !== -1) {\n95 +        subscriptions.splice(index, 1);\n96 +      }\n97 +    }\n98 +\n99 +    return this;\n100 +  }\n101 +\n102 +  async emitAsync<K extends keyof TEvents>(\n103 +    event: K,\n104 +    data: TEvents[K]\n105 +  ): Promise<void> {\n106 +    this.recordHistory(event, data);\n107 +\n108 +    const subscriptions = this.listeners.get(event);\n109 +    if (!subscriptions) return;\n110 +\n111 +    for (const sub of subscriptions) {\n112 +      await sub.callback(data);\n113 +\n114 +      if (sub.once) {\n115 +        this.off(event, sub.callback);\n116 +      }\n117 +    }\n118 +  }\n119 +\n120 +  private recordHistory<K extends keyof TEvents>(event: K, data: TEvents[K]): void {\n121 +    if (!this.eventHistory.has(event)) {\n122 +      this.eventHistory.set(event, []);\n123 +    }\n124 +\n125 +    const history = this.eventHistory.get(event)!;\n126 +    history.push(data);\n127 +\n128 +    if (history.length > this.historySize) {\n129 +      history.shift();\n130 +    }\n131 +  }\n132 +\n133 +  getHistory<K extends keyof TEvents>(event: K): TEvents[K][] {\n134 +    return (this.eventHistory.get(event) as TEvents[K][]) || [];\n135 +  }\n136 +\n137 +  listenerCount<K extends keyof TEvents>(event: K): number {\n138 +    return this.listeners.get(event)?.length ?? 0;\n139 +  }\n140 +\n141 +  removeAllListeners<K extends keyof TEvents>(event?: K): this {\n142 +    if (event) {\n143 +      this.listeners.delete(event);\n144 +    } else {\n145 +      this.listeners.clear();\n146 +    }\n147 +    return this;\n148 +  }\n149 +\n150 +  eventNames(): (keyof TEvents)[] {\n151 +    return Array.from(this.listeners.keys());\n152 +  }\n153 +}\n154 +\n155 +export function createEventEmitter<TEvents extends Record<string, unknown>>(): TypedEventEmitter<TEvents> {\n156 +  return new TypedEventEmitter<TEvents>();\n157 +}\n158 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/events/src/emitter/TypedEventEmitter.ts\",\"relevantLinesStart\":74,\"relevantLinesEnd\":88}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"for (const sub of subscriptions) {\\n      sub.callback(data);\\n\\n      if (sub.once) {\\n        toRemove.push(sub);\\n      }\\n    }\\n\\n    for (const sub of toRemove) {\\n      const index = subscriptions.indexOf(sub);\\n      if (index !== -1) {\\n        subscriptions.splice(index, 1);\\n      }\\n    }\",\n    \"improvedCode\": \"const toExecute = [...subscriptions];\\n    \\n    for (const sub of toExecute) {\\n      sub.callback(data);\\n\\n      if (sub.once) {\\n        const index = subscriptions.indexOf(sub);\\n        if (index !== -1) {\\n          subscriptions.splice(index, 1);\\n        }\\n      }\\n    }\",\n    \"relevantFile\": \"packages/events/src/emitter/TypedEventEmitter.ts\",\n    \"relevantLinesEnd\": 88,\n    \"suggestionContent\": \"In the `emit` method, the code iterates over `subscriptions` array while also modifying it (removing 'once' listeners via splice). This causes items to be skipped when iterating. For example, if subscriptions[0] is a 'once' listener and gets removed, subscriptions[1] shifts to index 0, but the loop continues to index 1, skipping what was originally subscriptions[1].\",\n    \"oneSentenceSummary\": \"Iterating and splicing same array causes listeners to be skipped\",\n    \"relevantLinesStart\": 74\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 17: packages/dom/src/observers/ResizeObserverManager.ts",
        "vars": {
          "fileContent": "type ResizeCallback = (entry: ResizeObserverEntry) => void;\n\ninterface ObservedElement {\n  element: Element;\n  callback: ResizeCallback;\n}\n\nexport class ResizeObserverManager {\n  private observer: ResizeObserver;\n  private observedElements: Map<Element, ResizeCallback> = new Map();\n  private isInitialized = false;\n\n  constructor() {\n    this.observer = new ResizeObserver(this.handleResize.bind(this));\n    this.isInitialized = true;\n  }\n\n  private handleResize(entries: ResizeObserverEntry[]): void {\n    for (const entry of entries) {\n      const callback = this.observedElements.get(entry.target);\n      if (callback) {\n        try {\n          callback(entry);\n        } catch (error) {\n          console.error('Resize callback error:', error);\n        }\n      }\n    }\n  }\n\n  observe(element: Element, callback: ResizeCallback): void {\n    if (!this.isInitialized) {\n      throw new Error('ResizeObserverManager not initialized');\n    }\n\n    if (this.observedElements.has(element)) {\n      console.warn('Element already being observed, updating callback');\n    }\n\n    this.observedElements.set(element, callback);\n    this.observer.observe(element);\n  }\n\n  unobserve(element: Element): void {\n    this.observer.unobserve(element);\n    this.observedElements.delete(element);\n  }\n\n  disconnect(): void {\n    this.observer.disconnect();\n    this.observedElements.clear();\n  }\n\n  isObserving(element: Element): boolean {\n    return this.observedElements.has(element);\n  }\n}\n\nexport function useResizeObserver(\n  elementRef: { current: Element | null },\n  callback: ResizeCallback\n): void {\n  const manager = getGlobalManager();\n\n  if (elementRef.current) {\n    manager.observe(elementRef.current, callback);\n  }\n\n  return () => {\n    if (elementRef.current) {\n      manager.unobserve(elementRef.current);\n    }\n  };\n}\n\nlet globalManager: ResizeObserverManager | null = null;\n\nfunction getGlobalManager(): ResizeObserverManager {\n  if (!globalManager) {\n    globalManager = new ResizeObserverManager();\n  }\n  return globalManager;\n}\n\nexport class ElementResizeWatcher {\n  private cleanup: (() => void) | null = null;\n\n  watch(element: Element, onResize: ResizeCallback): void {\n    const manager = getGlobalManager();\n    manager.observe(element, onResize);\n\n    this.cleanup = () => {\n      manager.unobserve(element);\n    };\n\n    window.addEventListener('beforeunload', this.cleanup.bind(this));\n  }\n\n  unwatch(): void {\n    if (this.cleanup) {\n      this.cleanup();\n      this.cleanup = null;\n    }\n  }\n\n  destroy(): void {\n    this.unwatch();\n    window.removeEventListener('beforeunload', this.cleanup?.bind(this) as EventListener);\n  }\n}\n\nexport default ResizeObserverManager;\n",
          "patchWithLinesStr": "## file: 'packages/dom/src/observers/ResizeObserverManager.ts'\n\n@@ -0,0 +1,113 @@\n__new hunk__\n1 +type ResizeCallback = (entry: ResizeObserverEntry) => void;\n2 +\n3 +interface ObservedElement {\n4 +  element: Element;\n5 +  callback: ResizeCallback;\n6 +}\n7 +\n8 +export class ResizeObserverManager {\n9 +  private observer: ResizeObserver;\n10 +  private observedElements: Map<Element, ResizeCallback> = new Map();\n11 +  private isInitialized = false;\n12 +\n13 +  constructor() {\n14 +    this.observer = new ResizeObserver(this.handleResize.bind(this));\n15 +    this.isInitialized = true;\n16 +  }\n17 +\n18 +  private handleResize(entries: ResizeObserverEntry[]): void {\n19 +    for (const entry of entries) {\n20 +      const callback = this.observedElements.get(entry.target);\n21 +      if (callback) {\n22 +        try {\n23 +          callback(entry);\n24 +        } catch (error) {\n25 +          console.error('Resize callback error:', error);\n26 +        }\n27 +      }\n28 +    }\n29 +  }\n30 +\n31 +  observe(element: Element, callback: ResizeCallback): void {\n32 +    if (!this.isInitialized) {\n33 +      throw new Error('ResizeObserverManager not initialized');\n34 +    }\n35 +\n36 +    if (this.observedElements.has(element)) {\n37 +      console.warn('Element already being observed, updating callback');\n38 +    }\n39 +\n40 +    this.observedElements.set(element, callback);\n41 +    this.observer.observe(element);\n42 +  }\n43 +\n44 +  unobserve(element: Element): void {\n45 +    this.observer.unobserve(element);\n46 +    this.observedElements.delete(element);\n47 +  }\n48 +\n49 +  disconnect(): void {\n50 +    this.observer.disconnect();\n51 +    this.observedElements.clear();\n52 +  }\n53 +\n54 +  isObserving(element: Element): boolean {\n55 +    return this.observedElements.has(element);\n56 +  }\n57 +}\n58 +\n59 +export function useResizeObserver(\n60 +  elementRef: { current: Element | null },\n61 +  callback: ResizeCallback\n62 +): void {\n63 +  const manager = getGlobalManager();\n64 +\n65 +  if (elementRef.current) {\n66 +    manager.observe(elementRef.current, callback);\n67 +  }\n68 +\n69 +  return () => {\n70 +    if (elementRef.current) {\n71 +      manager.unobserve(elementRef.current);\n72 +    }\n73 +  };\n74 +}\n75 +\n76 +let globalManager: ResizeObserverManager | null = null;\n77 +\n78 +function getGlobalManager(): ResizeObserverManager {\n79 +  if (!globalManager) {\n80 +    globalManager = new ResizeObserverManager();\n81 +  }\n82 +  return globalManager;\n83 +}\n84 +\n85 +export class ElementResizeWatcher {\n86 +  private cleanup: (() => void) | null = null;\n87 +\n88 +  watch(element: Element, onResize: ResizeCallback): void {\n89 +    const manager = getGlobalManager();\n90 +    manager.observe(element, onResize);\n91 +\n92 +    this.cleanup = () => {\n93 +      manager.unobserve(element);\n94 +    };\n95 +\n96 +    window.addEventListener('beforeunload', this.cleanup.bind(this));\n97 +  }\n98 +\n99 +  unwatch(): void {\n100 +    if (this.cleanup) {\n101 +      this.cleanup();\n102 +      this.cleanup = null;\n103 +    }\n104 +  }\n105 +\n106 +  destroy(): void {\n107 +    this.unwatch();\n108 +    window.removeEventListener('beforeunload', this.cleanup?.bind(this) as EventListener);\n109 +  }\n110 +}\n111 +\n112 +export default ResizeObserverManager;\n113 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/dom/src/observers/ResizeObserverManager.ts\",\"relevantLinesStart\":89,\"relevantLinesEnd\":100}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"window.addEventListener('beforeunload', this.cleanup.bind(this));\\n  }\\n\\n  unwatch(): void {\\n    if (this.cleanup) {\\n      this.cleanup();\\n      this.cleanup = null;\\n    }\\n  }\\n\\n  destroy(): void {\\n    this.unwatch();\\n    window.removeEventListener('beforeunload', this.cleanup?.bind(this) as EventListener);\\n  }\",\n    \"improvedCode\": \"private boundCleanup: (() => void) | null = null;\\n\\n  watch(element: Element, onResize: ResizeCallback): void {\\n    // ... existing code ...\\n    this.boundCleanup = this.cleanup.bind(this);\\n    window.addEventListener('beforeunload', this.boundCleanup);\\n  }\\n\\n  destroy(): void {\\n    this.unwatch();\\n    if (this.boundCleanup) {\\n      window.removeEventListener('beforeunload', this.boundCleanup);\\n      this.boundCleanup = null;\\n    }\\n  }\",\n    \"relevantFile\": \"packages/dom/src/observers/ResizeObserverManager.ts\",\n    \"relevantLinesEnd\": 100,\n    \"suggestionContent\": \"In the `destroy` method, `removeEventListener` is called with `this.cleanup?.bind(this)` which creates a new function reference. Since `bind()` always creates a new function, this will never match the function added in `watch()` (which used a different `.bind(this)` call). The event listener will never be removed, causing a memory leak. Store the bound function reference and use the same reference for both `addEventListener` and `removeEventListener`.\",\n    \"oneSentenceSummary\": \"bind() creates new function reference - removeEventListener never matches addEventListener\",\n    \"relevantLinesStart\": 89\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 18: packages/ui/src/components/InfiniteScroll.tsx",
        "vars": {
          "fileContent": "import React, { useEffect, useRef, useState, useCallback } from 'react';\n\ninterface InfiniteScrollProps {\n  onLoadMore: () => Promise<void>;\n  hasMore: boolean;\n  threshold?: number;\n  children: React.ReactNode;\n  loader?: React.ReactNode;\n}\n\ninterface ScrollState {\n  isLoading: boolean;\n  error: Error | null;\n  page: number;\n}\n\nexport function InfiniteScroll({\n  onLoadMore,\n  hasMore,\n  threshold = 200,\n  children,\n  loader = <div className=\"loading\">Loading...</div>,\n}: InfiniteScrollProps) {\n  const [state, setState] = useState<ScrollState>({\n    isLoading: false,\n    error: null,\n    page: 1,\n  });\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const loadingRef = useRef(false);\n\n  const handleScroll = useCallback(() => {\n    const container = containerRef.current;\n    if (!container || loadingRef.current || !hasMore) return;\n\n    const { scrollTop, scrollHeight, clientHeight } = container;\n    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;\n\n    if (distanceFromBottom < threshold) {\n      loadingRef.current = true;\n      setState(prev => ({ ...prev, isLoading: true }));\n\n      onLoadMore()\n        .then(() => {\n          setState(prev => ({\n            ...prev,\n            isLoading: false,\n            page: prev.page + 1,\n          }));\n        })\n        .catch((error) => {\n          setState(prev => ({\n            ...prev,\n            isLoading: false,\n            error,\n          }));\n        })\n        .finally(() => {\n          loadingRef.current = false;\n        });\n    }\n  }, [threshold, onLoadMore]);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    container.addEventListener('scroll', handleScroll);\n    return () => container.removeEventListener('scroll', handleScroll);\n  }, [handleScroll]);\n\n  useEffect(() => {\n    handleScroll();\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"infinite-scroll-container\"\n      style={ { overflow: 'auto', height: '100%' } }\n    >\n      {children}\n      {state.isLoading && loader}\n      {state.error && (\n        <div className=\"error\">\n          Failed to load: {state.error.message}\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default InfiniteScroll;\n",
          "patchWithLinesStr": "## file: 'packages/ui/src/components/InfiniteScroll.tsx'\n\n@@ -0,0 +1,95 @@\n__new hunk__\n1 +import React, { useEffect, useRef, useState, useCallback } from 'react';\n2 +\n3 +interface InfiniteScrollProps {\n4 +  onLoadMore: () => Promise<void>;\n5 +  hasMore: boolean;\n6 +  threshold?: number;\n7 +  children: React.ReactNode;\n8 +  loader?: React.ReactNode;\n9 +}\n10 +\n11 +interface ScrollState {\n12 +  isLoading: boolean;\n13 +  error: Error | null;\n14 +  page: number;\n15 +}\n16 +\n17 +export function InfiniteScroll({\n18 +  onLoadMore,\n19 +  hasMore,\n20 +  threshold = 200,\n21 +  children,\n22 +  loader = <div className=\"loading\">Loading...</div>,\n23 +}: InfiniteScrollProps) {\n24 +  const [state, setState] = useState<ScrollState>({\n25 +    isLoading: false,\n26 +    error: null,\n27 +    page: 1,\n28 +  });\n29 +\n30 +  const containerRef = useRef<HTMLDivElement>(null);\n31 +  const loadingRef = useRef(false);\n32 +\n33 +  const handleScroll = useCallback(() => {\n34 +    const container = containerRef.current;\n35 +    if (!container || loadingRef.current || !hasMore) return;\n36 +\n37 +    const { scrollTop, scrollHeight, clientHeight } = container;\n38 +    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;\n39 +\n40 +    if (distanceFromBottom < threshold) {\n41 +      loadingRef.current = true;\n42 +      setState(prev => ({ ...prev, isLoading: true }));\n43 +\n44 +      onLoadMore()\n45 +        .then(() => {\n46 +          setState(prev => ({\n47 +            ...prev,\n48 +            isLoading: false,\n49 +            page: prev.page + 1,\n50 +          }));\n51 +        })\n52 +        .catch((error) => {\n53 +          setState(prev => ({\n54 +            ...prev,\n55 +            isLoading: false,\n56 +            error,\n57 +          }));\n58 +        })\n59 +        .finally(() => {\n60 +          loadingRef.current = false;\n61 +        });\n62 +    }\n63 +  }, [threshold, onLoadMore]);\n64 +\n65 +  useEffect(() => {\n66 +    const container = containerRef.current;\n67 +    if (!container) return;\n68 +\n69 +    container.addEventListener('scroll', handleScroll);\n70 +    return () => container.removeEventListener('scroll', handleScroll);\n71 +  }, [handleScroll]);\n72 +\n73 +  useEffect(() => {\n74 +    handleScroll();\n75 +  }, []);\n76 +\n77 +  return (\n78 +    <div\n79 +      ref={containerRef}\n80 +      className=\"infinite-scroll-container\"\n81 +      style={ { overflow: 'auto', height: '100%' } }\n82 +    >\n83 +      {children}\n84 +      {state.isLoading && loader}\n85 +      {state.error && (\n86 +        <div className=\"error\">\n87 +          Failed to load: {state.error.message}\n88 +        </div>\n89 +      )}\n90 +    </div>\n91 +  );\n92 +}\n93 +\n94 +export default InfiniteScroll;\n95 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/ui/src/components/InfiniteScroll.tsx\",\"relevantLinesStart\":31,\"relevantLinesEnd\":56}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"const handleScroll = useCallback(() => {\\n    const container = containerRef.current;\\n    if (!container || loadingRef.current || !hasMore) return;\",\n    \"improvedCode\": \"const handleScroll = useCallback(() => {\\n    const container = containerRef.current;\\n    if (!container || loadingRef.current || !hasMore) return;\",\n    \"relevantFile\": \"packages/ui/src/components/InfiniteScroll.tsx\",\n    \"relevantLinesEnd\": 56,\n    \"suggestionContent\": \"The `handleScroll` callback has `hasMore` in its closure but `hasMore` is not included in the dependency array. When `hasMore` changes to `false`, the callback still uses the stale `true` value, causing unnecessary load attempts. Additionally, the initial scroll check in useEffect on line 68 has an empty dependency array but calls `handleScroll` which may not be the latest version.\",\n    \"oneSentenceSummary\": \"useCallback missing hasMore dependency causes stale closure bug\",\n    \"relevantLinesStart\": 31\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 19: packages/upload/src/handlers/FileUploadHandler.ts",
        "vars": {
          "fileContent": "import * as path from 'path';\nimport * as fs from 'fs/promises';\nimport * as crypto from 'crypto';\n\nexport interface UploadConfig {\n  uploadDir: string;\n  maxFileSize: number;\n  allowedExtensions: string[];\n  allowedMimeTypes: string[];\n}\n\nexport interface UploadedFile {\n  originalName: string;\n  savedPath: string;\n  size: number;\n  mimeType: string;\n  hash: string;\n}\n\nexport interface FileMetadata {\n  name: string;\n  size: number;\n  type: string;\n}\n\nconst DEFAULT_CONFIG: UploadConfig = {\n  uploadDir: './uploads',\n  maxFileSize: 10 * 1024 * 1024, // 10MB\n  allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx'],\n  allowedMimeTypes: [\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'application/pdf',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  ],\n};\n\nexport function getFileExtension(filename: string): string {\n  return path.extname(filename).toLowerCase();\n}\n\nexport function generateUniqueFilename(originalName: string): string {\n  const ext = getFileExtension(originalName);\n  const timestamp = Date.now();\n  const random = crypto.randomBytes(8).toString('hex');\n  return `${timestamp}_${random}${ext}`;\n}\n\nexport function sanitizeFilename(filename: string): string {\n  return filename\n    .replace(/[^a-zA-Z0-9._-]/g, '_')\n    .replace(/_{2,}/g, '_');\n}\n\nexport async function calculateFileHash(buffer: Buffer): Promise<string> {\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}\n\nexport class FileUploadHandler {\n  private config: UploadConfig;\n\n  constructor(config: Partial<UploadConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async ensureUploadDir(): Promise<void> {\n    await fs.mkdir(this.config.uploadDir, { recursive: true });\n  }\n\n  validateExtension(filename: string): boolean {\n    const ext = getFileExtension(filename);\n    return this.config.allowedExtensions.includes(ext);\n  }\n\n  validateMimeType(mimeType: string): boolean {\n    return this.config.allowedMimeTypes.includes(mimeType);\n  }\n\n  validateFileSize(size: number): boolean {\n    return size <= this.config.maxFileSize;\n  }\n\n  async saveFile(\n    buffer: Buffer,\n    metadata: FileMetadata\n  ): Promise<UploadedFile> {\n    await this.ensureUploadDir();\n\n    if (!this.validateExtension(metadata.name)) {\n      throw new Error(`File extension not allowed: ${getFileExtension(metadata.name)}`);\n    }\n\n    if (!this.validateMimeType(metadata.type)) {\n      throw new Error(`MIME type not allowed: ${metadata.type}`);\n    }\n\n    if (!this.validateFileSize(metadata.size)) {\n      throw new Error(`File size exceeds limit: ${metadata.size} bytes`);\n    }\n\n    const sanitized = sanitizeFilename(metadata.name);\n    const filename = generateUniqueFilename(sanitized);\n    const filepath = path.join(this.config.uploadDir, filename);\n\n    await fs.writeFile(filepath, buffer);\n\n    const hash = await calculateFileHash(buffer);\n\n    return {\n      originalName: metadata.name,\n      savedPath: filepath,\n      size: buffer.length,\n      mimeType: metadata.type,\n      hash,\n    };\n  }\n\n  async deleteFile(filepath: string): Promise<void> {\n    const fullPath = path.join(this.config.uploadDir, filepath);\n    await fs.unlink(fullPath);\n  }\n\n  async getFile(filepath: string): Promise<Buffer> {\n    const fullPath = path.join(this.config.uploadDir, filepath);\n    return fs.readFile(fullPath);\n  }\n\n  async listFiles(): Promise<string[]> {\n    return fs.readdir(this.config.uploadDir);\n  }\n\n  getConfig(): UploadConfig {\n    return { ...this.config };\n  }\n}\n\nexport function createUploadHandler(config?: Partial<UploadConfig>): FileUploadHandler {\n  return new FileUploadHandler(config);\n}\n",
          "patchWithLinesStr": "## file: 'packages/upload/src/handlers/FileUploadHandler.ts'\n\n@@ -0,0 +1,142 @@\n__new hunk__\n1 +import * as path from 'path';\n2 +import * as fs from 'fs/promises';\n3 +import * as crypto from 'crypto';\n4 +\n5 +export interface UploadConfig {\n6 +  uploadDir: string;\n7 +  maxFileSize: number;\n8 +  allowedExtensions: string[];\n9 +  allowedMimeTypes: string[];\n10 +}\n11 +\n12 +export interface UploadedFile {\n13 +  originalName: string;\n14 +  savedPath: string;\n15 +  size: number;\n16 +  mimeType: string;\n17 +  hash: string;\n18 +}\n19 +\n20 +export interface FileMetadata {\n21 +  name: string;\n22 +  size: number;\n23 +  type: string;\n24 +}\n25 +\n26 +const DEFAULT_CONFIG: UploadConfig = {\n27 +  uploadDir: './uploads',\n28 +  maxFileSize: 10 * 1024 * 1024, // 10MB\n29 +  allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx'],\n30 +  allowedMimeTypes: [\n31 +    'image/jpeg',\n32 +    'image/png',\n33 +    'image/gif',\n34 +    'application/pdf',\n35 +    'application/msword',\n36 +    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n37 +  ],\n38 +};\n39 +\n40 +export function getFileExtension(filename: string): string {\n41 +  return path.extname(filename).toLowerCase();\n42 +}\n43 +\n44 +export function generateUniqueFilename(originalName: string): string {\n45 +  const ext = getFileExtension(originalName);\n46 +  const timestamp = Date.now();\n47 +  const random = crypto.randomBytes(8).toString('hex');\n48 +  return `${timestamp}_${random}${ext}`;\n49 +}\n50 +\n51 +export function sanitizeFilename(filename: string): string {\n52 +  return filename\n53 +    .replace(/[^a-zA-Z0-9._-]/g, '_')\n54 +    .replace(/_{2,}/g, '_');\n55 +}\n56 +\n57 +export async function calculateFileHash(buffer: Buffer): Promise<string> {\n58 +  return crypto.createHash('sha256').update(buffer).digest('hex');\n59 +}\n60 +\n61 +export class FileUploadHandler {\n62 +  private config: UploadConfig;\n63 +\n64 +  constructor(config: Partial<UploadConfig> = {}) {\n65 +    this.config = { ...DEFAULT_CONFIG, ...config };\n66 +  }\n67 +\n68 +  async ensureUploadDir(): Promise<void> {\n69 +    await fs.mkdir(this.config.uploadDir, { recursive: true });\n70 +  }\n71 +\n72 +  validateExtension(filename: string): boolean {\n73 +    const ext = getFileExtension(filename);\n74 +    return this.config.allowedExtensions.includes(ext);\n75 +  }\n76 +\n77 +  validateMimeType(mimeType: string): boolean {\n78 +    return this.config.allowedMimeTypes.includes(mimeType);\n79 +  }\n80 +\n81 +  validateFileSize(size: number): boolean {\n82 +    return size <= this.config.maxFileSize;\n83 +  }\n84 +\n85 +  async saveFile(\n86 +    buffer: Buffer,\n87 +    metadata: FileMetadata\n88 +  ): Promise<UploadedFile> {\n89 +    await this.ensureUploadDir();\n90 +\n91 +    if (!this.validateExtension(metadata.name)) {\n92 +      throw new Error(`File extension not allowed: ${getFileExtension(metadata.name)}`);\n93 +    }\n94 +\n95 +    if (!this.validateMimeType(metadata.type)) {\n96 +      throw new Error(`MIME type not allowed: ${metadata.type}`);\n97 +    }\n98 +\n99 +    if (!this.validateFileSize(metadata.size)) {\n100 +      throw new Error(`File size exceeds limit: ${metadata.size} bytes`);\n101 +    }\n102 +\n103 +    const sanitized = sanitizeFilename(metadata.name);\n104 +    const filename = generateUniqueFilename(sanitized);\n105 +    const filepath = path.join(this.config.uploadDir, filename);\n106 +\n107 +    await fs.writeFile(filepath, buffer);\n108 +\n109 +    const hash = await calculateFileHash(buffer);\n110 +\n111 +    return {\n112 +      originalName: metadata.name,\n113 +      savedPath: filepath,\n114 +      size: buffer.length,\n115 +      mimeType: metadata.type,\n116 +      hash,\n117 +    };\n118 +  }\n119 +\n120 +  async deleteFile(filepath: string): Promise<void> {\n121 +    const fullPath = path.join(this.config.uploadDir, filepath);\n122 +    await fs.unlink(fullPath);\n123 +  }\n124 +\n125 +  async getFile(filepath: string): Promise<Buffer> {\n126 +    const fullPath = path.join(this.config.uploadDir, filepath);\n127 +    return fs.readFile(fullPath);\n128 +  }\n129 +\n130 +  async listFiles(): Promise<string[]> {\n131 +    return fs.readdir(this.config.uploadDir);\n132 +  }\n133 +\n134 +  getConfig(): UploadConfig {\n135 +    return { ...this.config };\n136 +  }\n137 +}\n138 +\n139 +export function createUploadHandler(config?: Partial<UploadConfig>): FileUploadHandler {\n140 +  return new FileUploadHandler(config);\n141 +}\n142 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/upload/src/handlers/FileUploadHandler.ts\",\"relevantLinesStart\":106,\"relevantLinesEnd\":114},{\"relevantFile\":\"packages/upload/src/handlers/FileUploadHandler.ts\",\"relevantLinesStart\":91,\"relevantLinesEnd\":93}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"async deleteFile(filepath: string): Promise<void> {\\n    const fullPath = path.join(this.config.uploadDir, filepath);\\n    await fs.unlink(fullPath);\\n  }\\n\\n  async getFile(filepath: string): Promise<Buffer> {\\n    const fullPath = path.join(this.config.uploadDir, filepath);\\n    return fs.readFile(fullPath);\\n  }\",\n    \"improvedCode\": \"async deleteFile(filepath: string): Promise<void> {\\n    const fullPath = path.resolve(this.config.uploadDir, filepath);\\n    const uploadDirResolved = path.resolve(this.config.uploadDir);\\n    if (!fullPath.startsWith(uploadDirResolved + path.sep)) {\\n      throw new Error('Invalid file path');\\n    }\\n    await fs.unlink(fullPath);\\n  }\\n\\n  async getFile(filepath: string): Promise<Buffer> {\\n    const fullPath = path.resolve(this.config.uploadDir, filepath);\\n    const uploadDirResolved = path.resolve(this.config.uploadDir);\\n    if (!fullPath.startsWith(uploadDirResolved + path.sep)) {\\n      throw new Error('Invalid file path');\\n    }\\n    return fs.readFile(fullPath);\\n  }\",\n    \"relevantFile\": \"packages/upload/src/handlers/FileUploadHandler.ts\",\n    \"relevantLinesEnd\": 114,\n    \"suggestionContent\": \"The `deleteFile` and `getFile` methods are vulnerable to path traversal attacks. An attacker can pass `../../../etc/passwd` as the filepath parameter. Using `path.join(uploadDir, filepath)` doesn't prevent escaping the upload directory. Need to validate that the resolved path is still within the upload directory.\",\n    \"oneSentenceSummary\": \"Path traversal vulnerability - can read/delete files outside upload directory\",\n    \"relevantLinesStart\": 106\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"if (!this.validateFileSize(metadata.size)) {\\n      throw new Error(`File size exceeds limit: ${metadata.size} bytes`);\\n    }\",\n    \"improvedCode\": \"if (!this.validateFileSize(buffer.length)) {\\n      throw new Error(`File size exceeds limit: ${buffer.length} bytes`);\\n    }\\n    \\n    if (buffer.length !== metadata.size) {\\n      throw new Error(`Size mismatch: claimed ${metadata.size}, actual ${buffer.length}`);\\n    }\",\n    \"relevantFile\": \"packages/upload/src/handlers/FileUploadHandler.ts\",\n    \"relevantLinesEnd\": 93,\n    \"suggestionContent\": \"The `saveFile` method validates `metadata.size` but then writes `buffer` without checking if `buffer.length` matches `metadata.size`. An attacker can claim a small file size in metadata while sending a large buffer, bypassing the size limit check.\",\n    \"oneSentenceSummary\": \"Size validation uses metadata instead of actual buffer length - bypass possible\",\n    \"relevantLinesStart\": 91\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      },
      {
        "description": "Example 20: packages/forms/src/validators/FormValidator.ts",
        "vars": {
          "fileContent": "export interface FieldValidation {\n  field: string;\n  isValid: boolean;\n  errors: string[];\n}\n\nexport interface FormValidationResult {\n  isValid: boolean;\n  fields: FieldValidation[];\n  summary: string;\n}\n\nexport interface ValidationRule {\n  name: string;\n  message: string;\n  validate: (value: string, formData?: Record<string, string>) => boolean;\n}\n\nconst emailRegex = /^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,}|[0-9]{1,3})(\\]?)$/;\nconst passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$/;\nconst urlRegex = /^(https?:\\/\\/)?(([\\da-z\\.-]+)\\.([a-z\\.]{2,6})|localhost)([\\/\\w \\.-]*)*\\/?$/;\n\nexport const commonRules: Record<string, ValidationRule> = {\n  required: {\n    name: 'required',\n    message: 'This field is required',\n    validate: (value) => value.trim().length > 0,\n  },\n  email: {\n    name: 'email',\n    message: 'Please enter a valid email address',\n    validate: (value) => emailRegex.test(value),\n  },\n  password: {\n    name: 'password',\n    message: 'Password must be at least 8 characters with uppercase, lowercase, number and special character',\n    validate: (value) => passwordRegex.test(value),\n  },\n  url: {\n    name: 'url',\n    message: 'Please enter a valid URL',\n    validate: (value) => urlRegex.test(value),\n  },\n  maxLength: {\n    name: 'maxLength',\n    message: 'Value exceeds maximum length',\n    validate: (value) => value.length <= 255,\n  },\n};\n\nexport function createMinLengthRule(min: number): ValidationRule {\n  return {\n    name: `minLength_${min}`,\n    message: `Must be at least ${min} characters`,\n    validate: (value) => value.length >= min,\n  };\n}\n\nexport function createMatchRule(fieldName: string): ValidationRule {\n  return {\n    name: `match_${fieldName}`,\n    message: `Must match ${fieldName}`,\n    validate: (value, formData) => formData?.[fieldName] === value,\n  };\n}\n\nexport function createPatternRule(pattern: RegExp, message: string): ValidationRule {\n  return {\n    name: 'pattern',\n    message,\n    validate: (value) => pattern.test(value),\n  };\n}\n\nexport class FormValidator {\n  private rules: Map<string, ValidationRule[]> = new Map();\n  private customMessages: Map<string, string> = new Map();\n\n  addRule(field: string, rule: ValidationRule): this {\n    const existing = this.rules.get(field) || [];\n    existing.push(rule);\n    this.rules.set(field, existing);\n    return this;\n  }\n\n  addRules(field: string, rules: ValidationRule[]): this {\n    rules.forEach(rule => this.addRule(field, rule));\n    return this;\n  }\n\n  setCustomMessage(field: string, message: string): this {\n    this.customMessages.set(field, message);\n    return this;\n  }\n\n  validateField(field: string, value: string, formData?: Record<string, string>): FieldValidation {\n    const rules = this.rules.get(field) || [];\n    const errors: string[] = [];\n\n    for (const rule of rules) {\n      if (!rule.validate(value, formData)) {\n        const customMessage = this.customMessages.get(`${field}_${rule.name}`);\n        errors.push(customMessage || rule.message);\n      }\n    }\n\n    return {\n      field,\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  validate(formData: Record<string, string>): FormValidationResult {\n    const fields: FieldValidation[] = [];\n    let allValid = true;\n\n    for (const [field, _] of this.rules) {\n      const value = formData[field] || '';\n      const validation = this.validateField(field, value, formData);\n      fields.push(validation);\n\n      if (!validation.isValid) {\n        allValid = false;\n      }\n    }\n\n    return {\n      isValid: allValid,\n      fields,\n      summary: allValid\n        ? 'All fields are valid'\n        : `Found errors in: ${fields.filter(f => !f.isValid).map(f => f.field).join(', ')}`,\n    };\n  }\n\n  getErrorSummaryHtml(result: FormValidationResult): string {\n    if (result.isValid) {\n      return '<div class=\"success\">Form is valid!</div>';\n    }\n\n    const errorItems = result.fields\n      .filter(f => !f.isValid)\n      .map(f => `<li><strong>${f.field}:</strong> ${f.errors.join(', ')}</li>`)\n      .join('');\n\n    return `<div class=\"error-summary\"><ul>${errorItems}</ul></div>`;\n  }\n\n  comparePasswords(password: string, storedHash: string): boolean {\n    if (password.length !== storedHash.length) {\n      return false;\n    }\n\n    let result = true;\n    for (let i = 0; i < password.length; i++) {\n      if (password[i] !== storedHash[i]) {\n        result = false;\n      }\n    }\n    return result;\n  }\n\n  reset(): void {\n    this.rules.clear();\n    this.customMessages.clear();\n  }\n}\n\nexport function validateEmail(email: string): boolean {\n  return emailRegex.test(email);\n}\n\nexport function validatePassword(password: string): boolean {\n  return passwordRegex.test(password);\n}\n\nexport default FormValidator;\n",
          "patchWithLinesStr": "## file: 'packages/forms/src/validators/FormValidator.ts'\n\n@@ -0,0 +1,179 @@\n__new hunk__\n1 +export interface FieldValidation {\n2 +  field: string;\n3 +  isValid: boolean;\n4 +  errors: string[];\n5 +}\n6 +\n7 +export interface FormValidationResult {\n8 +  isValid: boolean;\n9 +  fields: FieldValidation[];\n10 +  summary: string;\n11 +}\n12 +\n13 +export interface ValidationRule {\n14 +  name: string;\n15 +  message: string;\n16 +  validate: (value: string, formData?: Record<string, string>) => boolean;\n17 +}\n18 +\n19 +const emailRegex = /^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,}|[0-9]{1,3})(\\]?)$/;\n20 +const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$/;\n21 +const urlRegex = /^(https?:\\/\\/)?(([\\da-z\\.-]+)\\.([a-z\\.]{2,6})|localhost)([\\/\\w \\.-]*)*\\/?$/;\n22 +\n23 +export const commonRules: Record<string, ValidationRule> = {\n24 +  required: {\n25 +    name: 'required',\n26 +    message: 'This field is required',\n27 +    validate: (value) => value.trim().length > 0,\n28 +  },\n29 +  email: {\n30 +    name: 'email',\n31 +    message: 'Please enter a valid email address',\n32 +    validate: (value) => emailRegex.test(value),\n33 +  },\n34 +  password: {\n35 +    name: 'password',\n36 +    message: 'Password must be at least 8 characters with uppercase, lowercase, number and special character',\n37 +    validate: (value) => passwordRegex.test(value),\n38 +  },\n39 +  url: {\n40 +    name: 'url',\n41 +    message: 'Please enter a valid URL',\n42 +    validate: (value) => urlRegex.test(value),\n43 +  },\n44 +  maxLength: {\n45 +    name: 'maxLength',\n46 +    message: 'Value exceeds maximum length',\n47 +    validate: (value) => value.length <= 255,\n48 +  },\n49 +};\n50 +\n51 +export function createMinLengthRule(min: number): ValidationRule {\n52 +  return {\n53 +    name: `minLength_${min}`,\n54 +    message: `Must be at least ${min} characters`,\n55 +    validate: (value) => value.length >= min,\n56 +  };\n57 +}\n58 +\n59 +export function createMatchRule(fieldName: string): ValidationRule {\n60 +  return {\n61 +    name: `match_${fieldName}`,\n62 +    message: `Must match ${fieldName}`,\n63 +    validate: (value, formData) => formData?.[fieldName] === value,\n64 +  };\n65 +}\n66 +\n67 +export function createPatternRule(pattern: RegExp, message: string): ValidationRule {\n68 +  return {\n69 +    name: 'pattern',\n70 +    message,\n71 +    validate: (value) => pattern.test(value),\n72 +  };\n73 +}\n74 +\n75 +export class FormValidator {\n76 +  private rules: Map<string, ValidationRule[]> = new Map();\n77 +  private customMessages: Map<string, string> = new Map();\n78 +\n79 +  addRule(field: string, rule: ValidationRule): this {\n80 +    const existing = this.rules.get(field) || [];\n81 +    existing.push(rule);\n82 +    this.rules.set(field, existing);\n83 +    return this;\n84 +  }\n85 +\n86 +  addRules(field: string, rules: ValidationRule[]): this {\n87 +    rules.forEach(rule => this.addRule(field, rule));\n88 +    return this;\n89 +  }\n90 +\n91 +  setCustomMessage(field: string, message: string): this {\n92 +    this.customMessages.set(field, message);\n93 +    return this;\n94 +  }\n95 +\n96 +  validateField(field: string, value: string, formData?: Record<string, string>): FieldValidation {\n97 +    const rules = this.rules.get(field) || [];\n98 +    const errors: string[] = [];\n99 +\n100 +    for (const rule of rules) {\n101 +      if (!rule.validate(value, formData)) {\n102 +        const customMessage = this.customMessages.get(`${field}_${rule.name}`);\n103 +        errors.push(customMessage || rule.message);\n104 +      }\n105 +    }\n106 +\n107 +    return {\n108 +      field,\n109 +      isValid: errors.length === 0,\n110 +      errors,\n111 +    };\n112 +  }\n113 +\n114 +  validate(formData: Record<string, string>): FormValidationResult {\n115 +    const fields: FieldValidation[] = [];\n116 +    let allValid = true;\n117 +\n118 +    for (const [field, _] of this.rules) {\n119 +      const value = formData[field] || '';\n120 +      const validation = this.validateField(field, value, formData);\n121 +      fields.push(validation);\n122 +\n123 +      if (!validation.isValid) {\n124 +        allValid = false;\n125 +      }\n126 +    }\n127 +\n128 +    return {\n129 +      isValid: allValid,\n130 +      fields,\n131 +      summary: allValid\n132 +        ? 'All fields are valid'\n133 +        : `Found errors in: ${fields.filter(f => !f.isValid).map(f => f.field).join(', ')}`,\n134 +    };\n135 +  }\n136 +\n137 +  getErrorSummaryHtml(result: FormValidationResult): string {\n138 +    if (result.isValid) {\n139 +      return '<div class=\"success\">Form is valid!</div>';\n140 +    }\n141 +\n142 +    const errorItems = result.fields\n143 +      .filter(f => !f.isValid)\n144 +      .map(f => `<li><strong>${f.field}:</strong> ${f.errors.join(', ')}</li>`)\n145 +      .join('');\n146 +\n147 +    return `<div class=\"error-summary\"><ul>${errorItems}</ul></div>`;\n148 +  }\n149 +\n150 +  comparePasswords(password: string, storedHash: string): boolean {\n151 +    if (password.length !== storedHash.length) {\n152 +      return false;\n153 +    }\n154 +\n155 +    let result = true;\n156 +    for (let i = 0; i < password.length; i++) {\n157 +      if (password[i] !== storedHash[i]) {\n158 +        result = false;\n159 +      }\n160 +    }\n161 +    return result;\n162 +  }\n163 +\n164 +  reset(): void {\n165 +    this.rules.clear();\n166 +    this.customMessages.clear();\n167 +  }\n168 +}\n169 +\n170 +export function validateEmail(email: string): boolean {\n171 +  return emailRegex.test(email);\n172 +}\n173 +\n174 +export function validatePassword(password: string): boolean {\n175 +  return passwordRegex.test(password);\n176 +}\n177 +\n178 +export default FormValidator;\n179 +\n__old hunk__\n",
          "prSummary": "",
          "referenceBugs": "[{\"relevantFile\":\"packages/forms/src/validators/FormValidator.ts\",\"relevantLinesStart\":127,\"relevantLinesEnd\":130},{\"relevantFile\":\"packages/forms/src/validators/FormValidator.ts\",\"relevantLinesStart\":21,\"relevantLinesEnd\":21},{\"relevantFile\":\"packages/forms/src/validators/FormValidator.ts\",\"relevantLinesStart\":133,\"relevantLinesEnd\":145}]",
          "referenceCodeSuggestions": "[\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \".map(f => `<li><strong>${f.field}:</strong> ${f.errors.join(', ')}</li>`)\",\n    \"improvedCode\": \".map(f => `<li><strong>${escapeHtml(f.field)}:</strong> ${escapeHtml(f.errors.join(', '))}</li>`)\",\n    \"relevantFile\": \"packages/forms/src/validators/FormValidator.ts\",\n    \"relevantLinesEnd\": 130,\n    \"suggestionContent\": \"The `getErrorSummaryHtml` method directly interpolates field names and error messages into HTML without escaping. If an attacker can control field names or validation messages (e.g., through a malicious form configuration or i18n injection), they can inject arbitrary HTML/JavaScript, leading to XSS vulnerabilities.\",\n    \"oneSentenceSummary\": \"XSS vulnerability - field names and errors interpolated into HTML without escaping\",\n    \"relevantLinesStart\": 127\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"const urlRegex = /^(https?:\\\\/\\\\/)?(([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]{2,6})|localhost)([\\\\/\\\\w \\\\.-]*)*\\\\/?$/;\",\n    \"improvedCode\": \"const urlRegex = /^(https?:\\\\/\\\\/)?([\\\\da-z\\\\.-]+\\\\.([a-z]{2,6})|localhost)(\\\\/[\\\\w\\\\.-]*)*\\\\/?$/;\",\n    \"relevantFile\": \"packages/forms/src/validators/FormValidator.ts\",\n    \"relevantLinesEnd\": 21,\n    \"suggestionContent\": \"The `urlRegex` pattern `([\\\\/\\\\w \\\\.-]*)*` contains nested quantifiers that can cause catastrophic backtracking (ReDoS). A malicious input like 'http://a.aa/' followed by many spaces can cause the regex engine to hang for an extremely long time, enabling denial-of-service attacks.\",\n    \"oneSentenceSummary\": \"ReDoS vulnerability - nested quantifiers in URL regex cause catastrophic backtracking\",\n    \"relevantLinesStart\": 21\n  },\n  {\n    \"label\": \"bug\",\n    \"language\": \"TypeScript\",\n    \"existingCode\": \"comparePasswords(password: string, storedHash: string): boolean {\\n    if (password.length !== storedHash.length) {\\n      return false;\\n    }\\n\\n    let result = true;\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] !== storedHash[i]) {\\n        result = false;\\n      }\\n    }\\n    return result;\\n  }\",\n    \"improvedCode\": \"comparePasswords(password: string, storedHash: string): boolean {\\n    const encoder = new TextEncoder();\\n    const a = encoder.encode(password);\\n    const b = encoder.encode(storedHash);\\n    if (a.length !== b.length) {\\n      // Still compare to maintain constant time\\n      crypto.subtle.timingSafeEqual?.(a, a);\\n      return false;\\n    }\\n    return crypto.subtle.timingSafeEqual?.(a, b) ?? false;\\n  }\",\n    \"relevantFile\": \"packages/forms/src/validators/FormValidator.ts\",\n    \"relevantLinesEnd\": 145,\n    \"suggestionContent\": \"The `comparePasswords` method attempts constant-time comparison but fails. The early return when lengths differ leaks length information. Also, even when lengths match, the JavaScript engine may optimize the loop and short-circuit when `result` becomes false. Use a proper constant-time comparison function like `crypto.timingSafeEqual`.\",\n    \"oneSentenceSummary\": \"Timing attack vulnerability - password comparison is not constant-time\",\n    \"relevantLinesStart\": 133\n  }\n]"
        },
        "assert": [
          {
            "type": "javascript",
            "value": "file://parse-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://judge-assertion.js"
          },
          {
            "type": "javascript",
            "value": "file://line-accuracy-assertion.js"
          }
        ]
      }
    ],
    "scenarios": [],
    "env": {},
    "outputPath": [
      "./results/output.json"
    ],
    "extensions": [],
    "metadata": {},
    "evaluateOptions": {}
  },
  "shareableUrl": null,
  "metadata": {
    "promptfooVersion": "0.120.22",
    "nodeVersion": "v24.6.0",
    "platform": "darwin",
    "arch": "arm64",
    "exportedAt": "2026-02-06T19:34:46.651Z",
    "evaluationCreatedAt": "2026-02-06T19:33:51.671Z"
  }
}